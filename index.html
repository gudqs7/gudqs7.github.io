<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gudqs7.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="心累没钱躺尸中">
<meta property="og:type" content="website">
<meta property="og:title" content="gudqs7&#39;s note">
<meta property="og:url" content="https://gudqs7.github.io/index.html">
<meta property="og:site_name" content="gudqs7&#39;s note">
<meta property="og:description" content="心累没钱躺尸中">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="gudqs7">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gudqs7.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>gudqs7's note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gudqs7's note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">心累没钱躺尸中</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/23/source-code-spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/23/source-code-spring/" class="post-title-link" itemprop="url">Spring 源码笔记</a>
        </h2>

        <div class="post-meta">
			
				<i class="fa fa-thumb-tack"></i>
				<font color="RED">置顶</font>
				<span class="post-meta-divider">|</span>
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-23 18:28:28" itemprop="dateCreated datePublished" datetime="2021-01-23T18:28:28+08:00">2021-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-25 23:18:44" itemprop="dateModified" datetime="2021-01-25T23:18:44+08:00">2021-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/23/source-code-spring/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/23/source-code-spring/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring源码分析"><a href="#Spring源码分析" class="headerlink" title="Spring源码分析"></a>Spring源码分析</h1><h2 id="关键类介绍"><a href="#关键类介绍" class="headerlink" title="关键类介绍"></a>关键类介绍</h2><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">万能的 applicationContext, 但实际上各种能力都是依赖于其他的类, 比如 getBean 是 beanFactory 的, publishEvent 是事件广播器的, 等等. 其本身是一个综合体, 整合这些能力, 便于开发者调用和理解.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面列一下相关的接口, 抽象类, 和具体类</span></span><br><span class="line">ApplicationContext</span><br><span class="line">	是一个只读的 bean 容器</span><br><span class="line">	可以加载解析配置文件(如xml)</span><br><span class="line">	可以发布事件和注册监听</span><br><span class="line">	具有国际化消息处理能力</span><br><span class="line">ConfigurableApplicationContext</span><br><span class="line">	是一个具有可配置能力的 容器(可设置各个参数, 如id, 父容器)</span><br><span class="line">	具有容器生命周期概念, 如启动,停止,关闭.</span><br><span class="line">AbstractApplicationContext</span><br><span class="line">	模板方法模式的抽象类, 定义了容器的模板(refresh方法), 但由具体的子类实现部分方法</span><br><span class="line">	管理Bean和BeanFactory的PostProcessor</span><br><span class="line">	管理事件的监听和处理</span><br><span class="line">AbstractRefreshableApplicationContext</span><br><span class="line">	为可重复刷新的容器提供基类</span><br><span class="line">	加入了BeanFactory的管理(创建/关闭等)</span><br><span class="line">AbstractRefreshableConfigApplicationContext</span><br><span class="line">	加入了configLocation字段, 用于某些容器初始化BeanFactory和Bean</span><br><span class="line">AbstractXmlApplicationContext</span><br><span class="line">	定义了读取xml配置文件来加载BeanFactory的代码, 使得子类只需提供配置文件地址或Resource</span><br><span class="line">ClassPathXmlApplicationContext</span><br><span class="line">	继承基类, 提供配置文件地址的构造方法, 调用refresh加载BeanFactory</span><br></pre></td></tr></table></figure>

<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">1.核心中的核心, 加载和管理 beanDefinitions(Bean配置信息), 创建和管理 bean 对象实例, 注册和管理 BeanPostProcessor(Bean扩展)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面列一下相关的接口, 抽象类, 和具体类</span></span><br><span class="line">BeanFactory</span><br><span class="line">  定义了 Bean 的基础操作接口, 如 getBean, getType, isSingleton 等</span><br><span class="line"></span><br><span class="line">SingletonBeanRegistry</span><br><span class="line">  定义了单例对象的操作接口 (注册/获取/是否已存在) </span><br><span class="line"></span><br><span class="line">HierarchicalBeanFactory</span><br><span class="line">  定义了父 BeanFactory 的相关操作接口(获取)</span><br><span class="line"></span><br><span class="line">ConfigurableBeanFactory</span><br><span class="line">  定义了对 BeanFactory 做各种配置的操作接口, 包括 BeanPostProcessor, setParentBeanFactory, destroyBean, registerAlias, resolveAliases 等</span><br><span class="line"></span><br><span class="line">DefaultSingletonBeanRegistry</span><br><span class="line">  实现了 SingletonBeanRegistry 接口, 即实现了单例对象的缓存管理, 包括一级/二级/三级(二级三级只依赖循环用上的两个缓存)</span><br><span class="line">  </span><br><span class="line">FactoryBeanRegistrySupport</span><br><span class="line">  继承了 DefaultSingletonBeanRegistry</span><br><span class="line">	实现对使用 FactoryBean 存储和获取 bean 对象实例方式的支持</span><br><span class="line">	</span><br><span class="line">AbstractBeanFactory</span><br><span class="line">  继承了 FactoryBeanRegistrySupport</span><br><span class="line">  实现了 BeanFactory/HierarchicalBeanFactory/ConfigurableBeanFactory 定义的接口</span><br><span class="line">  实现了具体 getBean, 包括缓存管理等</span><br><span class="line">  </span><br><span class="line">AutowireCapableBeanFactory</span><br><span class="line">  定义了根据 class 类型获取 BeanDefinition 信息以及 Bean 对象的接口</span><br><span class="line"></span><br><span class="line">AbstractAutowireCapableBeanFactory</span><br><span class="line">  继承自 AbstractBeanFactory </span><br><span class="line">  实现了 AutowireCapableBeanFactory 中定义的方法(就是实现了根据 class 获取 bean 或 BeanDefinition)</span><br><span class="line">  实现了 createBean, 也就是真正的实例化一个对象的过程, 包括实例化, 为需要赋值的字段注入相应的值</span><br><span class="line">  同时触发了 BeanPostProcessor 的方法调用</span><br><span class="line">  </span><br><span class="line">BeanDefinitionRegistry</span><br><span class="line">  定义了 BeanDefinition 的注册/获取/移除</span><br><span class="line">  </span><br><span class="line">ListableBeanFactory</span><br><span class="line">	定义了 BeanDefinition 的可遍历性</span><br><span class="line">  </span><br><span class="line">ConfigurableListableBeanFactory</span><br><span class="line">  结合 ListableBeanFactory 和 ConfigurableBeanFactory 并补充完善了几个相关接口 (如 getBeanNamesIterator 接口 )</span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory</span><br><span class="line">  继承了 AbstractAutowireCapableBeanFactory</span><br><span class="line">  实现了 BeanDefinitionRegistry/ConfigurableListableBeanFactory 的接口</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 总结:</span></span><br><span class="line">定义处:</span><br><span class="line">BeanFactory(getBean)</span><br><span class="line">SingletonBeanRegistry(addSingleton)</span><br><span class="line">HierarchicalBeanFactory(getParentBeanFactory)</span><br><span class="line">ConfigurableBeanFactory(addBeanPostProcessor)</span><br><span class="line">AutowireCapableBeanFactory(autowireBean)</span><br><span class="line">BeanDefinitionRegistry(registerBeanDefinition)</span><br><span class="line">ListableBeanFactory(getBeanDefinitionNames)</span><br><span class="line">ConfigurableListableBeanFactory(getBeanNamesIterator)</span><br><span class="line"></span><br><span class="line">实现处:</span><br><span class="line">DefaultSingletonBeanRegistry(registerSingleton)</span><br><span class="line">FactoryBeanRegistrySupport(getObjectFromFactoryBean)</span><br><span class="line">AbstractBeanFactory(doGetBean)</span><br><span class="line">AbstractAutowireCapableBeanFactory(createBean)</span><br><span class="line">DefaultListableBeanFactory(registerBeanDefinition)</span><br></pre></td></tr></table></figure>





<h2 id="容器初始化过程"><a href="#容器初始化过程" class="headerlink" title="容器初始化过程"></a>容器初始化过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.setParent(): 处理父容器 </span><br><span class="line">2.setConfigLocations(): 解析并设置xml配置文件路径</span><br><span class="line">3.refresh(): 创建 beanFactory 对象并初始化, 读取 xml 配置文件得到 beanDefinitions, 接着处理两种 PostProcessor, 然后添加国际化处理器和事件广播器以及相应的初始化和一些处理, 最后实例化单例的 bean 等等.</span><br><span class="line"></span><br><span class="line"><span class="comment">#外圈结束, 再看 refresh() 里面的每个方法</span></span><br><span class="line">1.prepareRefresh(): 准备工作, 一些字段值的设置和处理.</span><br><span class="line">2.obtainFreshBeanFactory(): 创建一个 beanFactory 对象并注册到 applicationContext (即赋值到字段上), 然后解析 xml 配置文件(或注解配置)的信息, 解析得到 beanDefinitions 并注册到容器中.</span><br><span class="line">3.然后是一些对 beanFactory 对象的完善配置的代码</span><br><span class="line">4.扫描并执行 BeanFactoryPostProcessor(其作用是为beanFactory对象添加东西提供扩展性), 其中我认识的就只有 ConfigurationClassPostProcessor(这个类作用就是解析 @Configuration/@Component/@Import/@ImportSource/@ComponentScan等基础注解).</span><br><span class="line">5.扫描实现了 BeanPostProcessor 接口的 bean 并注册到 beanFactory 中存起来, 等 createBean 创建对象时会在对应的时机执行一些对应的方法(钩子). 常见的各种 XxxAware 就是靠这个实现的咯.</span><br><span class="line">6.接着, 初始化国际化资源处理器, 事件广播器, 并注册一些需要注册的事件(也注册容器内实现对应接口的 bean)</span><br><span class="line">7.处理一些 beanFactory 的配置, 接着为所有单例且非懒加载的(不就是默认策略嘛) bean 创建实例, 缓存起来.</span><br><span class="line">8.广播容器加载完成了的事件. 以及处理生命周期.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后总结下, 先创建容器, 再将根据配置文件解析得到 BeanDefinition 注册到容器中, 然后处理两大扩展(BeanFactoryPostProcessor/BeanPostProcessor), 接着是Spring的国际化, 以及相当有用的事件广播器, 最后实例化 bean. 整体感觉其实很简单, 但其实有大量的工作交给了 BeanPostProcessor.</p>
</blockquote>
<h3 id="超长源码分析过程"><a href="#超长源码分析过程" class="headerlink" title="超长源码分析过程"></a>超长源码分析过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先随便写个 main 方法, 如我写的, 可测试依赖循环问题和事件监听:</span></span><br><span class="line"><span class="comment">// 包名: cn.gudqs7.spring.tests, 改动则需同步修改xml哦</span></span><br><span class="line"><span class="comment">// 进入对应类代码: 快捷键 Cmd+Option+鼠标点击 (或 Ctrl+Alt+鼠标左键 ); 如果是接口松开 Option(或Alt)键</span></span><br><span class="line"></span><br><span class="line">Test.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ApplicationContext xmlContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application-wq.xml"</span>);</span><br><span class="line">		UserServiceImpl userService = xmlContext.getBean(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		userService.sayHi();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">application-wq.xml</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> <span class="keyword">default</span>-autowire=<span class="string">"byName"</span>&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean name=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.gudqs7.spring.tests.UserServiceImpl"</span>&gt;</span><br><span class="line">		&lt;property name="starter"&gt;&lt;ref bean="serverStarter"/&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;bean name=<span class="string">"serverStarter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.gudqs7.spring.tests.ServerStarter"</span>&gt;</span><br><span class="line">		&lt;property name="userService"&gt;&lt;ref bean="userService"/&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">UserServiceImpl.java</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> ServerStarter starter;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(starter);</span><br><span class="line">		System.out.println(<span class="string">"Hello Spring!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStarter</span><span class="params">(ServerStarter starter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.starter = starter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ServerStarter.java</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStarter</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Inject</span></span><br><span class="line">	<span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">		String applicationName = event.getApplicationContext().getApplicationName();</span><br><span class="line">		System.out.println(applicationName);</span><br><span class="line">		System.out.println(userService);</span><br><span class="line">		System.out.println(<span class="string">"========== started by gudqs7 =============="</span>);</span><br><span class="line">		System.out.println(<span class="string">"========== started by gudqs7 =============="</span>);</span><br><span class="line">		System.out.println(<span class="string">"========== started by gudqs7 =============="</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserServiceImpl userService)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userService = userService;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接下来, 进入ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String) 方法中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其跳转到了</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为容器的 parent 字段赋值, 若 parent 不为空, 且有 ConfigurableEnvironment, 则合并数据(将父容器有的加到子容器中)</span></span><br><span class="line">		<span class="comment">// 即执行了 org.springframework.context.support.AbstractApplicationContext.setParent()</span></span><br><span class="line">		<span class="keyword">super</span>(parent);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为 configLocations 字段赋值(告知配置文件位置), 赋值前会根据环境变量解析(此时环境变量中只有系统环境变量: 如JAVA_HOME).</span></span><br><span class="line">		setConfigLocations(configLocations);</span><br><span class="line">		<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">			<span class="comment">// 注释在下面</span></span><br><span class="line">      refresh();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后具体的看 refresh 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="comment">// 1.设置容器初始的一些属性(时间,状态)，初始化占位符数据源并校验所有 bean 所使用的占位符是否存在, 清空事件和监听</span></span><br><span class="line">		<span class="comment">// 2.清空重置旧的 beanFactory, 再创建新的 beanFactory 并通过解析 xml或注解 加载 beanDefinitions</span></span><br><span class="line">		<span class="comment">// 3.设置了一些 beanFactory 的属性, 添加了几个有用的 BeanPostProcessor, 还添加了几个 bean 到容器中(都是环境相关的 bean)</span></span><br><span class="line">		<span class="comment">// 4.子类对beanFactory 添加自己的特殊的 BeanPostProcessor (如servletContxt/servletConfig注入)</span></span><br><span class="line">		<span class="comment">// 5.扫描容器中实现了 BeanFactoryPostProcessor 接口的 bean 将其注册到 beanFactory 中并执行</span></span><br><span class="line">		<span class="comment">// 6.扫描容器中实现了 BeanPostProcessor 接口的 bean 将其注册到 beanFactory 但不执行(实例化 bean 对象那会有几个执行时机)</span></span><br><span class="line">		<span class="comment">// 7.创建一个国际化资源解析器并注册到 beanFactory; 创建一个事件广播器并注册到 beanFactory.</span></span><br><span class="line">		<span class="comment">// 8.调用子类的其他刷新时需要做的事情(模板方法)</span></span><br><span class="line">		<span class="comment">// 9.扫描容器中实现了 ApplicationListener 接口的 bean, 将其预存到广播器中但不执行</span></span><br><span class="line">		<span class="comment">//10.完成 beanFactory 的一些配置(包括终结一些东西, 如 setTempClassLoader(null) ); 将单例的 bean 创建出来放入容器中(未设置lazy-init=true)的 bean</span></span><br><span class="line">		<span class="comment">//11.广播 ContextRefreshedEvent 事件， 初始化LifeCycleProcessor及调用其 onRefresh 方法.</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			<span class="comment">// 设置容器初始的一些属性(时间,状态)，初始化占位符数据源并校验所有 bean 所使用的占位符是否存在, 清空事件和监听</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			<span class="comment">// 清空重置旧的 beanFactory, 再创建新的 beanFactory 并解析 xml或注解 加载 beanDefinitions</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			<span class="comment">// 设置了一些 beanFactory 的属性, 添加了几个有用的 BeanPostProcessor, 还添加了几个 bean 到容器中(都是环境相关的 bean)</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				<span class="comment">// 子类对beanFactory 添加自己的特殊的 BeanPostProcessor (如servletContxt/servletConfig注入)</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				<span class="comment">// 扫描容器中实现了 BeanFactoryPostProcessor 接口的 bean 将其注册到 beanFactory 中并执行</span></span><br><span class="line">				<span class="comment">//   扫描6次, 2(BeanDefinitionRegistry/BeanFactory) x 3(优先级:高/中/其他)</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				<span class="comment">// 扫描容器中实现了 BeanPostProcessor 接口的 bean 将其注册到 beanFactory 但不执行; 扫描6次: 2(MergedBeanDefinitionPostProcessor/其他) x 3(优先级: 高/中/其他)</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				<span class="comment">// 创建一个国际化资源解析器并注册到 beanFactory.</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				<span class="comment">// 创建一个事件广播器并注册到 beanFactory.</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				<span class="comment">// 调用子类的其他刷新时需要做的事情(模板方法)</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				<span class="comment">// 将可能存在的 applicationListeners 注册到事件广播器中(新建时是不存在的),</span></span><br><span class="line">				<span class="comment">// 然后扫描容器中实现了 ApplicationListener 接口的 bean, 将其预存到广播器中但不执行</span></span><br><span class="line">				<span class="comment">// 将之前 publishEvent() 想广播的事件广播出去, 然后字段 earlyApplicationEvents 赋值为空(代表之后可立即广播)</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				<span class="comment">// 完成 beanFactory 的一些配置(包括终结一些东西, 如 setTempClassLoader(null) )</span></span><br><span class="line">				<span class="comment">// 注册默认的表达式解析器(若无相应的bean存在)</span></span><br><span class="line">				<span class="comment">// 扫描容器中实现了 LoadTimeWeaverAware 接口的 bean, 并触发(getBean)之前注册过的 BeanPostProcessor</span></span><br><span class="line">				<span class="comment">// 将单例的 bean 创建出来放入容器中(未设置lazy-init=true)的 bean</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				<span class="comment">// 广播 ContextRefreshedEvent 事件， 初始化LifeCycleProcessor及调用其 onRefresh 方法.</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">							<span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				<span class="comment">// 销毁缓存的单例对象</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">				<span class="comment">// 变更状态</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				<span class="comment">// 清空公共工具产生的缓存(内存松一口气).</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我错了, 代码都放上去不如给个GitHub地址, 接下来省略代码吧, 只放注释😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挨个看里面的方法</span></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#prepareRefresh</span><br><span class="line">    <span class="comment">// 1.设置容器初始的一些属性, 如启动时间, 当前状态</span></span><br><span class="line">		<span class="comment">// 2.打印开始日志</span></span><br><span class="line">		<span class="comment">// 3.初始化占位符数据源</span></span><br><span class="line">		<span class="comment">// 4.校验所有 bean 所使用的占位符是否存在</span></span><br><span class="line">		<span class="comment">// 5.清空事件和监听</span></span><br><span class="line">		<span class="comment">// Switch to active.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</span><br><span class="line">    <span class="comment">// 1.存在旧的则先摧毁 bean 对象实例及缓存数据, 再将旧的置为 null</span></span><br><span class="line">		<span class="comment">// 2.创建一个新的 beanFactory 对象, 再设置 id及一些配置</span></span><br><span class="line">		<span class="comment">// 3.扫描并加载 beanDefinations</span></span><br><span class="line">		<span class="comment">// 4.设置这个新的 beanFactory 对象为 applicationContext 的 beanFactory 字段值.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</span><br><span class="line">    <span class="comment">// 1.设置 beanFactory 的类加载器</span></span><br><span class="line">		<span class="comment">// 2.设置 beanFactory 的表达式解析器</span></span><br><span class="line">		<span class="comment">// 3.1:注册一个 BeanPostProcessor 用于将实现了ApplicationContext能力相关的Aware接口的 bean, 触发赋值setter 注入 applicationContext 对象</span></span><br><span class="line">		<span class="comment">// 3.2:设置 beanFactory 处理 bean 时要忽略的接口(主要是setter注入时忽视一些也是setter的方法, 因为这些方法会由 PostProcessor 来触发)</span></span><br><span class="line">		<span class="comment">// 4.注册一些特殊的 bean(注入这些bean时会注入 this 对象: 多功能工具人 ApplicationContext, 可见其和普通 bean 的注册方式不一样)</span></span><br><span class="line">		<span class="comment">// 5.注册一个 BeanPostProcessor 用于检测加载的 bean 是否实现了 ApplicationListener 接口, 若是, 则注册到事件广播器中(不是,是暂存在applicationListeners字段中, 等事件广播器创建后才注册)</span></span><br><span class="line">		<span class="comment">// 6.注册一个 BeanPostProcessor 用于触发实现了 LoadTimeWeaverAware 接口的 bean 的 setLoadTimeWeaver() 社会 LTW 实例.</span></span><br><span class="line">		<span class="comment">// 7.注册几个环境相关 bean 到容器中(Spring的环境对象, 以及系统环境变量和系统配置文件)</span></span><br><span class="line"></span><br><span class="line">org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</span><br><span class="line">    <span class="comment">// 1.若 beanFactory 实现了 BeanDefinitionRegistry 接口(new AnnotationConfigApplicationContext 就实现了)</span></span><br><span class="line">		<span class="comment">//    则扫描所有实现了 BeanDefinitionRegistryPostProcessor 接口的 bean, 根据优先级分三类(高/中/其他)依次执行</span></span><br><span class="line">		<span class="comment">// 2.然后扫描所有实现了 BeanFactoryPostProcessor 接口的 bean, 依旧是根据优先级分三类依次执行.</span></span><br><span class="line">		<span class="comment">// 3.每次执行前都会根据 Order 信息排序, 再遍历执行</span></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)</span><br><span class="line">    <span class="comment">// 1.扫描6次: 2(MergedBeanDefinitionPostProcessor/其他) x 3(优先级: 高/中/其他)</span></span><br><span class="line">		<span class="comment">//    将其加入到 beanFactory 的 beanPostProcessors 集合中</span></span><br><span class="line">		<span class="comment">// 2.再次加入 ApplicationListenerDetector (用于处理实现 ApplicationListener 的 bean 注册到事件广播器), 主要是使其在链末尾, 可以最后执行.</span></span><br><span class="line"></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#registerListeners</span><br><span class="line">    <span class="comment">// 1.将可能存在的 applicationListeners 注册到事件广播器中(新建时是不存在的)</span></span><br><span class="line">		<span class="comment">// 2.扫描容器中实现了 ApplicationListener 接口的 bean, 将其预存到广播器中但不执行</span></span><br><span class="line">		<span class="comment">// 3.将之前 publishEvent() 想广播的事件广播出去, 然后字段 earlyApplicationEvents 赋值为空</span></span><br><span class="line">		<span class="comment">//    (因为 publishEvent() 中根据是否为空判断立刻执行或先存着) (另这也解释了 prepareRefresh() 中为何要赋值一个空集合)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</span><br><span class="line">    <span class="comment">// 1.完成 beanFactory 的一些配置</span></span><br><span class="line">		<span class="comment">// 2.注册默认的表达式解析器(若无相应的bean存在)</span></span><br><span class="line">		<span class="comment">// 3.扫描容器中实现了 LoadTimeWeaverAware 接口的 bean, 并触发(getBean)之前注册过的 BeanPostProcessor</span></span><br><span class="line">		<span class="comment">// 4.将单例的 bean 创建出来放入容器中(未设置lazy-init=true)的 bean</span></span><br><span class="line"></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#finishRefresh</span><br><span class="line">    <span class="comment">// 1.清空资源缓存</span></span><br><span class="line">		<span class="comment">// 2.创建一个生命周期管理器(start, refresh, stop等)并注册到 beanFactory</span></span><br><span class="line">		<span class="comment">// 3.触发生命周期管理器的 onRefresh()</span></span><br><span class="line">		<span class="comment">// 4.广播容器刷新完成的事件</span></span><br><span class="line">		<span class="comment">// 5.为 Spring Tool Suite 提供某些便捷(没用过, 不知道...)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可算复制完了, 如果你有幸直接跳读到这里, 那么送上地址 : <a href="https://github.com/gudqs7/spring-framework/tree/wq-comment" target="_blank" rel="noopener">注意分支吧</a> </p>
<p>另外上面方法前带个 <strong>#</strong> 的, 复制到 IDEA 双击 Shift 然后粘贴, 选择 Symbols 搜索更准确呢!</p>
</blockquote>
<h2 id="获取容器对象过程"><a href="#获取容器对象过程" class="headerlink" title="获取容器对象过程"></a>获取容器对象过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从getBean(Class type) 中进入</span></span><br><span class="line">1.检查 applicationContext 和 beanFactory 的状态, 若有异常则给出准确的错误.</span><br><span class="line">2.扫描容器中所有此 <span class="built_in">type</span> 的 beanName, 遍历判断每个 beanName 是否可用</span><br><span class="line">   可用则判断可用的个数是否刚好是一个, 是则直接调用 getBean() 返回对象实例</span><br><span class="line">   若可用的个数超过一个, 则根据 beanDefinition 的 isPrimary 和对比配置的优先级是否为有最高的再返回最高的</span><br><span class="line">   若都不行, 则报错.</span><br><span class="line">3.接着看 getBean, 先试着从单例的缓存中获取, 若存在则返回.</span><br><span class="line">4.若缓存中不存在, 则判断父容器是否存, 若存在则从父容器获取</span><br><span class="line">   若父容器不存在, 则自己新建, 先标记 beanName 到 alreadyCreated 中(表示已经创建了防止重复创建) 再开始创建一个 bean.</span><br><span class="line">5.创建一个新的 bean 实例, 先处理 beanDefinition 的 dependsOn 属性(即若存在则先调用 getBean 获取依赖的 bean)</span><br><span class="line">6.若 beanDefinition 的设置是单例, 则通过闭包对创建对象前后进行一些异常处理和缓存处理(主要是彻底创建完后加入到单例一级缓存, 移除二级和三级缓存[循环依赖相关的两个缓存]).</span><br><span class="line">7.通过反射根据 beanClass 创建一个对象实例, 然后将其添加到 singletonFactories 中(解决依赖循环问题)</span><br><span class="line">8.调用 populateBean() 为对象的字段(属性)注入它所需要的值(可能是@Resource, @Value等); (此时可能会遇到依赖循环问题, 但解决这个问题的缓存在此之前就添加了, 所以不怕)</span><br><span class="line">9.最后调用 initializeBean() 完成 bean 的初始化(调用 bean 的一些方法, 如 afterPropertiesSet), 返回对象实例.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 先根据 type 找到 beanName, 找到后根据 beanName 创建对象; 创建对象前先检查缓存(单例), 再考虑父容器, 最后才是自己创建, 自己创建会先创建 dependsOn 的 bean 对象, 然后才通过反射实例化出一个对象实例(这里反射用到的class和构造方法, 通过实现 SmartInstantiationAwareBeanPostProcessor接口都可进行干预), 实例化后存到二级缓存, 再为字段赋值(注入); 最后调用 bean 的 init 相关的接口(如afterPropertiesSet), 就可以返回这个对象实例了.</p>
</blockquote>
<h3 id="超长源码分析过程-1"><a href="#超长源码分析过程-1" class="headerlink" title="超长源码分析过程"></a>超长源码分析过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从这个方法进入</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 判断容器的状态, 确保 beanFactory 可用.(主要是若不可用, 提示的错误信息会比getBeanFacgtory()中更准确)</span></span><br><span class="line">  <span class="comment">// 使用 beanFactory 的 getBean 方法获取对象并返回.</span></span><br><span class="line">  assertBeanFactoryActive();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(requiredType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后其他所有涉及的核心方法的注释</span></span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveBean</span><br><span class="line">    <span class="comment">// 调用 resolveNamedBean, 如存在 bean 则直接返回. (核心)</span></span><br><span class="line">		<span class="comment">// 若不存在则从父容器中寻找, 父容器实现了 DefaultListableBeanFactory 则调与同子容器相同的方法</span></span><br><span class="line">		<span class="comment">// 若没实现则 通过 getBeanProvider 获取.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveNamedBean(org.springframework.core.ResolvableType, java.lang.Object[], boolean)</span><br><span class="line">    <span class="comment">// 1.调用 getBeanNamesForType 获取所有与 type 相匹配的 beanName 集合.</span></span><br><span class="line">		<span class="comment">// 2.遍历判断每个 beanName 是否可用</span></span><br><span class="line">		<span class="comment">// 3.若可用的 beanName 只有一个, 则调用 getBean(beanName) 获取对象实例并返回</span></span><br><span class="line">		<span class="comment">//   若可用数超过一个, 则试着根据是否主要以及高优先级来确定一个 beanName 实例, 若能确定则返回, 不能则报错.</span></span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</span><br><span class="line">    <span class="comment">// 1.获取完整的 beanName</span></span><br><span class="line">		<span class="comment">// 2.调用 getSingleton1() 检查是否存在缓存, 这层检查可防止依赖循环.</span></span><br><span class="line">		<span class="comment">//     若存在, 则通过 getObjectForBeanInstance() 判断缓存的是 bean 还是 FactoryBean 并返回相应的对象实例.</span></span><br><span class="line">		<span class="comment">// 3.若不存在, 先试着从父容器获取(子容器不存在这个 beanDefinition 且父容器不为空)</span></span><br><span class="line">		<span class="comment">//     没有父容器则 调用 markBeanAsCreated() 标记这个 bean已经创建了 (先标记, 再创建)</span></span><br><span class="line">		<span class="comment">//     获取 beanDefinition, 判断其 dependsOn 属性是否存在, 存在则 先获取依赖的 bean</span></span><br><span class="line">		<span class="comment">//     调用 getSingleton2() 处理单例缓存</span></span><br><span class="line">		<span class="comment">// 4.而 getSingleton2() 中的闭包中 执行的 createBean() 方法中则才是创建实例并调用 BeanPostProcessor</span></span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)</span><br><span class="line">    <span class="comment">// 1.判断是否存在于 singletonObjects 中</span></span><br><span class="line">		<span class="comment">// 2.若不存在则判断 bean 是否处于创建中(未创建完成, 如循环依赖时)</span></span><br><span class="line">		<span class="comment">// 3.若处于创建中, 则同步后判断是否存在于 earlySingletonObjects (也就是 singletonFactories 移除后存入的地方)</span></span><br><span class="line">		<span class="comment">//      (因为FactoryBean占用空间大, 获取对象麻烦且速度更慢, 这是为了防止如果循环依赖链条很长 多次获取浪费CPU的问题)</span></span><br><span class="line">		<span class="comment">// 4.不存于 earlySingletonObjects 则代表第一次(也只会有一次)取 singletonFactories</span></span><br><span class="line">		<span class="comment">//    取出后调用 getObject() 并将其存入到 earlySingletonObjects, 然后从 singletonFactories 中移除. 以后就少走几行代码了.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</span><br><span class="line">    <span class="comment">// 1.先确保是第一次创建单例对象, 防止重复创建</span></span><br><span class="line">		<span class="comment">// 2.进行一些异常处理</span></span><br><span class="line">		<span class="comment">// 3.调用 singletonFactory.getObject() 创建对象</span></span><br><span class="line">		<span class="comment">// 4.创建对象结束添加单例缓存和清空 singletonFactories / earlySingletonObjects 缓存.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</span><br><span class="line">    <span class="comment">// 1.调用 resolveBeanClass 解析得到真正的 bean class, 若解析不为空且处于某些情况下, 则复制一份 beanDefinition 并设置 beanClass 为解析所得</span></span><br><span class="line">		<span class="comment">// 2.执行 BeanPostProcessor 的 postProcessorsBeforeInstantiation() 方法</span></span><br><span class="line">		<span class="comment">// 3.调用 doCreateBean() 创建对象 并返回</span></span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</span><br><span class="line">    <span class="comment">// 1.调用 createBeanInstance() 获得一个 对象实例的 包装类</span></span><br><span class="line">		<span class="comment">// 2.同步锁下执行 BeanFactoryPostProcessor 的 postProcessMergedBeanDefinition().</span></span><br><span class="line">		<span class="comment">// 3.添加 singletonFactories 缓存, 移除 earlySingletonObjects; 解决循环依赖问题.</span></span><br><span class="line">		<span class="comment">// 4.调用 populateBean() 检查字段是否需要注入对象实例, 是则获取对应的 bean 注入. (可能引起循环依赖)</span></span><br><span class="line">		<span class="comment">// 5.调用 initializeBean() 执行对象的一些 Aware 和 init 方法和 BeanPostProcessor 的 postProcessBeforeInitialization.</span></span><br><span class="line">		<span class="comment">// 6.最后返回对象实例.</span></span><br></pre></td></tr></table></figure>





<h2 id="各种实现的原理"><a href="#各种实现的原理" class="headerlink" title="各种实现的原理"></a>各种实现的原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?</span><br><span class="line">2.为何我写的 class 实现 ApplicationListener&lt;XxxEvent&gt; 后并放入容器中, 就能监听我想知道的事件?</span><br><span class="line">3.为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?</span><br><span class="line">4.Spring是如何解决循环依赖的(指用字段注入而非构造方法)?</span><br><span class="line">5.Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?</span><br><span class="line">6.Spring AOP是如何实现的(指@Aspect)?</span><br><span class="line">7.Spring 事务是如何实现的(指@Transaction)?</span><br></pre></td></tr></table></figure>

<h3 id="为何我写的-class-实现一些接口-如ApplicationContextAware-后并放入容器中-就可以获取到一些对象-如applicationContext"><a href="#为何我写的-class-实现一些接口-如ApplicationContextAware-后并放入容器中-就可以获取到一些对象-如applicationContext" class="headerlink" title="为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?"></a>为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) 首先 AbstractApplicationContext#prepareBeanFactory 会添加一个ApplicationContextAwareProcessor</span><br><span class="line">2) 这个 beanPostProcessor 负责在bean初始化之前注入context对象.</span><br><span class="line">3) 这个 beanPostProcessor 的执行时机是在 doCreateBean 中的 postProcessBeforeInitialization()</span><br></pre></td></tr></table></figure>



<h3 id="为何我写的-class-实现-ApplicationListener-后并放入容器中-就能监听我想知道的事件"><a href="#为何我写的-class-实现-ApplicationListener-后并放入容器中-就能监听我想知道的事件" class="headerlink" title="为何我写的 class 实现 ApplicationListener 后并放入容器中, 就能监听我想知道的事件?"></a>为何我写的 class 实现 ApplicationListener<XxxEvent> 后并放入容器中, 就能监听我想知道的事件?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) 在 AbstractApplicationContext#registerListeners() 中扫描容器内所有相关实现类加入到事件监听者集合中</span><br><span class="line">2) 然后在publishEvent时，遍历事件监听者集合调用bean的方法即可。观察者模式！</span><br><span class="line">3) 另外也用了BeanPostProcessor去实现, 叫 ApplicationListenerDetector, 加入时机同1, 执行时机同1.</span><br><span class="line">4) 至于为何使用2种机制, 应该是因为 registerListeners() 时, 扫描只是当前的, 后续可能容器内的 bean 还会增加(我也猜不到啥形式增加, 反正简单写个类肯定不会), 所以还是需要 ApplicationListenerDetector 在这个 Bean 初始化时加入到监听者中去.</span><br></pre></td></tr></table></figure>



<h3 id="为何Spring中遇到各种顺序问题-只需要实现-Ordered-接口-或加上-Order注解-就能使其有序"><a href="#为何Spring中遇到各种顺序问题-只需要实现-Ordered-接口-或加上-Order注解-就能使其有序" class="headerlink" title="为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?"></a>为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?</h3><blockquote>
<p>因为 Spring 预先在执行这些东西之前, 进行一个排序动作, 然后才遍历执行. 包括AOP, BeanFactoryPostProcessor, BeanPostProcessor .</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) 比如说 BeanPostProcesser, 容器扫描后, 会像对bean集合排序, 再遍历执行.</span><br><span class="line">2) 详细过程见 PostProcessorRegistrationDelegate#sortPostProcessors()</span><br></pre></td></tr></table></figure>



<h3 id="Spring是如何解决循环依赖的-指用字段注入而非构造方法"><a href="#Spring是如何解决循环依赖的-指用字段注入而非构造方法" class="headerlink" title="Spring是如何解决循环依赖的(指用字段注入而非构造方法)?"></a>Spring是如何解决循环依赖的(指用字段注入而非构造方法)?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先， 假定有两个单例 bean A 和 B, A 持有 B, B 持有A， 构成循环</span><br><span class="line"><span class="number">2</span>) 此时程序调用getBean获取A，则在 doCreateBean 中 创建后将 bean 缓存到 singletonFactories 中</span><br><span class="line"><span class="number">3</span>) 然后设置属性B, 解析属性, 需要获取B对象</span><br><span class="line"><span class="number">4</span>) 获取B, 则执行doCreateBean 后执行解析属性, 需要获取 A对象 (又一次)</span><br><span class="line"><span class="number">5</span>) 获取A, 进入 doGetBean 中的 getSingleton, 此时判断 singletonFactories 中有A, 则可以直接取出A</span><br><span class="line"><span class="number">6</span>) 获得A后, 即可完成B的属性赋值, 然后会完成B的创建.</span><br><span class="line"><span class="number">7</span>) B创建完后, A就能获得B, 则A也完成了属性赋值, 最后完成创建A.</span><br><span class="line"><span class="number">8</span>) 到此, 返回即可.</span><br><span class="line"></span><br><span class="line">&gt; 总结: 首次获取A, 创建A对象后缓存一个存储A对象的 ObjectFactory 实例, 再解析属性时触发 getBean(B), 同理也会做缓存, 然后也解析属性, 触发getBean(A), 第二次获取A, 进入另一个逻辑, 返回 ObjectFactory 实例中存储的对象A, 即可完成getBean(A), 然后完成getBean(B), 再完成外层的getBean(A).  </span><br><span class="line">  </span><br><span class="line">TIPS:</span><br><span class="line">步骤<span class="number">4</span>中, 会先判断 earlySingletonObjects, 不存在才判断 singletonFactories, 而从 singletonFactories 中取得对象后, 则会将其从 singletonFactories 移除并加入 earlySingletonObjects</span><br><span class="line"></span><br><span class="line">这是因为 singletonFactories 缓存的 FactoryBean, 若反复调用 getObject(), 则每次获取都会调用 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#getEarlyBeanReference 方法, 而此方法会执行 SmartInstantiationAwareBeanPostProcessor 的 getEarlyBeanReference(), 这会导致 BeanPostProcessor 重复执行, 显然是不行的.</span><br></pre></td></tr></table></figure>



<h3 id="Spring可以用注解替换XML配置文件了-是如何实现的呢-常用注解的实现原理"><a href="#Spring可以用注解替换XML配置文件了-是如何实现的呢-常用注解的实现原理" class="headerlink" title="Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?"></a>Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1) 首先是指定包名或指定类名</span><br><span class="line">	如指定包名则 scan 时会执行, 如指定类名则在构造方法初始化 reader 时执行</span><br><span class="line">2) 无论哪种, 最终都会走一段代码 AnnotationConfigUtils#registerAnnotationConfigProcessors()</span><br><span class="line">3) 这段代码会添加一些 BeanFactoryPostProcessor</span><br><span class="line">	如 ConfigurationClassPostProcessor 负责解析 @Configuration&#x2F;@Import&#x2F;@Bean 等注解</span><br><span class="line">    	然后由 ConfigurationClassBeanDefinitionReader 负责将信息转换成BeanDefinition再注册到容器。</span><br><span class="line">	如 AutowiredAnnotationBeanPostProcessor 负责解析 @Autowired&#x2F;@Value 注解</span><br><span class="line">    如 CommonAnnotationBeanPostProcessor 负责解析 @Resource 注解</span><br><span class="line">    解析放在 postProcessProperties() 方法中， 先扫描bean的字段和方法， 然后一一调用方法和为字段注入值</span><br><span class="line">4) 之后, 他会将扫描的类放到 beanDefinitions 中(或指定的类注册进去)</span><br><span class="line">5) BeanFactory加载完毕后, 回到AbstractApplicationContext的refresh逻辑</span><br><span class="line">	如会执行 postProcessBeanFactory(), 调用前面加入的ConfigurationClassPostProcessor</span><br><span class="line">	然后会添加更多的类到容器中.</span><br><span class="line">    </span><br><span class="line">注意事项：</span><br><span class="line">    @Configuration 和 @Component的区别？</span><br><span class="line">    观察发现，即使使用@Component 其下带 @Bean 的方法依然可以注入到容器中。所以似乎两者没有区别？</span><br><span class="line">    仔细查看源码和资料后，发现 postProcessBeanFactory() 方法在 processConfigBeanDefinitions() 后还会调用 enhanceConfigurationClasses()</span><br><span class="line">    而在这个方法中, 对前面解析了class 是 CONFIGURATION_CLASS_FULL (即代表@Configuration)的类</span><br><span class="line">    会生成一个 cglib 的代理, 这样获取@Bean注解的方法的bean时,不会每次调用方法new 一个, 而是有缓存.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 就是利用 BeanFactoryPostProcessor 可获取 BeanDefinitionRegistry 对象, 然后扫描容器内带有注解的 bean, 解析这些注解得到一些 BeanDefinition, 再通过获得的 BeanDefinitionRegistry对象注册到 BeanFactory 中.</p>
</blockquote>
<h3 id="Spring-AOP是如何实现的-指-Aspect"><a href="#Spring-AOP是如何实现的-指-Aspect" class="headerlink" title="Spring AOP是如何实现的(指@Aspect)?"></a>Spring AOP是如何实现的(指@Aspect)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1) 使用 @EnableAspectJAutoProxy</span><br><span class="line">2) @EnableAspectJAutoProxy 中使用了 @Import(AspectJAutoProxyRegistrar.class)</span><br><span class="line">3) ConfigurationClassPostProcessor 会解析@Import, 进入 registerBeanDefinitions() 中</span><br><span class="line">4) registerBeanDefinitions() 中添加了 AnnotationAwareAspectJAutoProxyCreator 到容器中</span><br><span class="line">5) AnnotationAwareAspectJAutoProxyCreator 本质上时一个 BeanPostProcessor</span><br><span class="line">6) 因此在 createBean 时, 会被自动调用. 其中 postProcessAfterInitialization() 负责创建代理对象</span><br><span class="line">7) 而 getAdvicesAndAdvisorsForBean() 则负责查找对应的增强. 然后会调用子类的findCandidateAdvisors</span><br><span class="line">8) 如 AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors() 负责注解编写增强@Before&#x2F;@After等</span><br><span class="line">9) 简单说下逻辑, 就是查找容器所有类, 判断这个类有没有 @Aspect 注解, 然后先找出所有Pointcut</span><br><span class="line">	再遍历所有方法, 找出方法上带有@Before等注解且有关联的Pointcut的方法,</span><br><span class="line">    然后使用这个方法和关联的Pointcut 来new 一个Advisor, 加入到Advisor集合中, 遍历结束后返回即可.</span><br><span class="line">10) 查找到所有的增强后, 再比较Pointcut表达式是否匹配当前的bean, 如可以则加入.</span><br><span class="line">11) 根据找到的Advisor集合, 创建一个带配置(advisor集合等)的代理对象, 代理对象执行方法前</span><br><span class="line">12) 会先根据配置中的advisor集合生成一个执行链, 然后在拦截代理方法处调用. 执行链会负责执行通知.</span><br><span class="line">13) 不同的通知由不同的适配器执行.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结就是通过 @EnableAspectJAutoProxy 的@Import, 使得程序最终会执行 AnnotationAwareAspectJAutoProxyCreator 的 postProcessAfterInitialization(对象初始化后调用) 方法, 这个方法在 BeanFactory创建完对象后触发, 此时便可通过 CGlib 等动态代理技术为 创建的 bean 对象创建一个代理对象, 然后这个代理对象会根据 Pointcut 找到关联的 Advisor,  并在合适的时机执行对应的 Advisor, 如 @Before产生的Advisor 会在执行了 bean 对象的指定方法(看Pointcut配置)后执行.</p>
</blockquote>
<h3 id="Spring-事务是如何实现的-指-Transaction"><a href="#Spring-事务是如何实现的-指-Transaction" class="headerlink" title="Spring 事务是如何实现的(指@Transaction)?"></a>Spring 事务是如何实现的(指@Transaction)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0) 事务是由AOP实现的, 所以需要找到对应的Pointcut 和 Advisor</span><br><span class="line">1) 打开了 @EnableTransactionManagement 注解</span><br><span class="line">2) 然后@Import 了 TransactionManagementConfigurationSelector</span><br><span class="line">3) 之后导入了 ProxyTransactionManagementConfiguration 到容器中</span><br><span class="line">4) ProxyTransactionManagementConfiguration 带有 @Configuration</span><br><span class="line">5) @Bean 注入了一个通用的Advisor: BeanFactoryTransactionAttributeSourceAdvisor</span><br><span class="line">6) 这个Advisor的 Pointcut 是由 TransactionAttributeSourcePointcut 实现的</span><br><span class="line">	实现逻辑是 TransactionAttributeSourcePointcut 的 matches()</span><br><span class="line">    这个方法调用了 getTransactionAttributeSource() 获取 AnnotationTransactionAttributeSource</span><br><span class="line">    然后通过 getTransactionAttribute() 调用了 findTransactionAttribute()</span><br><span class="line">    最终使用SpringTransactionAnnotationParser 类判断方法是否有@Transactional注解</span><br><span class="line">    并解析注解信息然后返回. 另外这个方法还可以获取@Transactional注解的信息, 而这里只用于判断是否需要拦截这个方法.</span><br><span class="line">7) TransactionInterceptor 是一个Advisor</span><br><span class="line">    也可以通过AnnotationTransactionAttributeSource获取@Transactional注解上的信息</span><br><span class="line">    然后在invoke中, 拦截方法, 打开事务, 在执行完方法后, 提交事务, 报错时回滚事务</span><br><span class="line">    这个 Advisor 不同于传统的前置&#x2F;后置, 而是更具体的 MethodInterceptor(动态代理直接相关).</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 就是基于AOP实现的, 只需找到对应的 Pointcut 和 Advisor 即可. Pointcut 就是根据 @Transaction 注解判断方法是否需要代理, 这个很简单; 比较有意思的是 Advisor 不是我们写AOP那种 @Before,@Around之类的, 而是更接近动态代理原始的语法的 MethodInterceptor 即 TransactionInterceptor.</p>
</blockquote>
<h2 id="BeanFactoryPostProcessor-相关类分析"><a href="#BeanFactoryPostProcessor-相关类分析" class="headerlink" title="BeanFactoryPostProcessor 相关类分析"></a>BeanFactoryPostProcessor 相关类分析</h2><h3 id="BeanFactoryPostProcessor-生效原理"><a href="#BeanFactoryPostProcessor-生效原理" class="headerlink" title="BeanFactoryPostProcessor 生效原理"></a>BeanFactoryPostProcessor 生效原理</h3><blockquote>
<p>生效原理就是, ApplicationContext 的 refresh 方法中会扫描出容器中实现了 BeanFactoryPostProcessor 接口的 bean, 将其排序后执行相应的接口, 这样我们写的类实现的相应的接口的方法就被执行了.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常用的 BeanFactoryPostProcessor</span><br><span class="line"><span class="comment"># ConfigurationClassPostProcessor</span></span><br><span class="line">这个类作用就是解析 @Configuration/@Component/@Import/@ImportSource/@ComponentScan 等基础注解. 是注解开发的基石, 更是 Spring Boot 的基石.</span><br></pre></td></tr></table></figure>



<h2 id="BeanPostProcessor-相关类分析"><a href="#BeanPostProcessor-相关类分析" class="headerlink" title="BeanPostProcessor 相关类分析"></a>BeanPostProcessor 相关类分析</h2><h3 id="BeanPostProcessor-生效原理"><a href="#BeanPostProcessor-生效原理" class="headerlink" title="BeanPostProcessor 生效原理"></a>BeanPostProcessor 生效原理</h3><blockquote>
<p>在 refresh() 中会扫描容器中所有 实现了 BeanPostProcessor 接口的类, 添加到 BeanFactory 的 beanPostProcessors 字段中(是个List[CopyOnWriteArrayList自定义版, 自定义加入了清空缓存的逻辑]), 然后在 BeanFactory 创建对象时 createBean() 在适当的时机调用对应的方法.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">有哪几种 BeanPostProcessor (默认的+扩展)</span><br><span class="line">1.InstantiationAwareBeanPostProcessor</span><br><span class="line">	postProcessAfterInstantiation: 对象实例化后调用</span><br><span class="line">	postProcessBeforeInstantiation: 对象实例化前调用</span><br><span class="line">	postProcessProperties: 设置属性值前</span><br><span class="line">	postProcessPropertyValues: 设置属性值前, 若上个方法不处理(返回null)才会触发</span><br><span class="line"></span><br><span class="line">2.SmartInstantiationAwareBeanPostProcessor</span><br><span class="line">  predictBeanType: 获取一个 bean 的 class 类型前调用</span><br><span class="line">  getEarlyBeanReference: 获取一个二级缓存对象(singletonFactories的getObject)时调用</span><br><span class="line">  determineCandidateConstructors: 决定一个 bean 实例化的构造参数是什么时调用</span><br><span class="line">	</span><br><span class="line">3.DestructionAwareBeanPostProcessor</span><br><span class="line">	postProcessBeforeDestruction: 对象销毁前调用</span><br><span class="line">	requiresDestruction: 判断这个类针对某个 bean 是否执行 postProcessBeforeDestruction()</span><br><span class="line">	</span><br><span class="line">4.MergedBeanDefinitionPostProcessor</span><br><span class="line">  postProcessMergedBeanDefinition: 在创建对象前调用, 可对 BeanDefinition 做修改</span><br><span class="line">  resetBeanDefinition: 在重置 BeanDefinition 时调用, 用于清空 PostProcessor 对应的缓存</span><br><span class="line">	</span><br><span class="line">5.BeanPostProcessor(基础)</span><br><span class="line">  postProcessBeforeInitialization: 创建对象后(也设置好了字段), 在调用 init 之前调用</span><br><span class="line">  postProcessAfterInitialization: 在创建对象时, 调用了 init 之后调用</span><br><span class="line">  </span><br><span class="line">总结: </span><br><span class="line">0.对 BeanDefinition 做干预</span><br><span class="line">1.对象实例化过程中(对class/构造参数进行干预)</span><br><span class="line">2.对象实例化前后</span><br><span class="line">3.对象设置属性前, 对属性做干预</span><br><span class="line">4.对象初始化(init)前后</span><br><span class="line">5.对象销毁前</span><br></pre></td></tr></table></figure>

<h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 1.1: InstantiationAwareBeanPostProcessor 的 postProcessAfterInstantiation()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean 第一段</span></span><br><span class="line"><span class="comment">// 1.2: InstantiationAwareBeanPostProcessor 的 postProcessProperties()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean 第二段</span></span><br><span class="line"><span class="comment">// 1.3: InstantiationAwareBeanPostProcessor 的 postProcessPropertyValues</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean 第三段</span></span><br><span class="line"><span class="comment">// 1.4: InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1: SmartInstantiationAwareBeanPostProcessor 的 predictBeanType()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType 中</span></span><br><span class="line"><span class="comment">// 2.2: SmartInstantiationAwareBeanPostProcessor 的 getEarlyBeanReference()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getEarlyBeanReference 中</span></span><br><span class="line"><span class="comment">// 2.3: SmartInstantiationAwareBeanPostProcessor 的 determineCandidateConstructors()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineConstructorsFromBeanPostProcessors 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1: MergedBeanDefinitionPostProcessor 的 postProcessMergedBeanDefinition()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors 中</span></span><br><span class="line"><span class="comment">// 3.2: MergedBeanDefinitionPostProcessor 的 resetBeanDefinition()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.DefaultListableBeanFactory.resetBeanDefinition 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.1: DestructionAwareBeanPostProcessor 的 postProcessBeforeDestruction()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.DisposableBeanAdapter.destroy 中</span></span><br><span class="line"><span class="comment">// 4.2: DestructionAwareBeanPostProcessor 的 requiresDestruction()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.DisposableBeanAdapter.filterPostProcessors 和 org.springframework.beans.factory.support.DisposableBeanAdapter.hasApplicableProcessors 中</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有哪些常用的 BeanPostProcessor</span></span><br><span class="line">1.AsyncAnnotationBeanPostProcessor: 用于在将 @Async 相应的 Advisor 加入到对象的代理中</span><br><span class="line">2.ScheduledAnnotationBeanPostProcessor: 用于处理 @Scheduled 注解, 将 bean 生产代理类</span><br><span class="line">3.AnnotationAwareAspectJAutoProxyCreator: AOP 实现核心类</span><br><span class="line">4.AutowiredAnnotationBeanPostProcessor: 用于处理 @Autowired 注解</span><br><span class="line">5.ApplicationListenerDetector: 用于处理实现 ApplicationListener 接口的 bean 对象, 将其添加到事件广播器的监听者集合中.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2020/05/20/interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/interview/" class="post-title-link" itemprop="url">Java-Interview</a>
        </h2>

        <div class="post-meta">
			
				<i class="fa fa-thumb-tack"></i>
				<font color="RED">置顶</font>
				<span class="post-meta-divider">|</span>
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 08:48:14" itemprop="dateCreated datePublished" datetime="2020-05-20T08:48:14+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-25 23:11:18" itemprop="dateModified" datetime="2021-01-25T23:11:18+08:00">2021-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index"><span itemprop="name">Spring-MVC</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/20/interview/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/20/interview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h2><h3 id="说一下你重构代码都做了什么"><a href="#说一下你重构代码都做了什么" class="headerlink" title="说一下你重构代码都做了什么?"></a>说一下你重构代码都做了什么?</h3><blockquote>
<p>首先是两层改成三层, 把controller 的代码尽量迁移到 service 层. 然后将请求风格和响应数据结构统一. 还有就是处理全局异常, 最后对某些重复代码封装成工具类. 另外还会根据实际业务场景使用一些设计模式, 提高代码可扩展性, 降低代码之间的耦合性.</p>
</blockquote>
<h3 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM?"></a>什么是 JVM?</h3><blockquote>
<p> JVM 就是由编译器, 类加载器, 执行引擎, 运行时数据区组成. 其中数据区包含 堆,栈,本地方法栈, 方法区和程序计数器(PC 寄存器), 其中栈是由局部变量表, 操作数栈, 动态链接, 返回地址组成的.</p>
</blockquote>
<h3 id="你是怎么对-jvm-垃圾回收进行优化的"><a href="#你是怎么对-jvm-垃圾回收进行优化的" class="headerlink" title="你是怎么对 jvm 垃圾回收进行优化的?"></a>你是怎么对 jvm 垃圾回收进行优化的?</h3><blockquote>
<p>根据服务器的配置, 调整青年代和老年代的内存大小及比例, 在回收频率和回收速度上做取舍, 使用 G1 垃圾回收期控制 STW 停顿时间, 提高吞吐量.</p>
</blockquote>
<h3 id="说说-MySQL-优化"><a href="#说说-MySQL-优化" class="headerlink" title="说说 MySQL 优化"></a>说说 MySQL 优化</h3><blockquote>
<p>首先是 SQL 查询优化, 通过对联表字段, 查询条件, 分组字段, 排序字段进行综合分析, 根据最左原则建立一个或多个复合索引, 然后使用 explain 分析SQL执行计划, 判断索引使用情况, 根据分析结果进一步改进索引.</p>
<p>然后是对于数据量大的表, 考虑垂直或水平分表, 读多写少的情况, 可以一主多从集群. 另外对于一些统计类的查询, 可以用定时任务将统计结果存储起来, 而非实时查询.</p>
</blockquote>
<h3 id="你用-Redis-做了什么"><a href="#你用-Redis-做了什么" class="headerlink" title="你用 Redis 做了什么?"></a>你用 Redis 做了什么?</h3><blockquote>
<p>将高访问的首页商品列表缓存到 redis 中, 避免数据库瓶颈, 提高响应速度. </p>
<p>商品同步问题: 定时任务刷新. 或修改商品时更新, 缓存设置失效时间, 失效后自动读取数据库.</p>
<p>将购物车数据存放到 redis, 提高购物车交互体验(加快响应速度).</p>
</blockquote>
<h3 id="你使用消息队列做了什么"><a href="#你使用消息队列做了什么" class="headerlink" title="你使用消息队列做了什么?"></a>你使用消息队列做了什么?</h3><blockquote>
<p>解耦: 如下单系统调用库存系统减库存, 若调用时库存系统挂了或出错了, 下单系统还需要做重试处理, 异常处理, 此时可将减库存请求放到消息队列中, 库存系统读取消息进行处理, 若出错则放回消息队列重试. 这样即使代码 bug 导致一直不成功也可在升级后自动重试, 无需人工干预. 另微信支付回调也可如此处理.</p>
<p>削峰: 如秒杀瞬间请求过高, 可将请求放到消息队列中, 另一端缓慢消费, 可防止系统卡住.</p>
<p>异步: 比如下单后发送下单通知, 有短信通知, 微信公众号通知等, 一个一个发送会导致下单这个请求响应很慢, 因此可以将几个通知做成一个消息, 放到消息队列, 由另一处代码异步执行.</p>
</blockquote>
<h3 id="你使用线程池做了什么"><a href="#你使用线程池做了什么" class="headerlink" title="你使用线程池做了什么?"></a>你使用线程池做了什么?</h3><blockquote>
<p>将线程池封装到一个工具类中, 工具类再做成单例模式. 这样使用到多线程的地方都可以使用同一个公共线程池, 减少线程对象创建销毁. 提高线程的利用率.</p>
<p>一些地方异步操作, 拦截器添加请求日志时异步添加.</p>
</blockquote>
<h3 id="你在代码中使用了哪些设计模式"><a href="#你在代码中使用了哪些设计模式" class="headerlink" title="你在代码中使用了哪些设计模式?"></a>你在代码中使用了哪些设计模式?</h3><blockquote>
<p>单例模式, 静态工厂模式, 模板方法, 观察者, 装饰者, 策略模式, 状态模式, 职责链模式.</p>
<p>观察者: 监听商品信息更新, 根据佣金变化幅度决定是否删除, 根据佣金变化和价格变化幅度决定是否通知用户收藏商品变化.</p>
<p>策略模式: 订单不同类型, 对应的商品源不同, 查询数据方式不同, 因此使用策略模式, 便于新增类型的扩展.</p>
<p>状态模式: 红包状态的变化, 可以做成状态模式, 使得红包新增状态时扩展更简单.</p>
</blockquote>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">重复代码重构, 抽象出工具类, 返回值&#x2F;自定义异常 整理重构, 统一请求风格</span><br><span class="line">使用状态模式&#x2F;策略模式优化 if&#x2F;else</span><br><span class="line">使用工厂模式统一管理需要的实例对象, 如工具类, 邮件服务等</span><br><span class="line">封装通用 CRUD 接口及实现, 减少 Dao 层代码</span><br><span class="line"></span><br><span class="line">模块的拆分, 数据库分库分表, 微服务拆分</span><br></pre></td></tr></table></figure>

<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="MySQL-集群"><a href="#MySQL-集群" class="headerlink" title="MySQL 集群"></a>MySQL 集群</h4><blockquote>
<p>MySQL 默认支持主从架构集群, 可配合 mycat 实现读写分离.</p>
</blockquote>
<h4 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h4><blockquote>
<p>Redis Cluster, Codis</p>
</blockquote>
<h4 id="Tomcat-集群"><a href="#Tomcat-集群" class="headerlink" title="Tomcat 集群"></a>Tomcat 集群</h4><blockquote>
<p>tomcat 集群一般需要考虑 session 共享, 可通过 redis 实现 session 共享.</p>
</blockquote>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><blockquote>
<p>Spring Cloud 是一套分布式开发的解决方案, 集合了分布式调用, 链路追踪, 降级处理, 服务注册发现.</p>
</blockquote>
<h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><blockquote>
<p>Dubbo 是一个分布式 RPC 调用框架, 底层使用 netty 框架.</p>
</blockquote>
<h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><blockquote>
<p>docker 是一个容器, 提供了标准化的接口, 可用于快速构建部署环境, 简化部署流程</p>
</blockquote>
<h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><blockquote>
<p>docker-compose 使用 yml 文件描述容器间的关系以及容器的配置, 可用于快速构建复杂的运行环境.</p>
</blockquote>
<h4 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h4><blockquote>
<p>K8s 是一个根据容器快速搭建和管理集群的工具.</p>
</blockquote>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h3><blockquote>
<p>每个线程有自己的内存区域, 多线程之间通信主要通过共享内存来实现.</p>
</blockquote>
<ul>
<li>有序性: 在 CPU 执行指令时, 可能会对非 happens-before 指令进行重排, 优化执行效率. 在单线程情况, 往往不会产生问题, 但涉及多线程时, 可能导致 bug.</li>
<li>可见性: 一个线程修改了一个共享变量, 另一个线程不会知道这个改变, 这就是不可见, 要确保可见性, 一般使用 volatile 关键词, 当然, 加锁也可以.</li>
<li>原子性: 即对于某代码, 实际执行时会分为好几个原子指令, 确保原子性必须加锁 (如synchronized) 处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">happens-before:</span><br><span class="line">读后写</span><br><span class="line">写后写</span><br><span class="line">锁后解锁</span><br><span class="line">可传递性</span><br></pre></td></tr></table></figure>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote>
<p>线程是一个进程中的不同执行路径, 一个进程至少有一个主线程.</p>
<p>进程是一个程序的抽象, 一个程序运行后一般为一个进程.</p>
</blockquote>
<p>线程状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.New (新建)</span><br><span class="line">2.Runnable (就绪)</span><br><span class="line">3.Running (运行中)</span><br><span class="line">4.Blocked (阻塞)</span><br><span class="line">5.WAITING (等待)</span><br><span class="line">6.TIMED_WAITING (超时等待)</span><br><span class="line">7.Dead (死亡)</span><br><span class="line"></span><br><span class="line">[t:thread对象, obj: 同步块中的对象]</span><br><span class="line">New: new Thread()</span><br><span class="line">Runnable: t.start(), t.yield()</span><br><span class="line">Running: after t.start() and cpu run it</span><br><span class="line">Blocked: when enter synchronized block</span><br><span class="line">WAITING: obj.wait(), t.join(), LockSupport.park()</span><br><span class="line">TIMED_WAITING: Thread.sleep(x), obj.wait(x), t.join(x)</span><br><span class="line">Dead: when t.run() is over</span><br></pre></td></tr></table></figure>



<h3 id="JVM-对象结构"><a href="#JVM-对象结构" class="headerlink" title="JVM 对象结构"></a>JVM 对象结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对象头:</span><br><span class="line">	Mark Word(hash, 锁状态, 分代年龄)</span><br><span class="line">	类型指针</span><br><span class="line">	[数组长度]</span><br><span class="line">实例数据</span><br><span class="line">对齐</span><br></pre></td></tr></table></figure>



<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">标记算法:</span><br><span class="line">	1.引用计数法</span><br><span class="line">	2.可达性分析算法(根搜索)(根对象: 栈中的对象, 静态属性引用对象, 常量引用对象)</span><br><span class="line">回收算法:</span><br><span class="line">	1.标记-清除算法</span><br><span class="line">	2.标记-整理算法</span><br><span class="line">	3.标记-复制算法</span><br><span class="line">	4.分代算法( Eden 区(复制算法)--&gt; Survivor 区(缓存, 复制算法) --&gt; Old 区(标记-整理)</span><br><span class="line"></span><br><span class="line">回收器: (前 3 个 Young GC 使用, 后面的 Full GC 使用)</span><br><span class="line">	1.Serial (串行, 复制算法)</span><br><span class="line">	2.ParNew (多线程, 复制算法)</span><br><span class="line">	3.Parallel Scavenge (多线程, 改进版, 可控制吞吐量)</span><br><span class="line">	4.Serial Old(单线程, 标记-整理)</span><br><span class="line">	5.Parallel Old (多线程, 控制吞吐量, 标记-整理算法)</span><br><span class="line">	6.CMS (多线程, 低停顿, 标记-清除算法) : 初始(STW)-并发-重新(STW)-清除</span><br><span class="line">	7.G1 (多线程, CMS 升级版, 标记-整理算法): 初始(STW)-并发-最终(STW)-筛选清除(可控制停顿时间)</span><br></pre></td></tr></table></figure>



<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><blockquote>
<p>MySQL 索引一般选择 B+树做为数据结构存储. B+ 树的优点是, 对文件IO的访问次数控制在 3 次, 保证速度的同时, 能存储千万行数据.</p>
</blockquote>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对常用列添加索引, 视具体情况选择单一索引或复合索引(一般为复合)</span><br><span class="line">2.通过 Explain 语句分析执行计划, 将 type 提升到至少 index 级别.</span><br><span class="line">3.通过 Explain 语句分析执行计划, 将 extra 中 Using filesort消除(排序列加索引), Using join buffer消除 (通过给关联表的关联列加索引), Using temporary (一般通过分组列加索引), Using where(根据最左原则对条件列加复合索引)</span><br></pre></td></tr></table></figure>



<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ACID:</span><br><span class="line">A: 原子性, 多个操作要么都做, 要么都不做</span><br><span class="line">C: 一致性, 数据库文件的状态必须从一个一致性状态到另一个一致性状态.</span><br><span class="line">I: 隔离性, 事物之间相互隔离, 互不影响.</span><br><span class="line">D: 持续性, 一个事务一但提交, 则对数据库的改变是永久的.</span><br></pre></td></tr></table></figure>



<h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.读未提交: 可读取其他未提交事务的执行结果(如更新了某个字段), 可能会造成读取错误的数据(未提交的事务回滚了), 造成脏读.</span><br><span class="line">2.读已提交: 可读取其他已提交事务的执行结果, 2次读取数据还是可能不一致(其他事务又提交了), 造成不可重复读.</span><br><span class="line">3.可重复读: 确保同一事务内多次读取数据时, 会看到相同的数据. 但可能造成幻读, 如批量修改登录密码后, 另一个事务新增了一条记录, 导致新纪录未修改.</span><br><span class="line">4.串行化: 事务串行化执行, 效率低.</span><br></pre></td></tr></table></figure>

<h4 id="MySQL-默认隔离级别"><a href="#MySQL-默认隔离级别" class="headerlink" title="MySQL 默认隔离级别"></a>MySQL 默认隔离级别</h4><p><code>可重读读</code></p>
<h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁: 分为排它锁(X) 和共享锁(S). 即写锁和读锁.</span><br><span class="line">表锁: 分为元数据锁(MDL)和表锁.</span><br></pre></td></tr></table></figure>

<h4 id="锁触发方式"><a href="#锁触发方式" class="headerlink" title="锁触发方式"></a>锁触发方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁: 隐式(条件带有索引则锁对应列, 不带索引则锁全部行, RR 总会带有 GAP 锁, RC 不会), 显式(使用 for update, lock in share mode)</span><br><span class="line">表锁: 隐式(对整个表不带条件进行增删改, 或任何 DDL 操作) 显示(使用 for update, lock in share mode)</span><br></pre></td></tr></table></figure>



<h2 id="源码和框架"><a href="#源码和框架" class="headerlink" title="源码和框架"></a>源码和框架</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><h4 id="加锁流程-lock"><a href="#加锁流程-lock" class="headerlink" title="加锁流程 lock()"></a>加锁流程 <code>lock()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) acquire(): 尝试获取一个许可证, 获取成功则直接返回(lock结束), 获取失败则需要排队</span><br><span class="line"><span class="number">2</span>) tryAcquire(): 判断当前许可证数量(state), 若为<span class="number">0</span>则尝试获取</span><br><span class="line">     分公平和非公平, 公平锁会判断 hasQueuedPredecessors, 非公平则直接抢 compareAndSetState</span><br><span class="line">     若不为<span class="number">0</span>, 则判断持有锁的人是否为我本身, 是则增加当前许可证数量, 返回<span class="keyword">true</span>获取成功</span><br><span class="line">     不是则 返回 <span class="keyword">false</span>, 获取失败(将排队).</span><br><span class="line"><span class="number">3</span>) addWaiter(): AQS 队列尾部添加一个 Node(waiter=X[独占锁]), 若 tail 不存在, 则先初始化一个 空head[空指不代表任何线程] 后再加入队列</span><br><span class="line"><span class="number">4</span>) acquireQueued: 进入队列的节点, 尝试获取许可证, 失败则 park()</span><br><span class="line">     先判断node的上一个节点是否为 head 节点, 若是, 则要尝试获取一次许可证(因为这说明上一个线程已经在执行过程中了, 也许已经走完了unlock() 方法(即已经运行过唤醒队列下一位的代码了,而因为你那时还不在队列中或没进入睡眠中, 唤醒代码是无意义的), 而你则刚加入队列, 如果你此时直接park()去等待唤醒, 则根本无人唤醒你, 同理你的下一个节点也就等不到你去唤醒它.)</span><br><span class="line">     如果不是, 设置了上一个节点的 waitStatus 为 SINGLE 后, 自己睡眠 park(), 等待唤醒</span><br><span class="line"></span><br><span class="line">唤醒后:  </span><br><span class="line"><span class="number">5</span>) 判断上一个节点是不是 head, 一般来说是(因为unkock唤醒的一般就是head.next)</span><br><span class="line">     如果不是则进入 shouldParkAfterFailedAcquire: 将队列中一些已取消的节点从队列中删除, 重新设置节点的prev</span><br><span class="line">     因为是<span class="keyword">for</span>循环, 所以又会再回来判断, 这时应该是head了, 尝试获取许可证, <span class="number">2</span>种可能, 非公平时被刚lock的人抢了(概率较小吧), 另一种就是获取成功</span><br><span class="line">     获取成功后, 把原head节点删掉, 自己设为head节点(head象征一个拿到许可证的节点,除队列第一次初始化), 然后返回到acquire(), 中途没有线程被打断就正常出方法, lock结束</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">得到方式<span class="number">1</span>: acquire 时 state = <span class="number">0</span>, 且抢到了.</span><br><span class="line">得到方式<span class="number">2</span>: 没抢到或不让抢(公平锁), 进入队列等上一个来唤醒我, 上一个等上上个来唤醒他, 上上个等上上上个唤醒....</span><br><span class="line">    unlock 唤醒队列第二个非取消的线程并删除队列第一个元素 [其他元素移位]</span><br><span class="line">    这样第二个线程就可以唤醒非取消的第三个线程[相对而言的第三个,实际上唤醒时还是第二个, 只是唤醒后会删除第一个, 所以第三变第二]</span><br></pre></td></tr></table></figure>

<h4 id="解锁流程-unlock"><a href="#解锁流程-unlock" class="headerlink" title="解锁流程 unlock()"></a>解锁流程 <code>unlock()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) release(): 释放一个许可证, 并根据当前许可证数量是否为0 判断是否可以唤醒下一个节点</span><br><span class="line">2) tryRelease(): 释放一个许可证, 判断线程是否正确(是不是当前独占锁), 许可证减一</span><br><span class="line">	当前许可证数量是否为 0 返回是否可以唤醒队列的 bool 标识.</span><br><span class="line">3) unparkSuccessor(): 唤醒队列中除head外第一个处于阻塞(非取消)的节点(查找方式, 先看next, next状态不对则从后往前找最前的非取消的节点, 因为next如果为null, 无法找null的next).</span><br><span class="line">4) 唤醒后, 会将head设置为唤醒的节点, 以此达到下次唤醒下一个的目的.</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">唤醒的逻辑就是将排队的所有节点挨个唤醒, 而节点被唤醒后又会出队列; 所以代码将出队列和唤醒逻辑一起做, 先唤醒下一个, 下一个负责把前一个移出队列. 然后唤醒自己的下一个, 以此类推, 就实现了唤醒和出队列的操作.</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><code>ReentrantReadWriteLock</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">读锁</span><br><span class="line">	获取锁 tryAcquireShared(), 若当前没有写锁存在, 则 state + <span class="number">1</span>个读单位, 然后返回获取成功. 防止返回获取失败, 进入队列休眠.</span><br><span class="line">	释放锁 tryReleaseShared(), state - <span class="number">1</span>个读单位, 然后根据 state = <span class="number">0</span> 判断返回是否可以唤醒队列.</span><br><span class="line">	</span><br><span class="line">写锁</span><br><span class="line">	获取锁 tryAcquire(), 若存在读锁, 则失败, 若存在写锁, 判断是否重入获取, 是则返回获取成功. 否则失败; 失败就意味着加队列,休眠.</span><br><span class="line">    释放锁 tryRelease(), state - <span class="number">1</span>, 判断 state 中写锁数量是否为<span class="number">0</span>, 是则可以唤醒队列. 否则代表这时一个可重入锁的释放逻辑.</span><br><span class="line">   </span><br><span class="line">总结: 读写锁也好, 可重入锁也好, CountDownLatch 等工具类也好, 都是对 state 操作为多, 或者说, 实现了 AQS的它们, 只负责操作 state, 而队列, 唤醒, 都交给 AQS 来处理.</span><br></pre></td></tr></table></figure>



<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><h4 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a><code>countDown()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1) state 数量减一, 然后判断 state 数量是否为0, 若是则唤醒等待队列的线程.</span><br></pre></td></tr></table></figure>

<h4 id="await"><a href="#await" class="headerlink" title="await()"></a><code>await()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) new 之后, state 数量大于0, 所以会进入等待队列, 然后线程会进入休眠.</span><br><span class="line">2) 等待countDown释放锁, 释放到许可证为0时, 唤醒等待队列的线程.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<p>利用了加共享锁进入队列等待特性实现 <code>await()</code></p>
<p>释放共享锁减少许可证数量且唤醒队列中的等待的线程 实现 <code>countDown()</code></p>
</blockquote>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">与 CountDownLatch 相反, 初始数量一般为 0, acquire() 时判断是否有许可证, 有则成功, 无则队列休眠</span><br><span class="line">而 release 则是添加一个许可证, 添加后总是唤醒队列.</span><br></pre></td></tr></table></figure>

<h3 id="CycleBarrier"><a href="#CycleBarrier" class="headerlink" title="CycleBarrier"></a><code>CycleBarrier</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">含义: 凑足一定个数线程, 然后批量唤醒.</span><br><span class="line">await(): 利用 ReenrantLock 的 lock 和 condition 的 await 进入休眠</span><br><span class="line">当凑足后，用condition 的 singleAll 唤醒所有 await 的线程.</span><br></pre></td></tr></table></figure>





<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><code>HashMap</code></h3><h4 id="请简述-HashMap-的底层数据结构"><a href="#请简述-HashMap-的底层数据结构" class="headerlink" title="请简述 HashMap 的底层数据结构"></a>请简述 <code>HashMap</code> 的底层数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 使用了数组加链表, 以数组为主, 链表加红黑树为补充的数据结构来存储键值对.</span><br><span class="line">2. 当键发送冲突(碰撞)时, 数据将串成链表存于数组中, 当链表长度超过指定值(默认 8)时, 链表转成红黑树, 当红黑树长度小于指定值时(默认 6), 则又转成链表</span><br></pre></td></tr></table></figure>

<h4 id="为什么-HashMap-的初始容量以及扩容后的容量均为-2-的指数幂"><a href="#为什么-HashMap-的初始容量以及扩容后的容量均为-2-的指数幂" class="headerlink" title="为什么 HashMap 的初始容量以及扩容后的容量均为 2 的指数幂"></a>为什么 <code>HashMap</code> 的初始容量以及扩容后的容量均为 2 的指数幂</h4><blockquote>
<p>因为计算机做运算时, 取模运算速度远远慢于位运算, 而若容量始终为 2 的指数幂, 则根据 hash 获取数组下标时只需要 使用 <code>(数组长度-1) &amp; hash 值</code> 即可确定数组下标, 与取模得到的下标一样可靠.</p>
<p>而扩容后后, 因为需要进行 rehash 运算来确定 数据的新下标, 多次进行取数组下标则更能体现位运算的优势.</p>
</blockquote>
<h4 id="为什么-HashMap-的加载因子是-0-75-3-4"><a href="#为什么-HashMap-的加载因子是-0-75-3-4" class="headerlink" title="为什么 HashMap 的加载因子是 0.75 (3/4)"></a>为什么 <code>HashMap</code> 的加载因子是 0.75 (3/4)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用排除法:</span><br><span class="line">1.若加载因子为 1. 则每次 HashMap 满了才进行扩容, 必将有更高的几率触发 hash 碰撞导致数组下标一致需要转成链表或红黑树, 导致读取和更新速度降低.</span><br><span class="line">2.若加载因子为 0.5. 则每次 HashMap 都有一半容量剩余, 空间大大浪费, 对内存开销太大. 容易引发 OOM 事故.</span><br><span class="line"></span><br><span class="line">另外:</span><br><span class="line">0.5-1 之间那么多可能, 选哪个都行, 但作为 HashMap 的默认值, 选中间的 0.75, 走中庸之路, 也是解释的通的.</span><br></pre></td></tr></table></figure>

<h4 id="为什么-HashMap-1-8-扩容无需-rehash"><a href="#为什么-HashMap-1-8-扩容无需-rehash" class="headerlink" title="为什么 HashMap 1.8 扩容无需 rehash"></a>为什么 <code>HashMap</code> 1.8 扩容无需 rehash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 因为1.8的获取 hash 值的算法优化了. 无需一个 hashSeed 进行辅助运算 (主因)</span><br><span class="line">2. 由于 hash 值不变, 原链表中的所有节点只有 2 种可能:</span><br><span class="line">	一是 hash 值高于原数组长度, 则属于高位, 这些高位的节点, 新的下标一定是 (当前下标 + 旧数组长度). </span><br><span class="line">	另一种是 hash 值低于原数组长度, 属于低位, 这些节点的下标无需重新计算, 必然与当前下标一致</span><br><span class="line">	(不信自己那几个示例数据用画出完整二进制计算一下)(神奇的位运算)</span><br><span class="line">3. 重新计算下标时, 根据第 2 点可知, 其下标大小一定不高于(当前下标+旧数组长度), 即下一次循环的下标必然比上一次循环的下标要高, 所以 1.8 源码 resize 进行高低位分组然后转移数据时, 无需担心下一次循环会将刚刚放到新数组的值覆盖(下标相同则会覆盖)</span><br><span class="line">4. 1.8 的 resize 优化了算法, 保持了原有的链表顺序(不知道有啥用)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总得来说, 1.8 优化了 hash 算法, 使 <code>hashcode</code> 的高 16 位与 低 16 位进行异或运算, 降低了碰撞率</p>
<p>而 resize 算法也优化链表节点的迁移, 避免了 1.7 的链环产生</p>
<p>最大的区别就是, 1.7 没有将二进制的神奇发挥到极致, 依然像普通 java 程序一般逻辑. 而 1.8 则充分利用了二进制的优点(也充分的让人头晕), 提高了 <code>HashMap</code> 的效率.</p>
</blockquote>
<h4 id="为什么-HashMap-从链表达到-8-个时转成红黑树-达到-6-个时转回链表"><a href="#为什么-HashMap-从链表达到-8-个时转成红黑树-达到-6-个时转回链表" class="headerlink" title="为什么 HashMap 从链表达到 8 个时转成红黑树, 达到 6 个时转回链表?"></a>为什么 <code>HashMap</code> 从链表达到 8 个时转成红黑树, 达到 6 个时转回链表?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.根据 Poisson distribution 定律, 凑齐8个节点碰撞到同一个下标, 组成长度为 8 的链表概率极低, 约为 0.00000006, 而超过 8 个的几率则更低, 大约为千万分之一. 所以将阈值设置为 8, 因为这种概率极低. 因此可以减少链表转红黑树的, 提高增删改效率.</span><br><span class="line">2.若达到 7 个时转回链表, 则可能会导致HashMap 不停的在链表和红黑树之间转换, 所以阈值设置为 6, 可起到缓冲效果.</span><br></pre></td></tr></table></figure>



<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="关键类解析"><a href="#关键类解析" class="headerlink" title="关键类解析"></a>关键类解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext</span><br><span class="line">	是一个只读的 bean 容器</span><br><span class="line">	可以加载解析配置文件(如xml)</span><br><span class="line">	可以发布事件和注册监听</span><br><span class="line">	具有国际化消息处理能力</span><br><span class="line">ConfigurableApplicationContext</span><br><span class="line">	是一个具有可配置能力的 容器(可设置各个参数, 如id, 父容器)</span><br><span class="line">	具有容器生命周期概念, 如启动,停止,关闭.</span><br><span class="line">AbstractApplicationContext</span><br><span class="line">	模板方法模式的抽象类, 定义了容器的模板(refresh方法), 但由具体的子类实现部分方法</span><br><span class="line">	管理Bean和BeanFactory的PostProcessor</span><br><span class="line">	管理事件的监听和处理</span><br><span class="line">AbstractRefreshableApplicationContext</span><br><span class="line">	为可重复刷新的容器提供基类</span><br><span class="line">	加入了BeanFactory的管理(创建&#x2F;关闭等)</span><br><span class="line">AbstractRefreshableConfigApplicationContext</span><br><span class="line">	加入了configLocation字段, 用于某些容器初始化BeanFactory和Bean</span><br><span class="line">AbstractXmlApplicationContext</span><br><span class="line">	定义了读取xml配置文件来加载BeanFactory的代码, 使得子类只需提供配置文件地址或Resource</span><br><span class="line">ClassPathXmlApplicationContext</span><br><span class="line">	继承基类, 提供配置文件地址的构造方法, 调用refresh加载BeanFactory</span><br><span class="line">						</span><br><span class="line">BeanFactoryPostProcessor</span><br><span class="line">	用于给BeanFactory添加插件式功能, 如配置文件解析 $&#123;&#125; 占位符</span><br><span class="line">	如ConfigurationClassPostProcessor 将@Configuration类下的带@Bean的method返回值注册到beanDefinitions 中</span><br><span class="line"></span><br><span class="line">BeanPostProcessor</span><br><span class="line">	用于给bean添加功能, 如ApplicationContextAware的自动注入就是如此实现的</span><br></pre></td></tr></table></figure>

<h4 id="容器初始化流程"><a href="#容器初始化流程" class="headerlink" title="容器初始化流程"></a>容器初始化流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) 从XmlClassPathApplicationContext构造方法中进入 refresh 方法</span><br><span class="line">2) 先设置容器状态</span><br><span class="line">3) 调用子类初始化 BeanFactory</span><br><span class="line">4) 设置BeanFactory 一些属性,添加一些内置的PostProcessor 注册一些 environment 相关的bean</span><br><span class="line">5) 子类设置一些内置的PostProcessor</span><br><span class="line">6) 扫描添加并执行容器内的 BeanFactoryPostProcessor</span><br><span class="line">7) 扫描容器内的 BeanPostProcessor 并注册</span><br><span class="line">8) 初始化国际化消息处理器</span><br><span class="line">9) 初始化事件广播处理器</span><br><span class="line">10) 执行子类的 refresh 逻辑</span><br><span class="line">11) 扫描容器内的 ApplicationEvent (指实现类) 并注册到事件广播处理器</span><br><span class="line">12) 完成BeanFactory的初始化, 并加载一些单例对象(设置了急于加载的bean)</span><br><span class="line">13) 初始化LifcycleProcessor, 调用onRefresh方法, 发布 ContextRefreshedEvent 事件.</span><br><span class="line">14) 清除一些缓存(如反射缓存, 注解等)</span><br></pre></td></tr></table></figure>

<h4 id="某些实现原理"><a href="#某些实现原理" class="headerlink" title="某些实现原理"></a>某些实现原理</h4><h5 id="实现-ApplicationContextAware-为何会自动注入-applicationContext"><a href="#实现-ApplicationContextAware-为何会自动注入-applicationContext" class="headerlink" title="实现 ApplicationContextAware 为何会自动注入 applicationContext?"></a>实现 <code>ApplicationContextAware</code> 为何会自动注入 <code>applicationContext</code>?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) 首先 AbstractApplicationContext#prepareBeanFactory 会添加一个ApplicationContextAwareProcessor</span><br><span class="line"><span class="number">2</span>) 这个 beanPostProcessor 负责在bean初始化之前注入context对象.</span><br><span class="line"><span class="number">3</span>) 这个 beanPostProcessor 的执行时机是在 doCreateBean 中的 postProcessBeforeInitialization()</span><br></pre></td></tr></table></figure>

<h5 id="实现-ApplicationListener-为何会在事件触发时自动执行我们实现的方法"><a href="#实现-ApplicationListener-为何会在事件触发时自动执行我们实现的方法" class="headerlink" title="实现 ApplicationListener 为何会在事件触发时自动执行我们实现的方法?"></a>实现 <code>ApplicationListener</code> 为何会在事件触发时自动执行我们实现的方法?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) 在 AbstractApplicationContext#registerListeners() 中扫描容器内所有相关实现类加入到事件监听者集合中</span><br><span class="line"><span class="number">2</span>) 然后在publishEvent时，遍历事件监听者集合调用bean的方法即可。观察者模式！</span><br><span class="line"><span class="number">3</span>) 另外也用了BeanPostProcessor去实现, 叫 ApplicationListenerDetector, 加入时机同<span class="number">1</span>, 执行时机同<span class="number">1</span>.</span><br><span class="line"><span class="number">4</span>) 至于为何使用<span class="number">2</span>种机制，与多例有关吧！(scope=<span class="string">"prototype"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="实现Order接口或注解时如何自动排序的"><a href="#实现Order接口或注解时如何自动排序的" class="headerlink" title="实现Order接口或注解时如何自动排序的?"></a>实现<code>Order</code>接口或注解时如何自动排序的?</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) 比如说 BeanPostProcesser, 容器扫描后, 会像对bean集合排序, 再遍历执行.</span><br><span class="line">2) 详细过程见 PostProcessorRegistrationDelegate<span class="comment">#sortPostProcessors()</span></span><br></pre></td></tr></table></figure>

<h5 id="单例对象如何实现循环依赖注入？"><a href="#单例对象如何实现循环依赖注入？" class="headerlink" title="单例对象如何实现循环依赖注入？"></a>单例对象如何实现循环依赖注入？</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) 首先， 设定对象A，B， A 持有 B, B 持有A， 构成循环</span><br><span class="line">2) 此时程序调用getBean获取A，则在 doCreateBean 中 创建后将bean缓存到 singletonFactories 中</span><br><span class="line">3) 然后设置属性B, 解析属性, 需要获取B对象</span><br><span class="line">4) 获取B, 则执行doCreateBean 后执行解析属性, 需要获取 A对象 (又一次)</span><br><span class="line">5) 获取A, 进入 doGetBean 中的 getSingleton, 此时判断singletonFactories中有A, 则可以直接取出A</span><br><span class="line">6) 获得A后, 即可完成B的属性赋值, 然后会完成B的创建.</span><br><span class="line">7) B创建完后, A就能获得B, 则A也完成了属性赋值, 最后完成创建A.</span><br><span class="line">8) 到此, 返回即可.</span><br><span class="line"></span><br><span class="line">&gt; 总结: 首次获取A, 创建A对象后缓存一个存储A对象的 ObjectFactory 实例, 再解析属性时触发 getBean(B), 同理也会做缓存, 然后也解析属性, 触发getBean(A), 第二次获取A, 进入另一个逻辑, 返回 ObjectFactory 实例中存储的对象A, 即可完成getBean(A), 然后完成getBean(B), 再完成外层的getBean(A).</span><br></pre></td></tr></table></figure>

<p>TIPS</p>
<blockquote>
<p>观察源码, 发现有2个缓存, 一个是 <code>singletonFactories</code>, 另一个是 <code>earlySingletonObjects</code>.<br>其中<code>earlySingletonObjects</code>的管理都在 <code>getSingleton</code> 方法中做, 而 <code>singletonFactories</code> 则在<code>doCreateBean</code>中加入, 在 <code>getSingleton</code> 中删除(有<code>earlySingletonObjects</code>后就可以删除了).<br>虽然有2个缓存, 但如果你的bean没有使用<code>BeanFactory</code>创建, 则其实一个缓存也足够了<br>(因为这样的话 <code>singletonFactories</code> 每次创建返回的都是同一个, 因为此时 <code>singletonFactories</code>存的只是代码包装的一个内部类, 而非用户自定义的.)</p>
</blockquote>
<h5 id="InstantiationAwareBeanPostProcessor等一些特殊BeanProcessor的扩展方法是何时自动调用的"><a href="#InstantiationAwareBeanPostProcessor等一些特殊BeanProcessor的扩展方法是何时自动调用的" class="headerlink" title="InstantiationAwareBeanPostProcessor等一些特殊BeanProcessor的扩展方法是何时自动调用的?"></a><code>InstantiationAwareBeanPostProcessor</code>等一些特殊<code>BeanProcessor</code>的扩展方法是何时自动调用的?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先 getBeanPostProcessorCache 获取一些特殊的BeanPostProcessor</span><br><span class="line"><span class="number">2</span>) 如 InstantiationAwareBeanPostProcessor/SmartInstantiationAwareBeanPostProcessor</span><br><span class="line"><span class="number">3</span>) 然后 createBean时, 会在正确的时机使用到这些特殊的 PostProcessor, 取出来, 然后执行对应方法</span><br><span class="line"><span class="number">4</span>) 具体何时可以查看 getBeanPostProcessorCache() 的调用位置一一查看.</span><br></pre></td></tr></table></figure>

<h4 id="注解的实现"><a href="#注解的实现" class="headerlink" title="注解的实现"></a>注解的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先是指定包名或指定类名</span><br><span class="line">	如指定包名则scan时会执行, 如指定类名则在构造方法初始化 reader 时执行</span><br><span class="line">2) 无论哪种, 最终都会走一段代码 AnnotationConfigUtils#registerAnnotationConfigProcessors()</span><br><span class="line"><span class="number">3</span>) 这段代码会添加一些 BeanFactoryPostProcessor</span><br><span class="line">	如 ConfigurationClassPostProcessor 负责解析 <span class="meta">@Configuration</span>/<span class="meta">@Import</span>/<span class="meta">@Bean</span> 注解</span><br><span class="line">    	postProcessBeanDefinitionRegistry() 中 parse 所有的带以上注解的 beanDefinitions</span><br><span class="line">    	ConfigurationClassParser 将注解信息解析保存，</span><br><span class="line">    	然后由 ConfigurationClassBeanDefinitionReader 负责注册到容器。</span><br><span class="line">	如 AutowiredAnnotationBeanPostProcessor 负责解析 <span class="meta">@Autowired</span>/<span class="meta">@Value</span> 注解</span><br><span class="line">    如 CommonAnnotationBeanPostProcessor 负责解析 <span class="meta">@Resource</span> 注解</span><br><span class="line">    解析放在 postProcessProperties() 方法中， 先扫描bean的字段和方法， 然后一一调用方法和为字段注入值</span><br><span class="line"><span class="number">4</span>) 之后, 他会将扫描的类放到 beanDefinitions 中(或指定的类注册进去)</span><br><span class="line"><span class="number">5</span>) BeanFactory加载完毕后, 回到AbstractApplicationContext的refresh逻辑</span><br><span class="line">	如会执行 postProcessBeanFactory(), 调用前面加入的ConfigurationClassPostProcessor</span><br><span class="line">	然后会添加更多的类到容器中.</span><br><span class="line">    </span><br><span class="line">注意事项：</span><br><span class="line">    <span class="meta">@Configuration</span> 和 <span class="meta">@Component</span>的区别？</span><br><span class="line">    观察发现，即使使用<span class="meta">@Component</span> 其下带 <span class="meta">@Bean</span> 的方法依然可以注入到容器中。所以似乎两者没有区别？</span><br><span class="line">    仔细查看源码和资料后，发现 postProcessBeanFactory() 方法在 processConfigBeanDefinitions() 后还会调用 enhanceConfigurationClasses()</span><br><span class="line">    而在这个方法中, 对前面解析了<span class="class"><span class="keyword">class</span> 是 <span class="title">CONFIGURATION_CLASS_FULL</span> (即代表@<span class="title">Configuration</span>)的类</span></span><br><span class="line"><span class="class">    会生成一个 <span class="title">cglib</span> 的代理, 这样获取@<span class="title">Bean</span>注解的方法的<span class="title">bean</span>时,不会每次调用方法<span class="title">new</span> 一个, 而是有缓存.</span></span><br></pre></td></tr></table></figure>

<h4 id="AOP-流程"><a href="#AOP-流程" class="headerlink" title="AOP 流程"></a>AOP 流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 使用 <span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="number">2</span>) <span class="meta">@EnableAspectJAutoProxy</span> 中使用了 <span class="meta">@Import</span>(AspectJAutoProxyRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">3) <span class="title">ConfigurationClassPostProcessor</span> 会解析@<span class="title">Import</span>, 进入 <span class="title">registerBeanDefinitions</span>() 中</span></span><br><span class="line"><span class="class">4) <span class="title">registerBeanDefinitions</span>() 中添加了 <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> 到容器中</span></span><br><span class="line"><span class="class">5) <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> 本质上时一个 <span class="title">BeanPostProcessor</span></span></span><br><span class="line"><span class="class">6) 因此在 <span class="title">createBean</span> 时, 会被自动调用. 其中 <span class="title">postProcessAfterInitialization</span>() 负责创建代理对象</span></span><br><span class="line"><span class="class">7) 而 <span class="title">getAdvicesAndAdvisorsForBean</span>() 则负责查找对应的增强. 然后会调用子类的<span class="title">findCandidateAdvisors</span></span></span><br><span class="line"><span class="class">8) 如 <span class="title">AnnotationAwareAspectJAutoProxyCreator</span>#<span class="title">findCandidateAdvisors</span>() 负责注解编写增强@<span class="title">Before</span>/@<span class="title">After</span>等</span></span><br><span class="line"><span class="class">9) 简单说下逻辑, 就是查找容器所有类, 判断这个类有没有 @<span class="title">Aspect</span> 注解, 然后先找出所有<span class="title">Pointcut</span></span></span><br><span class="line"><span class="class">	再遍历所有方法, 找出方法上带有@<span class="title">Before</span>等注解且有关联的<span class="title">Pointcut</span>的方法,</span></span><br><span class="line"><span class="class">    然后使用这个方法和关联的<span class="title">Pointcut</span> 来<span class="title">new</span> 一个<span class="title">Advisor</span>, 加入到<span class="title">Advisor</span>集合中, 遍历结束后返回即可.</span></span><br><span class="line"><span class="class">10) 查找到所有的增强后, 再比较<span class="title">Pointcut</span>表达式是否匹配当前的<span class="title">bean</span>, 如可以则加入.</span></span><br><span class="line"><span class="class">11) 根据找到的<span class="title">Advisor</span>集合, 创建一个带配置(<span class="title">advisor</span>集合等)的代理对象, 代理对象执行方法前</span></span><br><span class="line"><span class="class">12) 会先根据配置中的<span class="title">advisor</span>集合生成一个执行链, 然后在拦截代理方法处调用. 执行链会负责执行通知.</span></span><br><span class="line"><span class="class">13) 不同的通知由不同的适配器执行.</span></span><br></pre></td></tr></table></figure>

<h4 id="Spring-事务实现"><a href="#Spring-事务实现" class="headerlink" title="Spring 事务实现"></a>Spring 事务实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>) 事务是由AOP实现的, 所以需要找到对应的Pointcut 和 Advisor</span><br><span class="line"><span class="number">1</span>) 打开了 <span class="meta">@EnableTransactionManagement</span> 注解</span><br><span class="line"><span class="number">2</span>) 然后<span class="meta">@Import</span> 了 TransactionManagementConfigurationSelector</span><br><span class="line"><span class="number">3</span>) 之后导入了 ProxyTransactionManagementConfiguration 到容器中</span><br><span class="line"><span class="number">4</span>) ProxyTransactionManagementConfiguration 带有 <span class="meta">@Configuration</span></span><br><span class="line"><span class="number">5</span>) <span class="meta">@Bean</span> 注入了一个通用的Advisor: BeanFactoryTransactionAttributeSourceAdvisor</span><br><span class="line"><span class="number">6</span>) 这个Advisor的 Pointcut 是由 TransactionAttributeSourcePointcut 实现的</span><br><span class="line">	实现逻辑是 TransactionAttributeSourcePointcut 的 matches()</span><br><span class="line">    这个方法调用了 getTransactionAttributeSource() 获取 AnnotationTransactionAttributeSource</span><br><span class="line">    然后通过 getTransactionAttribute() 调用了 findTransactionAttribute()</span><br><span class="line">    最终使用SpringTransactionAnnotationParser 类判断方法是否有<span class="meta">@Transactional</span>注解</span><br><span class="line">    并解析注解信息然后返回. 另外这个方法还可以获取<span class="meta">@Transactional</span>注解的信息, 而这里只用于判断是否需要拦截这个方法.</span><br><span class="line"><span class="number">7</span>) TransactionInterceptor 是一个Advisor</span><br><span class="line">    也可以通过AnnotationTransactionAttributeSource获取<span class="meta">@Transactional</span>注解上的信息</span><br><span class="line">    然后在invoke中, 拦截方法, 打开事务, 在执行完方法后, 提交事务, 报错时回滚事务</span><br><span class="line">    这个 Advisor 不同于传统的前置/后置, 而是更具体的 MethodInterceptor.</span><br></pre></td></tr></table></figure>



<h3 id="Spring-Boot-源码"><a href="#Spring-Boot-源码" class="headerlink" title="Spring Boot 源码"></a>Spring Boot 源码</h3><h4 id="简化了多少操作？"><a href="#简化了多少操作？" class="headerlink" title="简化了多少操作？"></a>简化了多少操作？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.MultipartAutoConfiguration</span><br><span class="line">	添加了一个bean StandardServletMultipartResolver, 并设置上传文件大小等属性</span><br><span class="line">	使得Spring MVC中的 DispatcherServlet 可以获取 multipartResolver, 处理文件上传.</span><br><span class="line">    若不是Spring Boot, 需要在xml或注解中手动添加一个 这样的bean才能处理文件上传, 而且配置文件还要自己读取.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.MailSenderAutoConfiguration</span><br><span class="line">    添加了一个 JavaMailSenderImpl 的bean到容器中, 并设置邮箱服务器/账号/密码等属性</span><br><span class="line">    若不是Spring Boot, 需要在xml中配置一个bean即配置他的属性(邮箱配置)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.TransactionAutoConfiguration</span><br><span class="line">    在内部类添加 <span class="meta">@EnableTransactionManagement</span>，剩下的参考上面的 Spring 事务实现</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>.WebMvcAutoConfiguration</span><br><span class="line">    添加了 RequestMappingHandlerAdapter/RequestMappingHandlerMapping</span><br><span class="line">    添加了 ContentNegotiatingViewResolver</span><br></pre></td></tr></table></figure>

<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 创建 SpringApplicationRunListeners 管理 run 过程的事件, 监听者取自 spring.factories</span><br><span class="line"><span class="number">2</span>) 触发 run 的开始(starting)事件</span><br><span class="line"><span class="number">3</span>) 初始化 environment 对象, 并利用 run 的 environmentPrepared 事件将application.yml的数据注入</span><br><span class="line"><span class="number">4</span>) 打印 Banner, 可自定义 Banner 通过 banner.txt 文件</span><br><span class="line"><span class="number">5</span>) 根据webApplicationType创建一个ApplicationContext 容器</span><br><span class="line">    默认使用 AnnotationConfigApplicationContext</span><br><span class="line"><span class="number">6</span>) 为 context 做一些初始化和设置</span><br><span class="line">    设置环境变量， 使得 context 可以获取 application.yml 中的配置</span><br><span class="line">    调用子类扩展的设置</span><br><span class="line">    加载 容器的 initializers</span><br><span class="line">    触发 run 的 contextPrepared 事件</span><br><span class="line">    打印日志</span><br><span class="line">    添加spring boot 启动参数信息到 bean 容器中</span><br><span class="line">    设置beanFactory的 allowBeanDefinitionOverriding 属性</span><br><span class="line">    设置 懒加载策略， 添加 postProcessor 则会将每个 beanDefinition 的 lazyInit 设置为 <span class="keyword">true</span></span><br><span class="line">    把启动类<span class="class"><span class="keyword">class</span>封装成 <span class="title">BeanDefinition</span> 放到容器中, 使得@<span class="title">Configuration</span>之类的注解生效</span></span><br><span class="line"><span class="class">    触发 <span class="title">run</span> 的 <span class="title">contextLoaded</span> 事件</span></span><br><span class="line"><span class="class">7) 调用 <span class="title">context</span> 的 <span class="title">refresh</span>()</span></span><br><span class="line"><span class="class">    执行 <span class="title">BeanFactoryPostProcessor</span>, 如 <span class="title">ConfigurationClassPostProcessor</span> 解析 @<span class="title">Import</span> 注解</span></span><br><span class="line"><span class="class">    @<span class="title">Import</span> 会实现 @<span class="title">EnableAutoConfiguration</span>, 总之都是熟悉的 <span class="title">spring</span> 套路. <span class="title">boot</span>的东西就少了.</span></span><br><span class="line"><span class="class">8) 调用留给子类的 <span class="title">afterRefresh</span>() 方法, 默认空实现</span></span><br><span class="line"><span class="class">9) 打印启动完毕信息</span></span><br><span class="line"><span class="class">10) 触发 <span class="title">run</span> 的 <span class="title">started</span> 事件</span></span><br><span class="line"><span class="class">11) 调用 容器内所有的 <span class="title">ApplicationRunner</span> 和 <span class="title">CommandLineRunner</span> 实现类, 类似事件监听.</span></span><br><span class="line"><span class="class">12) 使用 <span class="title">spring</span>.<span class="title">factories</span> 中的 <span class="title">exceptionReporters</span> 处理可能出现的异常.</span></span><br><span class="line"><span class="class">13) 触发 <span class="title">run</span> 的 <span class="title">running</span> 事件</span></span><br></pre></td></tr></table></figure>



<h4 id="一些东西的实现原理"><a href="#一些东西的实现原理" class="headerlink" title="一些东西的实现原理"></a>一些东西的实现原理</h4><h5 id="ConfigurationProperties-如何实现自动注入application-properties中配置的值"><a href="#ConfigurationProperties-如何实现自动注入application-properties中配置的值" class="headerlink" title="@ConfigurationProperties 如何实现自动注入application.properties中配置的值?"></a><code>@ConfigurationProperties</code> 如何实现自动注入<code>application.properties</code>中配置的值?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先加了 <span class="meta">@EnableConfigurationProperties</span> 也会解析里面的 <span class="meta">@Import</span> </span><br><span class="line"><span class="number">2</span>) <span class="meta">@Import</span> 则引入了 EnableConfigurationPropertiesRegistrar<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">3) 这是一个 <span class="title">ImportBeanDefinitionRegistrar</span> 的实现类, 会在解析 @<span class="title">Configuration</span> 注解时调用指定方法</span></span><br><span class="line"><span class="class">4) 指定方法 <span class="title">registerBeanDefinitions</span>() 获取 @<span class="title">EnableConfigurationPropertiesRegistrar</span> 的数据</span></span><br><span class="line"><span class="class">    如 @<span class="title">EnableConfigurationProperties</span>(<span class="title">RabbitProperties</span>.<span class="title">class</span>) 加载 <span class="title">RabbitProperties</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    然后, 将这些 <span class="title">class</span> 都注册到容器中</span></span><br><span class="line"><span class="class">5) 指定方法还注册了一些工具<span class="title">bean</span>和一个重要的 <span class="title">BeanPostProcessor</span> 在 <span class="title">registerInfrastructureBeans</span>()中</span></span><br><span class="line"><span class="class">6) <span class="title">registerInfrastructureBeans</span>() 加载了 <span class="title">ConfigurationPropertiesBindingPostProcessor</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">7) 在 <span class="title">postProcessorBeforeInitialization</span>() 中 调用 <span class="title">ConfigurationPropertiesBinder</span></span></span><br><span class="line"><span class="class">8) 调用链很长, 最后 <span class="title">property</span>.<span class="title">setValue</span>(<span class="title">beanSupplier</span>, <span class="title">bound</span>)</span>;设置了值 -- JavaBeanBinder</span><br><span class="line"></span><br><span class="line">总结: 就是先将 XxxProperties 类定义注入到容器中, 这样可以getBean, 然后通过 BeanPostProcessor</span><br><span class="line">    再实例化后将属性值一一绑定.</span><br></pre></td></tr></table></figure>

<h5 id="ConditionalXxx-的实现原理"><a href="#ConditionalXxx-的实现原理" class="headerlink" title="@ConditionalXxx 的实现原理"></a><code>@ConditionalXxx</code> 的实现原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 在类上加上注解 <span class="meta">@Conditional</span> 或 带有 <span class="meta">@Conditional</span> 的其他注解:其他扩展实现</span><br><span class="line"><span class="number">2</span>) 在所有的扫描类和注解的地方,如解析<span class="meta">@Configuration</span>, AnotatedBeanDefinitionReader等reader</span><br><span class="line">    会使用 ConditionEvaluator 的 shouldSkip() 判断是否可以加载, 时机点如下</span><br><span class="line">    AnnotatedBeanDefinitionReader#doRegisterBean() 的第二行代码</span><br><span class="line">    ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod() 第四行</span><br><span class="line">    ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass()</span><br><span class="line">    ConfigurationClassParser#doProcessConfigurationClass() 处理 ComponentScan 那段</span><br><span class="line"><span class="number">3</span>) 然后再 shouldSkip 中判断， 判断逻辑大致如下：</span><br><span class="line">    先遍历所有注解取得所有的 <span class="meta">@Conditional</span> 下的 所有 value, 这个 value 是具体的Condition实现, 如OnClassCondition</span><br><span class="line">    实例化 Condition 然后添加到 conditions中</span><br><span class="line">    排序并遍历调用 matches(), 一个不匹配则返回<span class="keyword">true</span>, 代表应该跳过.</span><br><span class="line"></span><br><span class="line">TIPS:</span><br><span class="line">ConditionOutcome 封装了是否匹配和匹配日志信息[为啥成功/为啥失败]</span><br><span class="line">SpringBootCondition 提供了通用的根据 ConditionOutcome 判断是否匹配并记录日志信息的抽象类.</span><br><span class="line">    子类只需实现 getMatchOutcome(): 根据 metadata[注解信息] 返回 ConditionOutcome 对象.</span><br><span class="line">    因此, 如果我们要实现自己的 Condition, 可以继承它.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另发现 <code>AutoConfigurationImportSelector</code> 也含有判断Condition的逻辑,<br>刚开始以为是 <code>AutoConfiguration</code> 的类没有走之前说到的判断, 所以这里要做判断.<br>后来我一想, 这是 @Import 引入的, 所以, 是走了判断的. 因此这里多出的一个 <code>AutoConfigurationImportFilter</code>, 应该是一个额外的插件, 专门过滤配置在 <code>spring.factories</code> 中的 <code>AutoConfiguration</code> 类的. 而插件的读取, 也是读取 <code>spring.factories</code> 来遍历. </p>
</blockquote>
<h5 id="AutoConfigureAfter-的实现原理"><a href="#AutoConfigureAfter-的实现原理" class="headerlink" title="@AutoConfigureAfter  的实现原理"></a><code>@AutoConfigureAfter</code>  的实现原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先 AutoConfigurationImportSelector 是一个 DeferredImportSelector  </span><br><span class="line"><span class="number">2</span>) 这种 DeferredImportSelector 会延迟加载, 原理是 parse 后再加载, 而非parse执行过程中就加载.</span><br><span class="line"><span class="number">3</span>) 延迟加载机制 会先调用 process 方法, 将要加载的<span class="class"><span class="keyword">class</span>保存起来, 然后再调用 <span class="title">selectImports</span> 返回.</span></span><br><span class="line"><span class="class">4) 此时 <span class="title">AutoConfigurationImportSelector</span>.<span class="title">AutoConfigurationGroup</span> 的 <span class="title">selectImports</span>() 会调用 <span class="title">sortAutoConfigurations</span>(), 也就是调用了 <span class="title">AutoConfigurationSorter</span>.<span class="title">getInPriorityOrder</span>()</span></span><br><span class="line"><span class="class">5) <span class="title">getInPriorityOrder</span>() 调用了 <span class="title">sortByAnnotation</span>() 这个方法根据2个注解 @<span class="title">AutoConfigureBefore</span> @<span class="title">AutoConfigureAfter</span> 排序.</span></span><br><span class="line"><span class="class">6) 最后返回的就是有序的了. 另外, 这两个注解只能作用再 <span class="title">AutoConfiguration</span> 上.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">总结:</span><br><span class="line">所有的 AutoConfiguration 所引入的<span class="class"><span class="keyword">class</span>文件解析完毕后, 再准备加载之前, 进行排序, 然后一一加载.</span></span><br></pre></td></tr></table></figure>



<h5 id="各种-AutoConfiguration-实现大致流程"><a href="#各种-AutoConfiguration-实现大致流程" class="headerlink" title="各种 AutoConfiguration 实现大致流程."></a>各种 <code>AutoConfiguration</code> 实现大致流程.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1) 首先是 @SpringBootApplication 启用了 @EnableAutoConfiguration</span><br><span class="line">2) @EnableAutoConfiguration 又使用 @Import 导入了 AutoConfigurationImportSelector.class</span><br><span class="line">3) 然后 AutoConfigurationImportSelector 导入 spring.factories所有的 EnableAutoConfiguration</span><br><span class="line">4) 最后，当一个项目依赖一个starter-xxx，会继承starter的依赖项, spring-boot-autoconfigure 由此被依赖</span><br><span class="line">5) spring-boot-autoconfigure 带有所有 boot 实现的 AutoConfiguration 和 spring.factories 配置</span><br><span class="line">6) 所以会加载该项目下 spirng.factories 中定义的 EnableAutoConfiguration</span><br><span class="line">7) 每个 AutoConfiguration 实现类被导入到容器中后</span><br><span class="line">	又被 ConfigurationClassPostProcessor 解析@Configuration, @Import 等注解 (老千层饼了)</span><br><span class="line">	这些AutoConfiguration会添加一些提供服务的 bean，或者再嵌套一层@Import，@Configuration等。</span><br><span class="line">	另外, 这些bean还是被自动配置了属性值的, 属性值哪里来? 都在 application.yml 中, 或是默认配置中.</span><br><span class="line">9) 这样，容器中就加入了一个或多个配置好的bean了, 可以直接使用. 如 stringRedisTemplate, jdbcTemplate</span><br></pre></td></tr></table></figure>

<h5 id="Spring-Boot-是如何自动扫描main方法所在类所在包的"><a href="#Spring-Boot-是如何自动扫描main方法所在类所在包的" class="headerlink" title="Spring Boot 是如何自动扫描main方法所在类所在包的?"></a>Spring Boot 是如何自动扫描main方法所在类所在包的?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) 首先是 @SpringBootApplication 启用了 @EnableAutoConfiguration</span><br><span class="line">2) @EnableAutoConfiguration 又使用 @AutoConfigurationPackage</span><br><span class="line">3) @AutoConfigurationPackage 中的 @Import 会被解析, Registrar.class 的registerBeanDefinitions会被执行</span><br><span class="line">4) 最终根据带有 @SpringBootApplication 的类对应的包名, 然后自动扫描到容器中, 效果同 @ComponentScan</span><br></pre></td></tr></table></figure>

<h5 id="application-properties-是如何被加载到Environment中的"><a href="#application-properties-是如何被加载到Environment中的" class="headerlink" title="application.properties 是如何被加载到Environment中的?"></a><code>application.properties</code> 是如何被加载到Environment中的?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) run方法中创建了Environment对象, 当初始化好一些东西后会触发事件</span><br><span class="line"><span class="number">2</span>) 通过 SpringApplicationRunListeners 的 environmentPrepared() 告知监听者</span><br><span class="line"><span class="number">3</span>) 默认存在 spring.factories 中的 EventPublishingRunListener 监听者负责转发事件</span><br><span class="line"><span class="number">4</span>) 事件被转发到 ApplicationListener 下的监听者来处理</span><br><span class="line"><span class="number">5</span>) 监听者配置在 spring.factories 中, 其中 ConfigFileApplicationListener 监听了此事件</span><br><span class="line"><span class="number">6</span>) 此监听者接受 ApplicationEnvironmentPreparedEvent 事件后</span><br><span class="line"><span class="number">7</span>) 加载一些 postProcessor 专门用于处理 environment 对象的 postProcessor</span><br><span class="line"><span class="number">8</span>) 其他的 postProcessor 暂时不管, 真正做了加载的是 postProcessors.add(<span class="keyword">this</span>); 自己的实现</span><br><span class="line"><span class="number">9</span>) 自己的处理方法是: addPropertySources(), 此方法将会扫描指定的路径下指定的某些文件</span><br><span class="line"><span class="number">10</span>) 然后使用 spring.factories 下的 PropertySourceLoader 一一尝试解析</span><br><span class="line"><span class="number">11</span>) 文件存在且解析正确则加入到 environment 的 propertySources.</span><br><span class="line">	某些路径: getSearchLocations() ,默认: classpath:/,classpath:/config/ ...</span><br><span class="line">	某些文件: getSearchNames() ,默认: application</span><br><span class="line"></span><br><span class="line">TIPS: </span><br><span class="line">PropertySourceLoader 有 PropertiesPropertySourceLoader/YamlPropertySourceLoader</span><br><span class="line">一个尝试后缀有 xml/properties, 另一个是 yml/yaml, 所以所有可能性有:</span><br><span class="line">    classpath:/application.xml; classpath:/application.properties</span><br><span class="line">	classpath:/application.yml; classpath:/application.yaml</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<h5 id="SpringApplication-run-如何加载-tomcat-的"><a href="#SpringApplication-run-如何加载-tomcat-的" class="headerlink" title="SpringApplication.run() 如何加载 tomcat 的?"></a><code>SpringApplication.run()</code> 如何加载 tomcat 的?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) boot 的 run 里面会创建 applicationContext, 如是 webApplicationType = SERVLET, 则实现类为 AnnotationConfigServletWebServerApplicationContext</span><br><span class="line">    另外一提, webApplicationType 是根据 classpath 下是否有哪些类来推断的.</span><br><span class="line"><span class="number">2</span>) 这个类继承了 ServletWebServerApplicationContext</span><br><span class="line"><span class="number">3</span>) ServletWebServerApplicationContext 实现了 onRefresh()</span><br><span class="line"><span class="number">4</span>) onRefresh() 调用了 createWebServer()</span><br><span class="line"><span class="number">5</span>) createWebServer() 使用 ServletWebServerFactory.getWebServer() 获取 webServer 对象</span><br><span class="line"><span class="number">6</span>) ServletWebServerFactory 会被 ServletWebServerFactoryAutoConfiguration 引入</span><br><span class="line">    详细见 ServletWebServerFactoryConfiguration.EmbeddedTomcat<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">7) 引入后调用 <span class="title">getWebServer</span>(), 大概为 <span class="title">new</span> <span class="title">Tomcat</span>(), 设置属性, 然后启动.</span></span><br><span class="line"><span class="class">8) 至此, <span class="title">run</span>() 启动了 <span class="title">tomcat</span> 或 <span class="title">jetty</span>/<span class="title">undertow</span>.</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line">TIPS:</span><br><span class="line">spring 使用工厂模式获取webServer, 然后工厂又通过AutoConfiguration自动注入(还会判断Condition).</span><br><span class="line">    这样如果新增一种 webServer, 只需要在写一个 AutoConfiguration 注入一个 工厂即可. 非常灵活.</span><br></pre></td></tr></table></figure>





<h3 id="Spring-MVC-源码"><a href="#Spring-MVC-源码" class="headerlink" title="Spring MVC 源码"></a>Spring MVC 源码</h3><h4 id="关键类解析-1"><a href="#关键类解析-1" class="headerlink" title="关键类解析"></a>关键类解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">WebMvcConfigurationSupport</span><br><span class="line">	默认注册了很多东西,如HandlerMapping几个实现, HandlerAdaptor几个实现</span><br><span class="line"></span><br><span class="line">HandlerMapping</span><br><span class="line">	添加容器内所有带有RequestMaping的类的公开方法到 mappings 中</span><br><span class="line">		(AbstractHandlerMethodMapping#afterPropertiesSet中)</span><br><span class="line">    根据request的uri查找对应的HandlerMethod, 步骤概述:</span><br><span class="line">    	把RequestMapping注解内的path作为key保持到一个map1</span><br><span class="line">    	其他信息封装成mapping作为key也保持到另一个map2</span><br><span class="line">    	根据uri去 map1 获取 mapping, 再根据mapping 获取 HandlerMethod</span><br><span class="line">    	封装成Match对象, 与其他匹配对象做比较后, 返回 HandlerMethod</span><br><span class="line"></span><br><span class="line">HandlerAdapter</span><br><span class="line">	初始化参数解析，返回值解析等</span><br><span class="line">		(RequestMappingHandlerAdapter#afterPropertiesSet)</span><br><span class="line">	根据Handle确定对应的HandlerAdapter, 然后执行这个 handler</span><br><span class="line">    如RequestMappingHandlerAdapter 则负责执行 HandlerMethod</span><br><span class="line">    	简单说就是封装 HandlerMethod, 根据参数值设置参数, 然后调用方法, 再处理返回值封装成ModelAndView</span><br><span class="line">    另外， 这里如果使用了@ResponseBody，会进入 RequestResponseBodyMethodProcessor</span><br><span class="line">    	然后使用messageConverters（json）写入到响应流</span><br><span class="line">    	最后mv也直接返回null， 不需要render了。</span><br><span class="line"></span><br><span class="line">ViewResolver</span><br><span class="line">	负责将ModelAndView解析成HTML, 如JSP, FreeMarker</span><br><span class="line"></span><br><span class="line">HandlerExecutionChian</span><br><span class="line">	管理拦截器和封装Handler, 负责拦截器的实际调用逻辑实现</span><br><span class="line">	</span><br><span class="line">DispatcherServlet</span><br><span class="line">	调度整个HTTP请求响应流程, 调用各个子组件负责执行处理方法, 解析视图, 处理异常等.</span><br></pre></td></tr></table></figure>

<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET</span><br><span class="line">HttpServlet#service()</span><br><span class="line">HttpServlet#doGet()</span><br><span class="line">FrameworkServlet#doGet()</span><br><span class="line">FrameworkServlet#processRequest()</span><br><span class="line">FrameworkServlet#doService()</span><br><span class="line">DispatcherServlet#doService()</span><br><span class="line">DispatcherServlet#doDispatch()</span><br><span class="line">	调用容器内所有的HandlerMapping的实现类的getHandler方法, 返回HandlerExecutionChain</span><br><span class="line">	调用容器内所有的HandlerAdaptor的实现类寻找适合的当前Hanlder的HandlerAdaptor</span><br><span class="line">	执行拦截器的 preHandle 方法, 并根据返回结果判断是否接续执行</span><br><span class="line">	HandlerAdaptor执行handle方法</span><br><span class="line">	进入RequestMappingHandlerAdaptor执行handle-&gt;handlerInternal-&gt;invokeHandlerMethod</span><br><span class="line">	生成ServletInvocableHandlerMethod(就是实现了反射调用方法和设置参数,处理返回值等操作)</span><br><span class="line">	调用invokeAndHandle--&gt;invokeForRequest</span><br><span class="line">		其中getMethodArgumentValues挨个调用HandlerMethodArgumentResolver获取参数值</span><br><span class="line">	然后执行 doInvoke, 利用反射技术调用 Method, method.invoke(obj, args);</span><br><span class="line">	执行完后, 返回结果, 回到 invokeAndHandle 调用 returnValueHandlers 处理返回结果</span><br><span class="line">	返回后 回到 invokeHandlerMethod, 调用 getModelAndView 获取通用的返回值(可能是空)</span><br><span class="line">	返回ModelAndView后, 回到doDispatch, 设置默认viewName (mv为空则不需要设置)</span><br><span class="line">	执行拦截器的 postHandle 方法</span><br><span class="line">	processDispatchResult 中的 render 解析视图后通过response 响应这个view</span><br><span class="line">	根据异常情况执行异常处理器, 以及执行拦截器的 afterCompletion 方法</span><br></pre></td></tr></table></figure>

<h4 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">何时加入?</span><br><span class="line">	从WebMvcConfigurationSupport的子类中调用addInterceptors </span><br><span class="line">	添加一些拦截器和拦截器的路径配置 InterceptorRegistry 和 MappedInterceptor</span><br><span class="line">    实现拦截器路径匹配, 在 new HandlerExecutionChian 时判断</span><br><span class="line"></span><br><span class="line">何时执行?</span><br><span class="line">	DispatcherServlet 负责在正确的时机调用 HandlerExecutionChian 来调用 preHanlde 等方法.</span><br><span class="line">	拿到 HandlerExecutionChian 后调用 preHanlde</span><br><span class="line">	HandlerAdapter执行完handler后, 调用 postHandle</span><br><span class="line">	解析视图并渲染到response之后, 调用 afterCompletion</span><br><span class="line">	如果中途出现异常, 或preHandle提前结束, 则也调用afterCompletion</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">	DispatcherServlet 去调用 HandlerExecutionChian去调用 拦截器具体方法. </span><br><span class="line">	复杂点是添加一个拦截器到被加入到HandlerExecutionChian比较复杂一点, 以及带路径匹配的拦截器实现略复杂一些.</span><br></pre></td></tr></table></figure>



<h3 id="Mybatis-源码"><a href="#Mybatis-源码" class="headerlink" title="Mybatis 源码"></a><code>Mybatis</code> 源码</h3><h4 id="关键类解析-2"><a href="#关键类解析-2" class="headerlink" title="关键类解析"></a>关键类解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Configuration</span><br><span class="line">	作用: 解析和保存大配置(mybatis全局配置,如数据库连接, 别名等), 小配置(每个mapper文件)信息</span><br><span class="line"></span><br><span class="line">MapperProxy, MapperMethod</span><br><span class="line">	作用: 生成daoImpl代理对象和实现接口方法: 调用sqlSession 操作方法</span><br><span class="line"></span><br><span class="line">Executor</span><br><span class="line">	作用: 协调和管理StatementHandler, ParameterHandler, ResultSetHandler, 解析mapperStatement配置信息成BoundSql.</span><br><span class="line"></span><br><span class="line">StatementHandler</span><br><span class="line">	作用: 生成preparedStatment对象(JDBC的), 调用execute方法.</span><br><span class="line"></span><br><span class="line">ParameterHandler</span><br><span class="line">	作用: 管理并使用TypeHandler为preparedStatment对象设置参数,</span><br><span class="line"></span><br><span class="line">ResultSetHandler</span><br><span class="line">	作用: 将ResultSet结果集转成接口返回值认识的数据, 负责延迟加载.</span><br></pre></td></tr></table></figure>

<h4 id="生命周期与执行流程"><a href="#生命周期与执行流程" class="headerlink" title="生命周期与执行流程"></a>生命周期与执行流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.读取配置文件, 解析xml(或properties)获得配置信息(数据库配置和mapperSql等) Configuration</span><br><span class="line">2.获取数据库连接, 开启事务, 准备执行sql (openSession)</span><br><span class="line">3.使用动态代理技术生成代理类</span><br><span class="line">4.代理类根据代理方法对应的mapperStatement类型调用sqlSession的insert,update,delete,selectXxx方法 (MapperProxy, MapperMethod)</span><br><span class="line">4.sqlSession调用Executor执行sql (Exector, SimpleExecutor, CachingExecutor)</span><br><span class="line">5.Executor 生成StatementHandler对象并解析xml中sql参数, 再使用ParameterHandler设置参数. (BaseExecutor, StatmentHandler, ParameterHandler, TypeHandler 前三个可被插件拦截任意方法)</span><br><span class="line">6.最后使用OGNL表达式解析库对 if,foreach,where等标签解析生成最总sql (ONGL)</span><br><span class="line">7.执行sql后获得resultSet, 使用 ResultSetHandler 处理后返回结果(resultMap, resultType的处理在这里) (ResultSetHandler 可被插件拦截任意方法)</span><br><span class="line">8.根据事务配置提交事务(自动提交), 保存一级缓存</span><br><span class="line">9.如开启二级缓存, Executor还会被装饰器模式包装一层, 将结果缓存到MapperStatement的cache变量中.</span><br><span class="line"></span><br><span class="line">TIPS:</span><br><span class="line">1.插件的使用实在Executor, StatementHandler, ParameterHandler, ResultSetHandler这几个对象实例化的时候, 使用jdk动态代理将配置里配置的形成代理链. 返回代理对象, 但调用方法时, 会判断是否拦截此方法并执行插件的代码.</span><br></pre></td></tr></table></figure>

<h4 id="使用到的设计模式"><a href="#使用到的设计模式" class="headerlink" title="使用到的设计模式"></a>使用到的设计模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.代理模式</span><br><span class="line">	MapperProxy 生成 mapper 实现类 jdk代理</span><br><span class="line">	Plugin 生成代理对象实现插件 jdk代理</span><br><span class="line">	ResultSetHandler(LazyLoad) cblib, javassist</span><br><span class="line">2.装饰者模式</span><br><span class="line">	CachingExecutor: 装饰SimpleExecutor添加二级缓存功能</span><br><span class="line">	Cache,FifoCache... 使用装饰者模式为缓存添加不同特性(功能)</span><br><span class="line">3.适配器模式</span><br><span class="line">	StatementHandler</span><br><span class="line">4.责任链模式</span><br><span class="line">	Interceptor(拦截Executor、StatementHandler、ParameterHandler、ResultSetHandler对象)</span><br><span class="line">5.策略模式			</span><br><span class="line">	StatementHandler</span><br><span class="line">		PreparedStatementHandler,CallableStatementHandler,SimpleStatementHandler</span><br><span class="line">	Executor</span><br><span class="line">		SimpleExecutor,ReuseExecutor,BatchExecutor</span><br><span class="line">	TypeHandler</span><br><span class="line">		UnknownTypeHandler, IntegerTypeHandler, NStringTypeHandler</span><br><span class="line">6.建造器模式</span><br><span class="line">	org.apache.ibatis.mapping.MappedStatement.Builder</span><br><span class="line">	org.apache.ibatis.builder.xml.XMLConfigBuilder</span><br></pre></td></tr></table></figure>

<h4 id="一级缓存实现"><a href="#一级缓存实现" class="headerlink" title="一级缓存实现"></a>一级缓存实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.put时机: </span><br><span class="line">	org.apache.ibatis.executor.BaseExecutor#queryFromDatabase 的 localCache.putObject(key, list)</span><br><span class="line">	</span><br><span class="line">2.get时机:</span><br><span class="line">	org.apache.ibatis.executor.BaseExecutor#query 的 localCache.getObject(key)</span><br><span class="line">	</span><br><span class="line">3.存在哪里</span><br><span class="line">	org.apache.ibatis.executor.BaseExecutor#localCache</span><br><span class="line">	这个类每次openSession会新建一个Executor实例</span><br></pre></td></tr></table></figure>

<h4 id="二级缓存实现"><a href="#二级缓存实现" class="headerlink" title="二级缓存实现"></a>二级缓存实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.put时机: </span><br><span class="line">	org.apache.ibatis.executor.CachingExecutor#query的tcm.putObject</span><br><span class="line">	然后实际上是调用了cache的put, cache实际上来自Configuration解析mapper文件时创建的, 即同一个mapper共用同一个cache.</span><br><span class="line">	</span><br><span class="line">2.get时机:</span><br><span class="line">	org.apache.ibatis.executor.CachingExecutor#query的tcm.getObject, cache实际是: 同上</span><br><span class="line"></span><br><span class="line">3.remove时机:</span><br><span class="line">	org.apache.ibatis.executor.CachingExecutor#flushCacheIfRequired</span><br><span class="line"></span><br><span class="line">注意事项: 上述时机都是TransactionCacheManager的调用, 而TransactionCacheManager会根据事务的提交和回滚来处理缓存的写入与移除时机, 如真实移除时机是下一次commit触发, 真实写入也是commit时触发.</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">4.存在哪里</span><br><span class="line">	org.apache.ibatis.mapping.MappedStatement</span><br><span class="line">	也算是在 org.apache.ibatis.session.Configuration 中</span><br></pre></td></tr></table></figure>





<h3 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a><code>Mybatis-Plus</code></h3><h2 id="IO-网络"><a href="#IO-网络" class="headerlink" title="IO / 网络"></a>IO / 网络</h2><h3 id="AIO-NIO-BIO"><a href="#AIO-NIO-BIO" class="headerlink" title="AIO, NIO, BIO"></a>AIO, NIO, BIO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BIO: 从 jdk1.4 前, 采用 ServerSocket API 进行网络连接, 所有操作都是阻塞的(如监听, 读&#x2F;写)</span><br><span class="line">NIO: 从 jdk1.4 起, 对于所有操作都是依赖事件驱动, 只需较少的线程即可处理大量请求</span><br><span class="line">AIO: jdk1.7 起, 在 NIO 基础上实现异步, 所有事件通知由系统通知, 而非NIO 那样轮询</span><br></pre></td></tr></table></figure>

<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TCP: 是面向连接的协议, 收发数据前, 必须建立可靠的连接(通过三次握手)</span><br><span class="line">UDP: 是无连接的协议, 收发数据不需要建立连接(握手)</span><br><span class="line"></span><br><span class="line">区别:</span><br><span class="line">速度: TCP 满, UDP 快</span><br><span class="line">正确性&#x2F;完整性: TCP 好, UDP 无</span><br><span class="line">顺序性: TCP 好, UDP 无</span><br><span class="line"></span><br><span class="line">应用:</span><br><span class="line">TCP: 文件下载, HTTP, DNS, IM 通讯</span><br><span class="line">UDP: 网络游戏, 直播推流</span><br></pre></td></tr></table></figure>

<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><blockquote>
<p>封装了复杂的NIO接口, 提供了简单的 API 实现服务端和客户端高并发通讯, 并封装了很多工具, 如心跳超时, 半包处理, websocket 等.</p>
</blockquote>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="队列-栈"><a href="#队列-栈" class="headerlink" title="队列,  栈"></a>队列,  栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">队列: 先进先出 FIFO</span><br><span class="line">栈: LIFO</span><br></pre></td></tr></table></figure>

<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单向链表: Node&#123;next: Node&#125;</span><br><span class="line">双向链表: Node&#123;prev: Node, next: Node&#125;</span><br><span class="line">循环链表: Node&#123;first: Node, last: Node, prev: Node, next: Node&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">二叉树:</span><br><span class="line">	先序遍历: 根-&gt;左-&gt;右</span><br><span class="line">	中序遍历: 左-&gt;根-&gt;右</span><br><span class="line">	后序遍历: 左-&gt;右-&gt;根</span><br><span class="line"></span><br><span class="line">红黑树:</span><br><span class="line">	红黑树是一种含有红黑结点并能自平衡的二叉查找树.</span><br><span class="line">	任意一结点到每个叶子结点的路径都包含数量相同的黑结点.</span><br><span class="line">	速度: O(log2 n) 最坏: O(log n)</span><br><span class="line">	对比 BST: 查找更快, 插入更慢.</span><br><span class="line">	对比 AVL: 查找略慢, 插入更快.</span><br><span class="line">	</span><br><span class="line">B+树:</span><br><span class="line">	所有记录节点存放在叶子节点上，且是顺序存放，由各叶子节点指针进行连接。</span><br><span class="line">	如果从最左边的叶子节点开始顺序遍历，能得到所有键值的顺序排序。</span><br><span class="line">	查找速度和树高度有关, 如 MySQL 树高度为 3, 则总是查询 3 次找到子节点, 即得到数据.</span><br></pre></td></tr></table></figure>



<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">快速排序: O(nlog(n))</span><br><span class="line">	将数组分为2半，并计算一个中间值，将左边所有大于中间值的移到右边，把右边所有小于中间值的移到左边，</span><br><span class="line">	然后分别对左边和右边递归处理（再分2半，再取中间值，再移动，再递归），直到无需递归为止。</span><br><span class="line"></span><br><span class="line">归并排序: O(nlog(n))</span><br><span class="line">	将数组不断两两拆分，直到无法拆分（只有2个元素）时开始对拆分后的元素进行排序，然后不断回溯，</span><br><span class="line">	不断排序，直到第一次拆分，即所有元素都是有序的了。排序方式为先取两个部分的第一个下标，</span><br><span class="line">	互相判断，谁小谁放到有序数组中，然后小的那个下标移位，继续判断，直到其中一个部分所有元素取完，</span><br><span class="line">	则将另一部分剩余元素批量直接拷贝到有序数组即可。</span><br><span class="line"></span><br><span class="line">冒泡排序: O(n^2) 最好 O(n)</span><br><span class="line">	进行 n - 1 轮， 每轮遍历数组两两比较交换，从而达到把最大的交换到最后面。下轮遍历数组个数减一。</span><br><span class="line"></span><br><span class="line">选择排序: O(n^2)</span><br><span class="line">	进行 n - 1 轮，每轮遍历选择数组最小值放到最前面，下轮遍历数组个数减一</span><br><span class="line"></span><br><span class="line">插入排序: O(n^2) 最好 O(n)</span><br><span class="line">	分2个数组，有序和无序，开局有序默认含有数组第一个元素，无序含有剩余的元素。</span><br><span class="line">	遍历无序所有元素，从后向前比较大小，然后进行插入到有序数组中或对数组元素移位。</span><br><span class="line"></span><br><span class="line">希尔排序: O(n^1.25)</span><br><span class="line">	对数组进行分组，对每组使用插入排序的移位进行排序，第一次分 数组长度&#x2F;2 组，</span><br><span class="line">	下一次分组为数组长度&#x2F;2再&#x2F;2组，若分 长度&#x2F;2 组，则每组2个， 若分 长度&#x2F;2&#x2F;2 组，</span><br><span class="line">	则每组 2*2 个，直到长度为1. 这是一个将数组后段数据尽可能与前段数据排序，</span><br><span class="line">	改进插入排序后端数据过小导致移位操作过多的问题。</span><br><span class="line"></span><br><span class="line">基数排序: O(n)</span><br><span class="line">	创建10个桶，每个桶大小均为数组长度，然后遍历数组，从元素的最低位（个位）开始，</span><br><span class="line">	取出并放到对应的桶（如个位是8，则放到第8个桶中），放完后，顺序遍历所有桶，</span><br><span class="line">	顺序取出每个元素，组成新数组，再将新数组按以上流程处理十位，再百位，直到数组中的最大数的最高位。</span><br><span class="line">	</span><br><span class="line">堆排序：</span><br><span class="line">	。。。</span><br></pre></td></tr></table></figure>

<h4 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">贪心算法</span><br><span class="line">爬山算法</span><br><span class="line">模拟退火算法</span><br><span class="line">遗传算法</span><br><span class="line">蚁群搜索算法</span><br></pre></td></tr></table></figure>



<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="7-大原则"><a href="#7-大原则" class="headerlink" title="7 大原则"></a>7 大原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单一职责: 每个类只负责一个职责(或每个方法)</span><br><span class="line">接口隔离: 一个类对另一个类的依赖应建立在最小的接口上</span><br><span class="line">依赖倒转: 高层模块不应依赖低层模块, 二者都应该依赖接口而非细节. 细节依赖抽象, 面向接口编程</span><br><span class="line">里式替换: 子类应该做到可以替换父类, 及子类应尽量不重写父类方法.</span><br><span class="line">开闭原则: 对提供者而已可以修改, 对使用者而言不需要修改(即代码兼容性), 尽量使用扩展增加功能, 而非修改原有类</span><br><span class="line">迪米特法则: 一个对象应该对其他对象保持最小了解(最少知道原则)</span><br><span class="line">合成复用原则: 一个类使用另一个类的代码(方法), 尽量使用合成, 而不是继承</span><br></pre></td></tr></table></figure>



<h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原理: 确保一个类只有一个实例，并提供该实例的全局访问点。</span><br><span class="line"></span><br><span class="line">饿汉式:</span><br><span class="line">	静态常量</span><br><span class="line">	静态代码块</span><br><span class="line">懒汉式:</span><br><span class="line">	直接判断(线程不安全)</span><br><span class="line">	方法加 synchronized(线程安全, 效率低)</span><br><span class="line">	判断后再同步(错误写法)</span><br><span class="line">	双重判断(if-同步-if) (推荐写法)</span><br><span class="line">	匿名静态内部类 (简单, 推荐)</span><br><span class="line">	枚举(简单, 但对象方法写在枚举中, 略有不适)</span><br><span class="line">	</span><br><span class="line">示例:</span><br><span class="line">	java.lang.Runtime#getRuntime()</span><br><span class="line">	java.awt.Desktop#getDesktop()</span><br></pre></td></tr></table></figure>

<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原理: 使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象.</span><br><span class="line">示例: Java 的 Object 对象的 clone 方法, java.util.Arrays.ArrayList#toArray()</span><br><span class="line"></span><br><span class="line">浅拷贝: 仅对基础类型及字符串类型的字段拷贝值</span><br><span class="line">深拷贝: 同时对引用类型(如数组,对象) 也进行拷贝</span><br><span class="line"></span><br><span class="line">深拷贝实现:</span><br><span class="line">1.重写 clone, 一一处理每个引用对象(调用对象的 clone), 麻烦, 且若对象之间关系复杂, 其中一个未实现深拷贝则导致 bug.</span><br><span class="line">2.利用序列化和反序列化, 如 Json, 或 Java 自带的序列化方式(二进制)</span><br></pre></td></tr></table></figure>

<h4 id="创建者模式-生成器模式"><a href="#创建者模式-生成器模式" class="headerlink" title="创建者模式(生成器模式)"></a>创建者模式(生成器模式)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	封装一个对象的构造过程，并允许按步骤构造.</span><br><span class="line">	若对象的生成过于复杂(字段极多且赋值还有依赖关系, 需要顺序调用), 则可将赋值过程封装成一个build(), 并放到一个 Builder 类中. 此类对外提供各个字段的赋值方法并先保存起来, 直到调用 build(), 此方法返回对象实例. </span><br><span class="line">	使用此模式, 调用者无需关注构建过程, 只需设置自己想要的值, 然后调用 build() 即可得到对象实例. 且若增加或修改字段, 构造过程变化, 调用者无感知, 无需修改代码. 符合开闭原则.</span><br><span class="line"></span><br><span class="line">示例: StringBuilder, 一些框架的 ConfigurationBuilder(如 xmpp), 用于构建配置.</span><br></pre></td></tr></table></figure>

<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</span><br><span class="line">	此模式可避免多个调用者创建对象时判断创建哪个子类的重复代码, 且若多一个子类, 调用者无需修改代码.</span><br><span class="line">	</span><br><span class="line">示例: Spring ApplicationContext 的 getBean 方法.</span><br></pre></td></tr></table></figure>

<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</span><br><span class="line">	此模式解决了简单工厂每增加一个子类需要修改工厂类的问题.</span><br><span class="line">	此模式存在问题, 若新增一个子类, 需同时新增一个子类工厂, 系统复杂性更高.</span><br><span class="line"></span><br><span class="line">示例: Calendar, NumberFormat</span><br></pre></td></tr></table></figure>

<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	提供一个接口，用于创建 相关的对象家族.</span><br><span class="line">  同上, 由子类工厂决定创建哪些对象.</span><br><span class="line">	此模式是工厂方法的升级版, 不同之处在于它同时创建多个种类的对象(工厂类具有多个方法).</span><br><span class="line">	此模式将一个对象家族的新建集合到一个工厂类创建管理, 这些对象家族相互之间一般有关联, 在创建时就可以处理这些关联. 且对于 2 个子类工厂, 一般可以无缝切换, 使得修改代码极为方便(即换一个子类工厂).</span><br><span class="line">	此模式在新增一个对象家族的成员时非常麻烦(即所有工厂类需要新增一个方法), 但再新增一类对象家族时比较简单(即新增一个子类工厂).</span><br></pre></td></tr></table></figure>



<h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	把一个接口转换成另一个用户需要的接口.</span><br><span class="line">	定义一个类, 实现用户需要的接口, 并聚合一个需要转换的接口对象, 在重写的方法(用户需要的方法)中调用聚合的对象的方法, 若需要返回值, 且返回值类型不一致, 则还需要在方法中处理一番, 然后返回. 这个过程叫做适配.这个类叫做适配器类.</span><br><span class="line">	使用此模式可对一些老旧接口适配兼容.</span><br><span class="line">	</span><br><span class="line">示例: java.util.Arrays#asList() 将数组适配成 List, Spring MVC的 HandlerAdapter</span><br></pre></td></tr></table></figure>

<h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	将一个或多个功能(方法)动态的新增到一个类中.</span><br><span class="line">	把需要新增功能类称为 A,定义一个类B,实现A的上层接口, 并聚合一个A 的实例对象, B类实现的接口中, 对其他不关心的方法直接调用聚合的对象的方法. 对于关心的方法则可以在调用前后进行加料处理(如一个方法返回一个数, 可以在原来的返回值上乘以 2), 同时, B类也可以新增一些其他方法, 这些方法就是多出的功能. B类就是装饰者类, A就是被装饰类.</span><br><span class="line">	此模式的优点是, 装饰类也可以当做被装饰类, 然后再来一层装饰, 可以无限的装饰.</span><br><span class="line">	</span><br><span class="line">示例: java IO 流</span><br></pre></td></tr></table></figure>

<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	控制其他对象的访问(方法级), 将一些前置或后置的处理, 通过代理对象注入到目标对象的方法前后. 面向切面编程.</span><br><span class="line"></span><br><span class="line">类型:</span><br><span class="line">	静态代理: 定义一个代理类实现目标对象的上层接口, 并聚合一个目标对象, 重写方法时将前置后置处理加上.</span><br><span class="line">	动态代理: </span><br><span class="line">		JDK 动态代理: 需要目标对象有上层接口(自然接口内的方法才可以代理) </span><br><span class="line">			使用java.lang.reflect.Proxy#getProxyClass</span><br><span class="line">		CGLIB 动态代理: 是个类就行. 实现原理是 ASM 框架动态生成目标对象类的子类字节码, 然后通过反射生成代理对象.</span><br><span class="line"></span><br><span class="line">示例: Spring AOP</span><br></pre></td></tr></table></figure>

<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	将抽象与实现分离开来，使它们可以独立变化。</span><br><span class="line">	桥接的含义是, 一个桥, 放在哪里都有桥的 2 边, 桥的 2 边可以变化, 但桥始终不变. 此处, 桥代表一个操作(如手机上运行软件), 2 边代表 一个操作的 2 个维度(如手机和软件). 同时, 桥接后的操作也可以视为一个维度, 与另一个维度桥接(如手机上运行软件和人这 2 个维度, 可以进行桥接, 组成 3 维度嵌套桥接).</span><br><span class="line">	</span><br><span class="line">示例: JDBC 获取连接, 获取连接是一个维度, 数据库是一个维度, 数据库有多个, 所以这是一个数据库维度变化, 另一维度不变的桥接模式.</span><br></pre></td></tr></table></figure>

<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</span><br><span class="line">	如常见的 线程池, 常量池等, 使得对象的获取速度加快.</span><br><span class="line">	</span><br><span class="line">示例: java.lang.Integer#valueOf() java.lang.Boolean#valueOf()</span><br></pre></td></tr></table></figure>

<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	将对象组合成树形结构来表示“整体&#x2F;部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</span><br><span class="line">	一般需要部分和整体具有一定的相似度, 才能对其进行抽象.</span><br><span class="line">	对部分&#x2F;整体进行抽象, 得出一个公共抽象类或接口, 再实现类中根据具体角色做不同处理. </span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">	javax.swing.JComponent#add(Component) </span><br><span class="line">  java.util.Map#putAll(Map)</span><br><span class="line">  java.util.List#addAll(Collection)</span><br><span class="line">  java.util.Set#addAll(Collection)</span><br></pre></td></tr></table></figure>

<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用.</span><br></pre></td></tr></table></figure>



<h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><h4 id="职责链-责任链-模式"><a href="#职责链-责任链-模式" class="headerlink" title="职责链(责任链)模式"></a>职责链(责任链)模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	使多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止, 从而避免请求的发送者和接收者之间的耦合关系。</span><br><span class="line">	</span><br><span class="line">示例:</span><br><span class="line">	javax.servlet.Filter#doFilter()</span><br><span class="line">	netty 的 Handler Chain</span><br></pre></td></tr></table></figure>

<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</span><br><span class="line">	主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</span><br><span class="line"></span><br><span class="line">示例: </span><br><span class="line">	swing 的事件监听(按钮事件, 鼠标事件)</span><br><span class="line">	JS 的 事件监听</span><br></pre></td></tr></table></figure>

<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</span><br><span class="line">	状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为.</span><br></pre></td></tr></table></figure>

<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	定义一系列算法，封装每个算法，并使它们可以互换。</span><br><span class="line">	策略模式可以让算法独立于使用它的客户端。</span><br><span class="line">	策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法.</span><br><span class="line"></span><br><span class="line">示例: java.util.Comparator#compare() javax.servlet.http.HttpServlet</span><br></pre></td></tr></table></figure>

<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	定义算法框架，并将一些步骤的实现延迟到子类。</span><br><span class="line">	通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</span><br><span class="line"></span><br><span class="line">示例: java.util.Collections#sort()</span><br></pre></td></tr></table></figure>

<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	将一个对象(命令接收者)的每个操作拆分到每一个命令类中, 再使用一个命令管理类来管理这些命令. 使得命令可以放入队列中有序执行, 且可以统一记录命令的操作日志, 还可以支持撤销操作(每个命令都实现对应的撤销即可).</span><br><span class="line">	此模式的好处是, 若将命令抽象为几个标准的命令(如开,关), 然后管理多个命令接收者(如灯,电视机,空调)的操作, 可使新增命令接收者变得简单, 即扩展性好.</span><br><span class="line">	</span><br><span class="line">	又称万能遥控器.</span><br></pre></td></tr></table></figure>

<h4 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	集中相关对象之间复杂的沟通和控制方式。降低子系统之间的耦合.</span><br><span class="line">	类似一个消息收发中心, 负责字系统的消息中转, 使得子系统之间可以进行一定的交互.</span><br><span class="line">	</span><br><span class="line">示例: 线程池管理者线程和要执行的任务.</span><br></pre></td></tr></table></figure>

<h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</span><br><span class="line">	如对游戏的当前状态进行一个保存, 然后在后续游戏中死亡后可以读取这个状态重新开始.</span><br></pre></td></tr></table></figure>

<h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原理: </span><br><span class="line">	为一个对象结构（比如组合结构）增加新能力。</span><br><span class="line">	使用访问者模式可实现重载的动态绑定(即伪双分派), 效果与重载方法内使用 instanceof 是一样的, 但使用访问者模式, 可扩展性更好.</span><br></pre></td></tr></table></figure>

<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</span><br><span class="line"></span><br><span class="line">示例: java.util.Iterator</span><br></pre></td></tr></table></figure>

<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	为语言创建解释器，通常由语言的语法和语法分析来定义。</span><br><span class="line"></span><br><span class="line">示例: EL 表达式, Freemaker模板</span><br></pre></td></tr></table></figure>

<h4 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	使用什么都不做的空对象来代替 NULL, 避免空对象判断, 避免空指针异常.</span><br></pre></td></tr></table></figure>



<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><h3 id="Redis-缓存"><a href="#Redis-缓存" class="headerlink" title="Redis 缓存"></a>Redis 缓存</h3><h4 id="缓存穿透-攻击型"><a href="#缓存穿透-攻击型" class="headerlink" title="缓存穿透(攻击型)"></a>缓存穿透(攻击型)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">含义:</span><br><span class="line">	对于一个不存在的 key 进行访问, 会导致数据库不停地查询这个 key 进行缓存.</span><br><span class="line">	</span><br><span class="line">解决方案:</span><br><span class="line">	1.使用布隆过滤器, 一定不存在的数据会被过滤.</span><br><span class="line">	2.查询后缓存一个空结果, 但很快超时.(有缺点, 但简单)</span><br></pre></td></tr></table></figure>

<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">含义:</span><br><span class="line">	缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</span><br><span class="line">	</span><br><span class="line">解决方案:</span><br><span class="line">	1.设置超时时, 在原有的失效时间基础上增加一个随机值，比如1-5分钟随机</span><br><span class="line">	2.加锁或者队列的方式保证缓存的单线 程（进程）, 避免大量请求打到数据库.</span><br></pre></td></tr></table></figure>

<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">含义:</span><br><span class="line">	单一热点 key 失效时导致大量请求打到数据库。</span><br><span class="line"></span><br><span class="line">解决方案:</span><br><span class="line">	1.分布式互斥锁(redis,zookper)</span><br><span class="line">	2.添加超时字段记录超时(比实际超时小一些), 每次获取数据根据字段判断是否超时, 若是, 则马上延长超时字段, 然后加载数据库重新缓存</span><br><span class="line">	3.redis不设置过期, 通过添加超时字段判断, 超时则代码异步跑一个重新缓存的任务(这里代码需要先本地加锁, 再加分布式锁).</span><br></pre></td></tr></table></figure>



<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><blockquote>
<p>解耦, 异步, 削峰</p>
</blockquote>
<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义:</span><br><span class="line">	为面向服务的架构（SOA）提供基本的最终一致性实现. 即将 2 个系统的交互通过消息队列中转, 以防止某个系统临时挂了导致调用失败.</span><br><span class="line">示例: 下单系统调用库存系统, 若当时库存系统正好挂了, 则导致下单失败. 此时将请求放到消息队列中, 库存系统读取消息进行处理, 若当时库存挂了也没关系, 处理失败也没关系(可重试, 且重试代码比较简单).</span><br></pre></td></tr></table></figure>

<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义:</span><br><span class="line">	对于某些不要求返回值的耗时操作, 可异步处理.</span><br><span class="line">示例:</span><br><span class="line">	用户下单后, 需发送多个下单提醒(微信通知, 短信通知, 邮件通知), 每个操作都比较耗时, 可考虑将其放入消息队列后直接返回, 由另一段代码负责读取消息发送通知.</span><br></pre></td></tr></table></figure>

<h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义:</span><br><span class="line">	将请求高峰打平, 使得系统可以处理过来.</span><br><span class="line">示例:</span><br><span class="line">	某次秒杀 1 分钟过来 1 万请求, 而系统一分钟大概只能处理 1千 请求, 系统要处理完这些请求理论需要 10 分钟, 但如果不做处理, 请求瞬间打过来, 系统直接卡死, 卡住时候一分钟可能只能处理 100 请求. 此时需要将所有请求都打到队列里面, 系统再慢慢从队列中读取处理.</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/30/source-code-spring-cloud-gateway/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/source-code-spring-cloud-gateway/" class="post-title-link" itemprop="url">source-code-spring-cloud-gateway</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-30 17:07:38" itemprop="dateCreated datePublished" datetime="2021-01-30T17:07:38+08:00">2021-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-31 00:50:53" itemprop="dateModified" datetime="2021-01-31T00:50:53+08:00">2021-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/30/source-code-spring-cloud-gateway/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/30/source-code-spring-cloud-gateway/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Gateway-源码笔记"><a href="#Spring-Gateway-源码笔记" class="headerlink" title="Spring Gateway 源码笔记"></a>Spring Gateway 源码笔记</h1><h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">1.DispatcherHandler</span><br><span class="line">	Spring Webflux 的核心类, 负责协调 HandlerMapping 和 HandlerAdapter</span><br><span class="line"></span><br><span class="line">2.HandlerMapping</span><br><span class="line">	Spring Webflux 的核心类, 负责根据请求信息查找 handler</span><br><span class="line"></span><br><span class="line">3.HandlerAdapter</span><br><span class="line">	Spring Webflux 的核心类, 负责执行 handler</span><br><span class="line">	</span><br><span class="line">4.RoutePredicateHandlerMapping</span><br><span class="line">	Spring Gateway 实现的 HandlerMapping, 负责根据谓词查找 Route 对象并返回 handler(FilteringWebHandler)</span><br><span class="line"></span><br><span class="line">5.FilteringWebHandler</span><br><span class="line">	是一个 handler</span><br><span class="line">	用于获取 route 对象的信息(主要是 GatewayFilter), 然后封装所有拦截器(包括 GlobalFilter)到 DefaultGatewayFilterChain, 挨个执行, 倒叙回归.</span><br><span class="line">	</span><br><span class="line">6.RoutePredicateFactory</span><br><span class="line">	谓词实现类的工厂类</span><br><span class="line">	负责创建具体的谓词工厂(如 Path, Method, Before 等)</span><br><span class="line">	apply() 返回一个 Predicate</span><br><span class="line">	</span><br><span class="line">7.Predicate</span><br><span class="line">	定义了 <span class="built_in">test</span> 方法, 返回 Boolean 值, <span class="literal">true</span> 代表匹配, <span class="literal">false</span> 代表不匹配(指匹配 Route)</span><br><span class="line">	</span><br><span class="line">8.GlobalFilter/GatewayFilter</span><br><span class="line">	定义了一个拦截方法, 可拦截请求进行相应处理</span><br><span class="line">	</span><br><span class="line">9.AsyncPredicate/AndAsyncPredicate</span><br><span class="line">	AsyncPredicate 本质上是一个方法(单方法接口), 方法被调用时会调用保存的 Predicate 类型字段的 <span class="built_in">test</span>() 方法.</span><br><span class="line">  AndAsyncPredicate 是一个左右结构的 AsyncPredicate, 进行判断时先判断左边, 再判断右边</span><br><span class="line">  若不断的 and, 会形成树结构. 所以执行时类似遍历二叉树.</span><br><span class="line"></span><br><span class="line">10.RouteDefinitionRouteLocator</span><br><span class="line">	负责从不同的 Locator(如配置文件) 获取 RouteDefinition, 并负责将 RouteDefinition 转成 Route 对象</span><br><span class="line">	</span><br><span class="line">11.RouteDefinition</span><br><span class="line">	包含有路由的所有配置信息, 含谓词, 拦截器, id, url 等等, 但都是字符串.</span><br><span class="line">	</span><br><span class="line">12.Route</span><br><span class="line">	含有的配置信是转化好了的, 如 Predicate 和 GatewayFilter.</span><br><span class="line">	</span><br><span class="line">13.NettyRoutingFilter</span><br><span class="line">	使用 netty 发送 http/wss 等请求.</span><br><span class="line"></span><br><span class="line">14.GatewayFilterFactory</span><br><span class="line">	拦截器实现类的工厂类</span><br><span class="line">	负责创建具体的 GatewayFilter 对象.</span><br><span class="line"></span><br><span class="line">15.AbstractConfigurable</span><br><span class="line">	负责处理谓词的配置和拦截器的配置转化成不同的 Class 配置.</span><br><span class="line">	实际上由 shortcutFieldOrder 属性配合 Binder 实现.</span><br><span class="line">	即按 shortcutFieldOrder 配置的字段列表, 按顺序从 PropertySource 中读取数据进行绑定; 而 PropertySource 则是从 RouteDefinition 的配置信息加入到 Map 后再用 MapConfigurationPropertySource 包装 Map 而得到的.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 除了谓词工厂和拦截器工厂这块的实现复杂, 其他都算比较简单, 哪怕响应式编程的代码到处都是, 也还是可以大致的理解代码的意思.</p>
<p>这两个工厂其实基本是同一套逻辑, 同一套代码, 就是有一个接口名不同, 然后其作用也不同, 但很相似.</p>
</blockquote>
<h2 id="谓语的实现原理-如何判断哪些请求该走哪个道"><a href="#谓语的实现原理-如何判断哪些请求该走哪个道" class="headerlink" title="谓语的实现原理(如何判断哪些请求该走哪个道)?"></a>谓语的实现原理(如何判断哪些请求该走哪个道)?</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Spring gateway 基于 Spring webflux, 因此会执行 DispatcherHandler, 这是一个 WebHandler, 所以会调用 DispatcherHandler.handle(), 这个类通过 HandlerMapping 查找对应的 handler 来执行.</span><br><span class="line">2.在初始化时会从容器中查找 HandlerMapping 类型的 bean, 用于查找 handler; 而 gateway 实现了一个 RoutePredicateHandlerMapping(GatewayAutoConfiguration 中注册进去的); 因此这里是入口!!!</span><br><span class="line">3.再看 RoutePredicateHandlerMapping 的逻辑, 其通过继承抽象类, 因此会在 getHandlerInternal() 中获取 handler. 接着回顾下 Route 对象的获取.</span><br><span class="line">4.其使用 RouteDefinitionRouteLocator 对象来调用 PropertiesRouteDefinitionLocator.getRouteDefinitions() 获取 RouteDefinition 集合对象(这里还有好几个不同的 Locator), 然后在 RouteDefinitionRouteLocator.convertToRoute() 中将 RouteDefinition 转成 Route 对象, 此时会调用 RouteDefinitionRouteLocator.combinePredicates() 将 RouteDefinition 中的 PredicateDefinition 集合信息转成了 AsyncPredicate 对象集合. 这个 AsyncPredicate 是通过解析谓词字符串, 根据谓词名称获取工厂类(PredicateFactory)再调用相应工厂类的方法(apply 方法)生成含相应逻辑判断的 GatewayPredicate 类(判断逻辑在 <span class="built_in">test</span> 方法中); 顺带一提谓词配置信息是 从 apply 的参数中传递过来的.</span><br><span class="line">5.Spring Gateway 默认注入了很多工厂(见 GatewayAutoConfiguration), 如 Host,Path,Method,Query,Cookie 等等.</span><br><span class="line">6.这样 在 RoutePredicateHandlerMapping.lookupRoute() 中的 r.getPredicate().apply(exchange) 就会执行 Route 中的谓词判断, 仅保留匹配的 Route, 然后再剩下的 Route 中取第一个返回. 最后将 Route 对象存到 exchange 中, 然后返回 FilteringWebHandler. </span><br><span class="line">7.这是一个 WebHandler, 会由自带的适配器 SimpleHandlerAdapter 执行, 即调用其 handle 方法.</span><br><span class="line">8.FilteringWebHandler 从 exchange 中取出 Route 对象, 在将 globalFilter 和 gatewayFilter 放到集合中(相当于链)再递归调用所有 Filter; 其中有几个 Filter 会执行请求, 即将请求分发到指定地址. 如 NettyRoutingFilter(见 GatewayAutoConfiguration).</span><br><span class="line">9.到此以将 Spring gateway 接收到的请求根据谓语匹配对应的 Route(路由) 再执行所有的 Filter 后请求 route 配置的地址.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 从 Spring webflux 的入口, 先 getHandler(), 得到的是返回值 FilteringWebHandler, 这个返回值会被 SimpleHandlerAdapter 执行, 但与谓词的逻辑无关; 但 getHandler() 还将配置文件(以及其他地方)获取到的 RouteDefinition 转成 Route 对象, 同时也将 RouteDefinition 中的 PredicateDefinition 转换成了 Predicate, 再将多个 Predicate 组成树结构变成一个 AsyncPredicate; 然后调用 AsyncPredicate 遍历执行每个谓词判断. 有一个返回 false, 则整个结果返回 false (指 and 相连). 如此便完成了根据谓词判断是否匹配 Route!!</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A1(DispatcherHandler)</span><br><span class="line">A2(HandlerMapping#getHandler)</span><br><span class="line">A3(RoutePredicateHandlerMapping#getHandlerInternal)</span><br><span class="line">A4(RouteDefinitionRouteLocator#getRouteDefinitions)</span><br><span class="line">A5(RouteDefinition)</span><br><span class="line">A6(RouteDefinitionRouteLocator#convertToRoute)</span><br><span class="line">A7(Route)</span><br><span class="line">A8(RouteDefinitionRouteLocator#combinePredicates)</span><br><span class="line">A9(PredicateDefinition#谓词配置信息)</span><br><span class="line">A0(AsyncPredicate#可执行的谓词)</span><br><span class="line"></span><br><span class="line">B0(PredicateFactory#apply)</span><br><span class="line">B1(GatewayPredicate#test 谓词判断)</span><br><span class="line">B2(GlobalFilter 含 NettyRoutingFilter)</span><br><span class="line">B3(FilteringWebHandler)</span><br><span class="line">B4(SimpleHandlerAdapter#适配器)</span><br><span class="line">B5(DefaultGatewayFilterChain#拦截器链)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A1--调用--&gt;A2</span><br><span class="line">A2--调用子类--&gt;A3</span><br><span class="line"></span><br><span class="line">A3--后触发所有--&gt;A0</span><br><span class="line">A0--通过--&gt;B1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A4--从配置文件等地方获得--&gt;A5</span><br><span class="line">A5--通过--&gt;A6</span><br><span class="line"></span><br><span class="line">A6--还调用--&gt;A8</span><br><span class="line">A8--将--&gt;A9</span><br><span class="line">A9--通过调用--&gt;B0</span><br><span class="line">B0--得到 Predicate 对象, 再由多个对象组合得到--&gt;A0</span><br><span class="line"></span><br><span class="line">B1--返回匹配的--&gt;A7</span><br><span class="line">A7--将其存到 exchange 对象中, 然后返回--&gt;B3</span><br><span class="line"></span><br><span class="line">B4--负责执行--&gt;B3</span><br><span class="line">B3--从 exchange 对象获取 Route 后再将--&gt;B2</span><br><span class="line">B2--打包封装成一个--&gt;B5</span><br><span class="line"></span><br><span class="line">B5--最终会执行--&gt;G1(NettyRoutingFilter#发起HTTP请求)</span><br><span class="line"></span><br><span class="line">A1--调用--&gt;B4</span><br></pre></td></tr></table></figure>





<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210131004943.png" alt="iShot2021-01-31 00.48.56"></p>
<h2 id="与-LoadBalancer-对接步骤"><a href="#与-LoadBalancer-对接步骤" class="headerlink" title="与 LoadBalancer 对接步骤"></a>与 LoadBalancer 对接步骤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.上面讲到执行所有的 Filter, 那么除了用户配置的 GatewayFilter, Gateway 配置的全局 Filter 也会执行(见 GatewayAutoConfiguration); 而负责处理 lb:// 的 Filter 是 ReactiveLoadBalancerClientFilter (见 GatewayReactiveLoadBalancerClientAutoConfiguration) </span><br><span class="line">2.具体方法为 ReactiveLoadBalancerClientFilter.filter(), 其逻辑是取出 host, 调用 LoadBalancer 的 choose() 获取 ServiceInstance, 然后将 url put 回 exchange 的上下文中存起来即可.</span><br></pre></td></tr></table></figure>



<h2 id="拦截器的执行方式"><a href="#拦截器的执行方式" class="headerlink" title="拦截器的执行方式?"></a>拦截器的执行方式?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截链是肯定的, 所有的 Filter 都可以先执行自己逻辑, 再使用 chain 触发下一个 Filter 直到无拦截器</span></span><br><span class="line"><span class="comment">// 然后开始返回, 因为是顺序进入, 所以是倒叙返回</span></span><br><span class="line"><span class="comment">// 返回后正常是一路不断往回返回, 但你的 Filter 也可以在 调用 chain 的时候不直接返回, 而是先暂存返回值, 再通过 exchange 对象(此时执行了其他 Filter 包括实际请求也执行了, 因此会有响应数据)取出响应数据(或返回值), 进行修改, 再 return 暂存的变量.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultGatewayFilterChain</span> <span class="keyword">implements</span> <span class="title">GatewayFilterChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;GatewayFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">  DefaultGatewayFilterChain(List&lt;GatewayFilter&gt; filters) &#123;</span><br><span class="line">    <span class="keyword">this</span>.filters = filters;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DefaultGatewayFilterChain</span><span class="params">(DefaultGatewayFilterChain parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filters = parent.getFilters();</span><br><span class="line">    <span class="keyword">this</span>.index = index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;GatewayFilter&gt; <span class="title">getFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> filters;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.defer(() -&gt; &#123;</span><br><span class="line">      <span class="comment">// 这里挨个取出, 虽然没有对 filters 进行 pop 操作啥的, 但是下一个执行完后, 会调用 chain.filter</span></span><br><span class="line">      <span class="comment">// 等于在递归进入这个方法, 虽然是不同对象的.. 但因为维护了 parent 和 index 的值</span></span><br><span class="line">      <span class="comment">// 使得 this.index &lt; filters.size() 这个递归终止条件得以正确执行. 因此和递归是类似的.</span></span><br><span class="line">      <span class="comment">// 也就是说, 最后所有 filter 执行完后, 也会不断的回归.</span></span><br><span class="line">      <span class="comment">// 那么, 最后的 Filter 完成请求(比如 http 请求), 得到的 response 会存在 exchange 中</span></span><br><span class="line">      <span class="comment">// 这样回归过程(也就是 chain.filter 方法之后得代码就可以取得数据进行干预)</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.index &lt; filters.size()) &#123;</span><br><span class="line">        GatewayFilter filter = filters.get(<span class="keyword">this</span>.index);</span><br><span class="line">        DefaultGatewayFilterChain chain = <span class="keyword">new</span> DefaultGatewayFilterChain(<span class="keyword">this</span>, <span class="keyword">this</span>.index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> filter.filter(exchange, chain);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.empty(); <span class="comment">// complete</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/30/source-code-spring-cloud-alibaba-sentinel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/source-code-spring-cloud-alibaba-sentinel/" class="post-title-link" itemprop="url">Spring Cloud Alibaba Sentinel 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-30 15:19:26 / 修改时间：17:05:00" itemprop="dateCreated datePublished" datetime="2021-01-30T15:19:26+08:00">2021-01-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index"><span itemprop="name">Spring Cloud</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/30/source-code-spring-cloud-alibaba-sentinel/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/30/source-code-spring-cloud-alibaba-sentinel/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Sentinel-与-Openfeign-整合"><a href="#Sentinel-与-Openfeign-整合" class="headerlink" title="Sentinel 与 Openfeign 整合"></a>Sentinel 与 Openfeign 整合</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.SentinelFeignAutoConfiguration</span><br><span class="line">	注入了 Feign.Builder(即 SentinelFeign.Builder) 到容器中</span><br><span class="line"></span><br><span class="line">2.SentinelFeign.Builder</span><br><span class="line">	重写 build 方法注入 sentinel 的 InvocationHandler(SentinelInvocationHandler)</span><br><span class="line"></span><br><span class="line">3.SentinelInvocationHandler</span><br><span class="line">	拦截方法, 包装方法为一个资源, 进行流控降级等处理</span><br><span class="line">	</span><br><span class="line">4.SentinelAutoConfiguration</span><br><span class="line">	注入了 SentinelResourceAspect 来支持 @SentinelResource 注解</span><br><span class="line">	注入了 SentinelBeanPostProcessor 来处理 @SentinelRestTemplate</span><br><span class="line">	注入了 SentinelDataSourceHandler 来加载各种数据源为规则配置</span><br><span class="line"></span><br><span class="line">5.SentinelResourceAspect</span><br><span class="line">	对加了 @SentinelResource 的方法添加 @Around 通知, 包围原方法已实现流控降级等处理.</span><br><span class="line">	</span><br><span class="line">6.SentinelBeanPostProcessor</span><br><span class="line">	对加了 @SentinelRestTemplate 注解的 RestTemplate bean, 添加一个 SentinelProtectInterceptor</span><br><span class="line"></span><br><span class="line">7.SentinelDataSourceHandler</span><br><span class="line">	解析 spring.cloud.sentinel.datasource 的配置, 加载配置的规则到 Sentinel 中.</span><br><span class="line">	</span><br><span class="line">8.SentinelProtectInterceptor</span><br><span class="line">	包装 RestTemplate 的请求, 使其可被流控降级等操作.</span><br></pre></td></tr></table></figure>





<h3 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Feign 那边的步骤是, 先从容器中获取 Feign.Builder 对象, 并且 FeignContext 也会注入一个默认的 Builder 对象, 但是毕竟是子容器, 优先级没有父容器高(加载配置更后, 所以 @ConditionalOnMissingBean 触发, 子容器就不注册了). 因此我们在父容器中中配置一个 Builder 就能进行对接.</span><br><span class="line">2.Feign 的实现是通过 JDK 生成一个代理对象拦截方法来构造并执行 HTTP 请求, 因此其需要一个 InvocationHandler 来拦截配置; 在 Feign 中, 通过字段 invocationHandlerFactory 来创建这个 InvocationHandler, 所以我们注入自己实现的 Builder 需要设置这个字段.</span><br><span class="line">3.即 SentinelFeign.Builder.build() 中调用 super.invocationHandlerFactory(xxx) 来设置.</span><br><span class="line">4.xxx 是匿名内部类, 直接看 create 方法, 这里根据 @FeignClient 注解的配置(fallback/fallbackFactory) 创建了一个 SentinelInvocationHandler</span><br><span class="line">5.SentinelInvocationHandler.invoke() 的逻辑是使用 SphU.entry() 包围 feign 生成的 method(这个 method 是干正事的: 执行负载均衡和发送 Http 请求), 这就对这个 method 进行流量控制了; 然后还在 catch 中处理 fallback.</span><br><span class="line">6.至此, 与 feign 的对接就完成了</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 新建一个 Builder 令生成的 Feign 对象持有我们指定的 invocationHandlerFactory, 使其创建代理对象时使用我们创建的 SentinelInvocationHandler 拦截对象方法; 这样就把方法的执行包围起来, 进行流量控制和熔断降级(catch 异常调用 fallback)了.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A1(FeignClientsRegistrar)</span><br><span class="line">A2(FeignClientFactoryBean)</span><br><span class="line">A3(真实 XxxService 接口)</span><br><span class="line">A4(SentinelInvocationHandler)</span><br><span class="line">A5(SentinelFeignAutoConfiguration)</span><br><span class="line">A6(Feign.Builder 即 SentinelFeign.Builder)</span><br><span class="line">A7(Feign 对象)</span><br><span class="line">A8(代理对象)</span><br><span class="line">A9( sentinel 将方法当做资源进行拦截)</span><br><span class="line">B1(在 catch 中处理 fallback 熔断逻辑)</span><br><span class="line"></span><br><span class="line">A1--扫描 FeignClient 注解, 注入--&gt;A2</span><br><span class="line"></span><br><span class="line">A3--被 controller 调用, 触发--&gt;A4</span><br><span class="line"></span><br><span class="line">A5--注入了一个--&gt;A6</span><br><span class="line">A2--调用--&gt;A6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A6--的 build 方法创建一个--&gt;A7</span><br><span class="line">A7--调用 newInstance 方法创建了含--&gt;A4</span><br><span class="line">A8--用来代替--&gt;A3</span><br><span class="line">A4--的--&gt;A8</span><br><span class="line"></span><br><span class="line">A4--调用--&gt;A9</span><br><span class="line">A9--然后--&gt;B1</span><br></pre></td></tr></table></figure>





<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210130163421.png" alt="image-20210130163418057"></p>
<h3 id="整合-FeignCircuitBreaker-Builder-步骤"><a href="#整合-FeignCircuitBreaker-Builder-步骤" class="headerlink" title="整合 FeignCircuitBreaker.Builder 步骤"></a>整合 FeignCircuitBreaker.Builder 步骤</h3><blockquote>
<p>即不注入自己的 Builder, 使用 openfeign 提供的 Builder, 通过扩展 CircuitBreakerFactory(即扩展 CircuitBreaker) 来实现流控降级(倒是 fallback 的处理便轻松了不少)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在 SentinelCircuitBreakerAutoConfiguration 注入一个 CircuitBreakerFactory.</span><br><span class="line">2.在 Openfeign 中, 会调用其 create() 创建得到一个 CircuitBreaker (即 SentinelCircuitBreaker)</span><br><span class="line">3.接着会在 FeignCircuitBreakerInvocationHandler.invoke() 中获取这个 CircuitBreaker, 调用其 run() 将要执行的 method 交给 SentinelCircuitBreaker 来处理.</span><br><span class="line">4.SentinelCircuitBreaker 中 run() 的实现就是简单的 SphU.entry() 来包装方法为资源进行流控降级, 至于 fallback 则直接调用 apply 交由 Openfeign 处理.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 不写自己的 Builder, 简单多了! 主要是去掉了 fallback 相关配置的获取与处理.</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/29/source-code-spring-cloud-server-discover-and-register/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/source-code-spring-cloud-server-discover-and-register/" class="post-title-link" itemprop="url">Spring Cloud 服务注册与发现源码笔记 (Nacos/Consul/Eureka)</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 13:21:23" itemprop="dateCreated datePublished" datetime="2021-01-29T13:21:23+08:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-30 00:11:56" itemprop="dateModified" datetime="2021-01-30T00:11:56+08:00">2021-01-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index"><span itemprop="name">Spring Cloud</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/29/source-code-spring-cloud-server-discover-and-register/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/29/source-code-spring-cloud-server-discover-and-register/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Cloud-服务注册与发现源码笔记-Nacos-Consul-Eureka"><a href="#Spring-Cloud-服务注册与发现源码笔记-Nacos-Consul-Eureka" class="headerlink" title="Spring Cloud 服务注册与发现源码笔记 (Nacos/Consul/Eureka)"></a>Spring Cloud 服务注册与发现源码笔记 (Nacos/Consul/Eureka)</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">1.EurekaClientAutoConfiguration</span><br><span class="line">	注册了众多的 bean</span><br><span class="line">	一部分用于和 Eureka Server 交互</span><br><span class="line">	一部分和 Commons 项目对接</span><br><span class="line">	注册了(EurekaClient/EurekaAutoServiceRegistration/ApplicationInfoManager/EurekaRegistration)</span><br><span class="line">	   </span><br><span class="line">2.EurekaClient</span><br><span class="line">	与 Eureka Server 端交互</span><br><span class="line">	负责向 Eureka Server 端注册/注销服务实例</span><br><span class="line">	在构造方法和 shutdown 方法中根据配置处理自动注册和自动注销.</span><br><span class="line"></span><br><span class="line">3.InstanceInfoReplicator</span><br><span class="line">	负责定义一个注册或更新服务实例的任务</span><br><span class="line">	负责管理任务执行器</span><br><span class="line"></span><br><span class="line">4.RestTemplateEurekaHttpClient</span><br><span class="line">	负责根据服务实例信息构造注册/注销的 Http 请求</span><br><span class="line">	使用 RestTemplate 发送请求</span><br><span class="line">	</span><br><span class="line">5.EurekaAutoServiceRegistration</span><br><span class="line">	负责管理服务实例的自动注册/注销, 与容器生命周期挂钩</span><br><span class="line"></span><br><span class="line">6.ApplicationInfoManager</span><br><span class="line">	负责管理服务实例状态变更事件(即管理监听者并在适当时机触发他们)</span><br><span class="line"></span><br><span class="line">7.ApplicationInfoManager.StatusChangeListener</span><br><span class="line">	状态改变事件监听者类</span><br><span class="line">	</span><br><span class="line">8.EurekaHealthCheckHandler</span><br><span class="line">	服务实例状态健康检查类, 注册/注销服务实例前会调用此类进行检查其状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务发现</span></span><br><span class="line">1.BlockingLoadBalancer (Commons 项目上)</span><br><span class="line">	负责调用实际的负载均衡器去选择一个服务实例</span><br><span class="line">	负责调度负载均衡整个过程, 触发相应的生命周期.</span><br><span class="line">	</span><br><span class="line">2.RoundRobinLoadBalancer (Commons 项目上)</span><br><span class="line">	实际的负载均衡策略算法类</span><br><span class="line">	负责连接 ServiceInstanceListSupplier 从其中获取服务实例列表</span><br><span class="line"></span><br><span class="line">3.ServiceInstanceListSupplier</span><br><span class="line">	定义了获取服务实例实例列表的接口(任意方式)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClient</span><br><span class="line">	定义了从服务端获取服务实例列表的接口(更明确了)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClientServiceInstanceListSupplier</span><br><span class="line">	ServiceInstanceListSupplier 的实现类</span><br><span class="line">	连接 ReactiveDiscoveryClient 类, 将服务端获取道德服务实例列表返回出去</span><br><span class="line">	</span><br><span class="line">5.EurekaDiscoveryClient</span><br><span class="line">	实现了 DiscoveryClient 接口</span><br><span class="line">	负责调用 EurekaClient 从 Eureka Server 端获取服务实例列表.</span><br><span class="line"></span><br><span class="line">6.EurekaClient</span><br><span class="line">	与 Eureka Server 端交互</span><br><span class="line">	负责向 Eureka Server 端获取服务实例列表</span><br><span class="line">	在构造方法和 shutdown 方法中根据配置处理自动注册和自动注销.</span><br><span class="line"></span><br><span class="line">7.EurekaServiceInstance</span><br><span class="line">	服务实例信息对象</span><br><span class="line">	实现 ServiceInstance, 与 Commons 对接</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">实现了 Commons 的 DiscoveryClient 接口(即 EurekaDiscoveryClient), 于是服务发现实现了;</span><br><span class="line">实现了 Commons 的 ServiceRegisty 接口(即 EurekaServiceRegistry), 于是服务注册也实现了.</span><br><span class="line">再总结: Commons 大发好.</span><br></pre></td></tr></table></figure>





<h3 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># EurekaClient 构造方法触发(前提 shouldRegisterWithEureka 为 true)</span></span><br><span class="line">1.EurekaClientAutoConfiguration 让容器里注册了一个 EurekaClient</span><br><span class="line">2.EurekaClient 这个类在构造方法中的 initScheduledTasks() 生成了一个 InstanceInfoReplicator 对象</span><br><span class="line">3.然后调用其 instanceInfoReplicator.start(), 逻辑是添加一个定时任务(仅执行一次), 定时任务执行 run()</span><br><span class="line">4.run() 里面会执行 discoveryClient.register() 也就是注册实例信息到 Eureka 上去.</span><br><span class="line">5.register() 里面会调用 RestTemplateEurekaHttpClient<span class="comment">#register() </span></span><br><span class="line">6.这个方法是构造一个 HTTP 请求, 地址为 serviceUrl + <span class="string">"apps/"</span> + info.getAppName(), Method 为 POST, 即 Eureka server 的ip/apps/服务实例名称(如spring.application.name), 当然请求 body 还会带上实例信息 info 对象.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据容器生命周期触发</span></span><br><span class="line">1.EurekaClientAutoConfiguration 让容器里注册了一个 EurekaAutoServiceRegistration.</span><br><span class="line">2.这个类即是 SmartLifecycle(与容器生命周期绑定), 也是 SmartApplicationListener(监听容器加载/关闭事件)</span><br><span class="line">3.因此其对应的 start()/stop() 和 onApplicationEvent() 都实现了对应的逻辑.</span><br><span class="line">4.如 start() 的逻辑为调用 EurekaServiceRegistry<span class="comment">#register()</span></span><br><span class="line">5.register() 先修改本地服务实例的装填, 再通过 com.netflix.discovery.DiscoveryClient<span class="comment">#registerHealthCheck() 来往任务管理器中提交一个任务, 后台执行, 任务 InstanceInfoReplicator#onDemandUpdate()</span></span><br><span class="line">6.此任务就是最终也会调用前面提到的 (4) 中的 run(). 然后就注册上去了.</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS</span></span><br><span class="line">(6) 中的任务, 与状态监听是一致的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 容器注册 EurekaClient, 调用构造方法完成大量初始化工作后, 另起一个线程调用 restTemplate 发送 HTTP 请求将当前服务实例信息发送给 Eureka server. 完成服务注册工作.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A(EurekaClientAutoConfiguration)</span><br><span class="line">A1(EurekaClient)</span><br><span class="line">A2(InstanceInfoReplicator)</span><br><span class="line">A3(EurekaClient#register)</span><br><span class="line">A4(RestTemplateEurekaHttpClient)</span><br><span class="line">A5(RestTemplate)</span><br><span class="line">A6(Eureka Server)</span><br><span class="line">A7(EurekaHttpResponse)</span><br><span class="line"></span><br><span class="line">A--让容器里注册一个--&gt;A1</span><br><span class="line">A1--在构造方法中生成一个--&gt;A2</span><br><span class="line">A2--在 run 方法中调用--&gt;A3</span><br><span class="line">A3--又把服务实例信息交给--&gt;A4</span><br><span class="line">A4--根据服务实例信息构造HTTP请求--&gt;A5</span><br><span class="line">A5--将服务实例信息发送给--&gt;A6</span><br><span class="line">A6--返回一个--&gt;A7</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210129172741.png" alt="image-20210129171345329"></p>
<h3 id="服务注销流程"><a href="#服务注销流程" class="headerlink" title="服务注销流程"></a>服务注销流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器关闭(配置了容器 shouldUnregisterOnShutdown=true)</span></span><br><span class="line">1.在 DiscoveryClient<span class="comment">#shutdown() 中根据 shouldUnregisterOnShutdown 判断是否需要注销</span></span><br><span class="line">2.然后在 unregister() 中调用 RestTemplateEurekaHttpClient<span class="comment">#cancel() </span></span><br><span class="line">3.cancel() 中使用 restTemplate 构造 Method 为 DELETE, URL 为 serviceUrl + <span class="string">"apps/"</span> + appName + <span class="string">'/'</span> + id 的请求并发送给 Eureka server 告知其注销 appName 下对应的服务实例(根据 id).</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收到容器关闭事件</span></span><br><span class="line">1.EurekaClientAutoConfiguration 让容器里注册了一个 EurekaAutoServiceRegistration.</span><br><span class="line">2.这个类即是 SmartLifecycle(与容器生命周期绑定), 也是 SmartApplicationListener(监听容器加载/关闭事件)</span><br><span class="line">3.因此其对应的 start()/stop() 和 onApplicationEvent() 都实现了对应的逻辑.</span><br><span class="line">4.如 stop() 的逻辑为调用 EurekaServiceRegistry<span class="comment">#deregister()</span></span><br><span class="line">5.deregister() 的作用是执行 ApplicationInfoManager<span class="comment">#setInstanceStatus() 将状态改为 DOWN</span></span><br><span class="line">6.因为 ApplicationInfoManager 这个类专门管理状态变化事件, 因此还会将事件发布出去. </span><br><span class="line">7.而在 initScheduledTasks 中就添加了这样的一个监听者, 起作用为调用 InstanceInfoReplicator<span class="comment">#onDemandUpdate()</span></span><br><span class="line">8.接着会调用 InstanceInfoReplicator<span class="comment">#run(), 第一行代码 refreshInstanceInfo() 会确保状态为最新的(那也还是 DOWN)</span></span><br><span class="line">9.但是其最终并不是调用 cancel 注销, 而 register 注册, 不过其中的状态是 DOWN, 因此会有 server 那边判断; 所以容器关闭事件并不会触发 cancel, 但效果应是一样的.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 要么是 shutdown() 中 unregister 调用了 cancel(), 发出了 Method 为 DELETE 的请求来注销; 要么就是 EurekaClientAutoConfiguration 中与容器生命周期做关联, 全程使用 register 接口来更新状态.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A(容器关闭#close)</span><br><span class="line">A1(DiscoveryClient#shutdown)</span><br><span class="line">A2(DiscoveryClient#unregister)</span><br><span class="line">A3(RestTemplateEurekaHttpClient#cancel)</span><br><span class="line">A4(RestTemplate)</span><br><span class="line">A5(Eureka Server) </span><br><span class="line"></span><br><span class="line">A--触发--&gt;A1</span><br><span class="line">A1--调用--&gt;A2</span><br><span class="line">A2--调用--&gt;A3</span><br><span class="line">A3--构造HTTP请求交给--&gt;A4</span><br><span class="line">A4--发送注销申请给--&gt;A5</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210129171241.png" alt="image-20210129171237603"></p>
<h3 id="服务发现流程"><a href="#服务发现流程" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Spring Cloud Commons 中注册了一个 ServiceInstanceListSupplier, 具体为(DiscoveryClientServiceInstanceListSupplier)</span><br><span class="line">2.这个类的作用是借助 ReactiveDiscoveryClient 的 getInstances(String serviceId) 方法向 LoadBalancer 提供从具体的 server(如Eureka) 获取服务实例对象列表, 这样只要实现 ReactiveDiscoveryClient 并放入容器就可以和 Spring cloud LoadBalancer 对接了.</span><br><span class="line">3.在 EurekaDiscoveryClientConfiguration 中让容器注册了一个 DiscoveryClient(具体为 EurekaDiscoveryClient).</span><br><span class="line">4.因为 Spring Cloud Commons 做了大量的预备对接工作, 所以对接其实就结束了.</span><br><span class="line">5.那再简单说下 EurekaDiscoveryClient 的实现, 即注入一个 EurekaClient eurekaClient, 然后调用 DiscoveryClient<span class="comment">#getInstancesByVipAddress() 就获取到了 ServiceInstance 列表.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: Commons 中准备好了对接的方式: 实现 DiscoveryClient 接口, 接着我们的确实现了 DiscoveryClient 接口, 即 EurekaDiscoveryClient, 而这这个类则会调用 EurekaClient 的 getInstancesByVipAddress 从 Eureka Server 端获取注册了的服务实例信息.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A1(BlockingLoadBalancerClient#位于Commons项目)</span><br><span class="line">A2(RoundRobinLoadBalancer#位于Commons项目)</span><br><span class="line">A4(LoadBalancerClientConfiguration#位于Commons项目)</span><br><span class="line">A5(DiscoveryClientServiceInstanceListSupplier)</span><br><span class="line">A6(EurekaDiscoveryClient#getInstances)</span><br><span class="line">A7(EurekaClient#getInstancesByVipAddress)</span><br><span class="line">A9(Eureka Server)</span><br><span class="line">A8(ServiceInstance 集合)</span><br><span class="line"></span><br><span class="line">A1--choose 方法调用--&gt;A2</span><br><span class="line">A2--choose 方法调用--&gt;A5</span><br><span class="line">A4--注入一个--&gt;A5</span><br><span class="line">A5--调用--&gt;A6</span><br><span class="line">A6--调用--&gt;A7</span><br><span class="line">A7--从--&gt;A9</span><br><span class="line">A9--获取--&gt;A8</span><br><span class="line">A10(EurekaDiscoveryClientConfiguration)--注入一个--&gt;A6</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210129233856.png" alt="image-20210129233854498"></p>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><h3 id="关键类-1"><a href="#关键类-1" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">1.ConsulAutoServiceRegistrationAutoConfiguration</span><br><span class="line">	负责添加自动注册/注销相关的 bean</span><br><span class="line">	注册了 ConsulAutoServiceRegistration/ConsulAutoServiceRegistrationListener/ConsulAutoRegistration</span><br><span class="line">	</span><br><span class="line">2.ConsulServiceRegistryAutoConfiguration</span><br><span class="line">	负责注册服务注册相关的 bean</span><br><span class="line">	注册了 ConsulServiceRegistry</span><br><span class="line">	</span><br><span class="line">3.ConsulDiscoveryClientConfiguration</span><br><span class="line">	负责注册服务发现相关的 bean</span><br><span class="line">	注册了 ConsulDiscoveryClient</span><br><span class="line">	</span><br><span class="line">4.ConsulServiceRegistry</span><br><span class="line">	负责与 ConsulClient 对接, 再提供注册/注销功能</span><br><span class="line"></span><br><span class="line">5.ConsulClient</span><br><span class="line">	与 Consul Server 端交互</span><br><span class="line">	负责向 Consul Server 端注册/注销服务实例</span><br><span class="line"></span><br><span class="line">6.AgentConsulClient</span><br><span class="line">	负责根据服务实例信息构造注册/注销的 Http 请求</span><br><span class="line">	</span><br><span class="line">7.ConsulAutoServiceRegistration/ConsulAutoServiceRegistrationListener</span><br><span class="line">	负责管理服务实例的自动注册/注销, 与容器生命周期挂钩</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务发现</span></span><br><span class="line">1.BlockingLoadBalancer (Commons 项目上)</span><br><span class="line">	负责调用实际的负载均衡器去选择一个服务实例</span><br><span class="line">	负责调度负载均衡整个过程, 触发相应的生命周期.</span><br><span class="line">	</span><br><span class="line">2.RoundRobinLoadBalancer (Commons 项目上)</span><br><span class="line">	实际的负载均衡策略算法类</span><br><span class="line">	负责连接 ServiceInstanceListSupplier 从其中获取服务实例列表</span><br><span class="line"></span><br><span class="line">3.ServiceInstanceListSupplier</span><br><span class="line">	定义了获取服务实例实例列表的接口(任意方式)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClient</span><br><span class="line">	定义了从服务端获取服务实例列表的接口(更明确了)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClientServiceInstanceListSupplier</span><br><span class="line">	ServiceInstanceListSupplier 的实现类</span><br><span class="line">	连接 ReactiveDiscoveryClient 类, 将服务端获取道德服务实例列表返回出去</span><br><span class="line">	</span><br><span class="line">5.ConsulDiscoveryClient</span><br><span class="line">	实现了 DiscoveryClient 接口</span><br><span class="line">	负责调用 ConsulClient 从 Consul Server 端获取服务实例列表.</span><br><span class="line"></span><br><span class="line">6.ConsulClient</span><br><span class="line">	与 Consul Server 端交互</span><br><span class="line">	负责向 Consul Server 端获取服务实例列表</span><br><span class="line"></span><br><span class="line">7.ConsulServiceInstance</span><br><span class="line">	服务实例信息对象</span><br><span class="line">	实现 ServiceInstance, 与 Commons 对接</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">实现了 Commons 的 DiscoveryClient 接口(即 ConsulDiscoveryClient), 于是服务发现实现了;</span><br><span class="line">实现了 Commons 的 ServiceRegisty 接口(即 ConsulServiceRegistry), 于是服务注册也实现了.</span><br><span class="line">再总结: Commons 大发好.</span><br></pre></td></tr></table></figure>

<h3 id="服务注册流程-1"><a href="#服务注册流程-1" class="headerlink" title="服务注册流程"></a>服务注册流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.ConsulAutoServiceRegistration 调用 org.springframework.cloud.consul.serviceregistry.ConsulServiceRegistry<span class="comment">#register() 完成注册</span></span><br><span class="line">2.接着 register() 调用 ConsulClient<span class="comment">#agentServiceRegister()</span></span><br><span class="line">3.然后会调用 AgentConsulClient<span class="comment">#agentServiceRegister()</span></span><br><span class="line">4.生成并发送请求, 请求地址为 /v1/agent/service/register</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 其实和 Eureka 差不多, 只是我跳过了一点点细节. 基本是就是 与 ServiceRegistry 交互了, 非常的配合 Commons 项目, 就像一个人写的一样…</p>
</blockquote>
<h3 id="服务发现流程-1"><a href="#服务发现流程-1" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先是 DiscoveryClientServiceInstanceListSupplier 会调用 ConsulDiscoveryClient<span class="comment">#getInstances()</span></span><br><span class="line">2.接着 getInstances() 会调用 ConsulClient<span class="comment">#getHealthServices()</span></span><br><span class="line">3.然后就是发送 HTTP 请求了, 请求地址为 /v1/health/service/, 返回的对象封装处理下得到 ServiceInstance 的实现类 ConsulServiceInstance.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 这次真的是和 Eureka 类似, 从 Commons 到 ConsulDiscoveryClient, 流程是一样的. 而其实 ConsulDiscoveryClient 的逻辑也和 EurekaDiscoverClient 类似… 只能说其实服务注册发现这个框架, 我们关注的功能其实并不是难点. 难点是 server 端的管理.</p>
</blockquote>
<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><h3 id="关键类-2"><a href="#关键类-2" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">1.NacosServiceRegistryAutoConfiguration</span><br><span class="line">	负责添加自动注册/注销相关的 bean</span><br><span class="line">	注册了 NacosAutoServiceRegistration/NacosServiceRegistry/NacosRegistration</span><br><span class="line">	</span><br><span class="line">2.NacosDiscoveryClientConfiguration</span><br><span class="line">	负责注册服务发现相关的 bean</span><br><span class="line">	注册了 NacosDiscoveryClient</span><br><span class="line">	</span><br><span class="line">3.NacosServiceRegistry</span><br><span class="line">	负责与 NamingService 对接, 再提供注册/注销功能</span><br><span class="line"></span><br><span class="line">4.NamingService</span><br><span class="line">	与 Nacos Server 端交互</span><br><span class="line">	负责向 Nacos Server 端注册/注销服务实例</span><br><span class="line">	调用 NamingProxy</span><br><span class="line"></span><br><span class="line">5.NamingProxy</span><br><span class="line">	负责根据服务实例信息构造注册/注销的 Http 请求</span><br><span class="line">	</span><br><span class="line">6.NacosAutoServiceRegistration</span><br><span class="line">	负责管理服务实例的自动注册/注销, 与容器生命周期挂钩</span><br><span class="line"></span><br><span class="line">7.NacosRegistration</span><br><span class="line">	本地实例对象, 相比服务实例数据更多</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务发现</span></span><br><span class="line">1.BlockingLoadBalancer (Commons 项目上)</span><br><span class="line">	负责调用实际的负载均衡器去选择一个服务实例</span><br><span class="line">	负责调度负载均衡整个过程, 触发相应的生命周期.</span><br><span class="line">	</span><br><span class="line">2.RoundRobinLoadBalancer (Commons 项目上)</span><br><span class="line">	实际的负载均衡策略算法类</span><br><span class="line">	负责连接 ServiceInstanceListSupplier 从其中获取服务实例列表</span><br><span class="line"></span><br><span class="line">3.ServiceInstanceListSupplier</span><br><span class="line">	定义了获取服务实例实例列表的接口(任意方式)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClient</span><br><span class="line">	定义了从服务端获取服务实例列表的接口(更明确了)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClientServiceInstanceListSupplier</span><br><span class="line">	ServiceInstanceListSupplier 的实现类</span><br><span class="line">	连接 ReactiveDiscoveryClient 类, 将服务端获取道德服务实例列表返回出去</span><br><span class="line">	</span><br><span class="line">5.NacosDiscoveryClient</span><br><span class="line">	实现了 DiscoveryClient 接口</span><br><span class="line">	负责调用 NamingService 从 Nacos Server 端获取服务实例列表.</span><br><span class="line"></span><br><span class="line">6.NamingService</span><br><span class="line">	与 Nacos Server 端交互</span><br><span class="line">	负责向 Nacos Server 端获取服务实例列表</span><br><span class="line"></span><br><span class="line">7.NacosServiceInstance</span><br><span class="line">	服务实例信息对象</span><br><span class="line">	实现 ServiceInstance, 与 Commons 对接</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">实现了 Commons 的 DiscoveryClient 接口(即 NacosDiscoveryClient), 于是服务发现实现了;</span><br><span class="line">实现了 Commons 的 ServiceRegisty 接口(即 ConsulServiceRegistry), 于是服务注册也实现了.</span><br><span class="line">再总结: Commons 大发好.</span><br></pre></td></tr></table></figure>



<h3 id="服务注册流程-2"><a href="#服务注册流程-2" class="headerlink" title="服务注册流程"></a>服务注册流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.NacosAutoServiceRegistration 调用 NacosServiceRegistry<span class="comment">#register 完成注册</span></span><br><span class="line">2.接着 register() 调用 NacosNamingService<span class="comment">#registerInstance()</span></span><br><span class="line">3.然后会调用 NamingProxy<span class="comment">#registerService()</span></span><br><span class="line">4.生成并发送请求, 请求地址为 /nacos/v1/ns/instance</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 这和 Consul 差不多; 还是继承 AbstractAutoServiceRegistration 来与 ServiceRegistry 交互了, 也是非常的配合 Commons 项目啊!!</p>
</blockquote>
<h3 id="服务发现流程-2"><a href="#服务发现流程-2" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先是 DiscoveryClientServiceInstanceListSupplier 会调用 NacosDiscoveryClient<span class="comment">#getInstances()</span></span><br><span class="line">2.接着 getInstances() 会调用 NacosServiceDiscovery<span class="comment">#getInstances()</span></span><br><span class="line">3.然后就是发送 HTTP 请求了, 请求地址为 /nacos/v1/ns/instance/list, 返回的对象封装处理下得到 ServiceInstance 的实现类 NacosServiceInstance.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 依然是和 Eureka/Consul 类似, 从 Commons 到 NacosDiscoveryClient, 流程是一样的. 而其实 NacosDiscoveryClient 的逻辑也和 ConsulDiscoveryClient/EurekaDiscoverClient 类似, 最终总是发起 HTTP 查询 server 端, 所以 server 端的代码才比较有趣啊.</p>
</blockquote>
<h2 id="Nacos-Config"><a href="#Nacos-Config" class="headerlink" title="Nacos Config"></a>Nacos Config</h2><h3 id="Nacos-Config-Client-加载-nacos-server-配置原理"><a href="#Nacos-Config-Client-加载-nacos-server-配置原理" class="headerlink" title="Nacos Config Client 加载 nacos server 配置原理"></a>Nacos Config Client 加载 nacos server 配置原理</h3><h4 id="关键类-3"><a href="#关键类-3" class="headerlink" title="关键类"></a>关键类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.NacosConfigBootstrapConfiguration</span><br><span class="line">	注册了一个 NacosPropertySourceLocator</span><br><span class="line"></span><br><span class="line">2.NacosPropertySourceLocator</span><br><span class="line">	用于从 nacos server 上加载 dataId 对应的配置文件到 environment 的 PropertySource 集合中.</span><br><span class="line">	</span><br><span class="line">3.ConfigService</span><br><span class="line">	用于与 nacos server 通信, 获取配置文件, 乃至订阅更新</span><br><span class="line">	</span><br><span class="line">4.NacosPropertySourceBuilder</span><br><span class="line">	借助 ConfigService 与 NacosDataParserHandler 从 nacos 获取 NacosPropertySource</span><br><span class="line">	</span><br><span class="line">5.NacosDataParserHandler</span><br><span class="line">	用于序列化(转码)服务端的配置文件数据为一个 PropertySource(即 NacosPropertySource)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动刷新</span></span><br><span class="line">1.NacosConfigAutoConfiguration</span><br><span class="line">2.NacosContextRefresher</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: ConfigService 与 NacosDataParserHandler 是两个干事的, 其他都是渣渣!!!</p>
</blockquote>
<h4 id="从-server-获取配置流程"><a href="#从-server-获取配置流程" class="headerlink" title="从 server 获取配置流程"></a>从 server 获取配置流程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.在 NacosConfigBootstrapConfiguration 中注册了一个 PropertySourceLocator(即 NacosPropertySourceLocator), 可用于为 environment 添加 PropertySource</span><br><span class="line">2.然后实现 locate 方法, 即 NacosPropertySourceLocator<span class="comment">#locate()</span></span><br><span class="line">3.在 locate() 的最后面, 调用了 loadApplicationConfiguration()</span><br><span class="line">4.这个方法通过多次调用 loadNacosDataIfPresent() 加载 dataId 和不同文件后缀以及profile 组和得到不同的 dataId.</span><br><span class="line">5.loadNacosDataIfPresent() 调用了 loadNacosPropertySource()</span><br><span class="line">6.其最终调用了 NacosPropertySourceBuilder<span class="comment">#loadNacosData()</span></span><br><span class="line">7.loadNacosData() 调用 ConfigService<span class="comment">#getConfig() </span></span><br><span class="line">8.getConfig() 会使用 ClientWorker<span class="comment">#getServerConfig() 发起 HTTP 请求从 nacos server 获取配置文件. 其请求地址是 /v1/cs/configs</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 还是挺简单的, 发个 HTTP 获取配置文件, 然后转化成一个 PropertySource, 再在 NacosPropertySourceLocator 的 locate 中扔进 environment 中去. Bingo!!!</p>
</blockquote>
<h4 id="从-server-实时更新原理"><a href="#从-server-实时更新原理" class="headerlink" title="从 server 实时更新原理"></a>从 server 实时更新原理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.在 NacosConfigAutoConfiguration 注册了一个 NacosContextRefresher</span><br><span class="line">2.其实现了 ApplicationListener&lt;ApplicationReadyEvent&gt;, 也就是会在容器准备事件触发后调用 NacosContextRefresher<span class="comment">#registerNacosListenersForApplications()</span></span><br><span class="line">3.在进行两个配置判断后(即 isRefreshEnabled() 和 PropertySource 的 isRefreshable), 调用 NacosContextRefresher<span class="comment">#registerNacosListener() </span></span><br><span class="line">4.这个方法通过 NacosConfigService<span class="comment">#addListener() 注册一个 AbstractSharedListener 监听者到 cacheData.</span></span><br><span class="line">5.而 ClientWorker<span class="comment">#checkConfigInfo() 中添加的 LongPollingRunnable 任务, 会在 run() 中执行 getServerConfig() 获取服务配置文件, 然后与当前缓存对比 md5, 若更新则通过 cacheData 取出刚刚添加的 listener, 触发事件(即 receiveConfigInfo() )</span></span><br><span class="line">6.触发后又会再发布一个 RefreshEvent 事件</span><br><span class="line">7.接着流转到 RefreshEventListener.onApplicationEvent()</span><br><span class="line">8.然后又会调用 ContextRefresher.refresh(), 这个方法中的 refreshEnvironment() 会调用 addConfigFilesToEnvironment(), 这方法先复制一个 StandardEnvironment, 将其放入到 SpringApplication 中, 再调用 SpringApplication 的 run() 走一遍, 会触发 NacosPropertySourceLocator.locate(), 于是复制的 environment 里面有新数据了, 再将其拷贝替换到当前的 environment. 完成 environment 的刷新. </span><br><span class="line">9.接着发布一个 EnvironmentChangeEvent 事件, 用来刷新 @ConfigurationProperties 注解的 Bean. (这么喜欢事件?不愧是写出 RocketMQ 的阿里啊!!!)</span><br><span class="line">10.接着在 ConfigurationPropertiesRebinder 中接收到这个事件, 触发 onApplicationEvent()</span><br><span class="line">11.然后会执行 ConfigurationPropertiesRebinder<span class="comment">#rebind()</span></span><br><span class="line">12.其逻辑是将 postProcessBeforeInitialization 中存起来的 ConfigurationPropertiesBean 类型的 map 遍历, 进行重新绑定(即 destroyBean 后再 initializeBean, 则会从新配置重新赋值).</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 有的地方(NacosContextRefresher)监听容器初始化添加配置更新的监听者, 自己不干活只发布配置刷新事件;</p>
<p>有的地方(ClientWorker)添加轮询任务获取服务端配置文件与本地 cacheData 对比 md5 来判断是否触发配置更新的监听者;</p>
<p>然后有的地方(RefreshEventListener)监听配置刷新事件然后用 SpringApplication.run() 通过触发 NacosPropertySourceLocator#locate() 为一个复制出来的 environment 对象添加从服务端获取最新配置, 再拷贝到当前的 environment 对象, 完成 environment 配置的刷新, 之后发布 environment 刷新事件;</p>
<p>有的地方(ConfigurationPropertiesRebinder)监听 environment 刷新事件, 然后为 @ConfigurationProperties 注解生成的 bean 重新绑定配置.</p>
<p>再总结: 挺好的, 奥运火炬手啊这是, 不停传递!!!!!</p>
</blockquote>
<h4 id="关键类-4"><a href="#关键类-4" class="headerlink" title="关键类"></a>关键类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.NacosConfigAutoConfiguration</span><br><span class="line">	注册一个监听容器初始化事件的 bean (NacosContextRefresher)</span><br><span class="line"></span><br><span class="line">2.NacosContextRefresher</span><br><span class="line">	再初始化事件触发后添加一个 AbstractSharedListener 监听者到 cacheData</span><br><span class="line"></span><br><span class="line">3.AbstractSharedListener</span><br><span class="line">	当服务端配置与本地不同后触发</span><br><span class="line">	触发后发布 RefreshEvent 事件</span><br><span class="line"></span><br><span class="line">4.CacheData</span><br><span class="line">	管理配置更新事件监听者</span><br><span class="line">	对比服务端配置与本地配置的 md5</span><br><span class="line">	md5 不同则触发 AbstractSharedListener</span><br><span class="line">	</span><br><span class="line">5.RefreshEvent</span><br><span class="line">	通过容器发布</span><br><span class="line">	当服务端配置发送更新触发</span><br><span class="line">	触发后调用 ContextRefresher<span class="comment">#refresh()</span></span><br><span class="line">	</span><br><span class="line">6.LongPollingRunnable</span><br><span class="line">	轮询任务, 获取服务端最新配置, 与 cacheData 对比</span><br><span class="line"></span><br><span class="line">7.ClientWorker</span><br><span class="line">	管理轮询任务(LongPollingRunnable)</span><br><span class="line">	负责与 nacos 服务端通信</span><br><span class="line">	</span><br><span class="line">8.ContextRefresher</span><br><span class="line">	监听 RefreshEvent 事件</span><br><span class="line">	负责获取服务端最新配置到 environment 对象中</span><br><span class="line">	发布 EnvironmentChangeEvent 事件</span><br><span class="line">	</span><br><span class="line">9.EnvironmentChangeEvent</span><br><span class="line">	通过容器发布</span><br><span class="line">	当 environment 对象更新后触发</span><br><span class="line">	触发后调用 ConfigurationPropertiesRebinder<span class="comment">#rebind()</span></span><br><span class="line">	</span><br><span class="line">10.ConfigurationPropertiesRebinder</span><br><span class="line">	监听 EnvironmentChangeEvent 事件</span><br><span class="line">	负责重新绑定用了 @ConfigurationProperties 注解的 Bean 的值</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A1(NacosConfigAutoConfiguration)</span><br><span class="line">A2(NacosContextRefresher)</span><br><span class="line">A3(ApplicationReadyEvent)</span><br><span class="line">A4(NacosContextRefresher#registerNacosListener)</span><br><span class="line">A5(NacosConfigService#addListener)</span><br><span class="line"> </span><br><span class="line">A7(ClientWorker)</span><br><span class="line">A8(LongPollingRunnable#轮询任务)</span><br><span class="line">A9(NacosConfigService#getServerConfig)</span><br><span class="line">B1(AbstractSharedListener#配置更新事件的监听者)</span><br><span class="line">B2(cacheData)</span><br><span class="line">B3(RefreshEvent)</span><br><span class="line">B4(RefreshEventListener)</span><br><span class="line">B5(ContextRefresher#refresh)</span><br><span class="line">B6(ContextRefresher#refreshEnvironment)</span><br><span class="line">B7(ContextRefresher#addConfigFilesToEnvironment)</span><br><span class="line">B8(SpringApplication#run)</span><br><span class="line">B9(StandardEnvironment)</span><br><span class="line">C1(NacosPropertySourceLocator#locate)</span><br><span class="line">C2(当前容器的 environment 对象)</span><br><span class="line">C3(EnvironmentChangeEvent)</span><br><span class="line">C4(ConfigurationPropertiesRebinder#onApplicationEvent)</span><br><span class="line">C5(ConfigurationPropertiesRebinder#rebind)</span><br><span class="line">C6(用了 ConfigurationProperties 注解 Bean)</span><br><span class="line"></span><br><span class="line">A1--注册了一个--&gt;A2</span><br><span class="line">A2--监听了--&gt;A3</span><br><span class="line">A3--事件触发后调用--&gt;A4</span><br><span class="line">A4--通过--&gt;A5</span><br><span class="line">A5--注册了一个--&gt;B1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">A7--构造方法中创建了一个--&gt;A8</span><br><span class="line">A8--run 方法中调用--&gt;A9</span><br><span class="line">A9--获取最新配置与--&gt;B2</span><br><span class="line"></span><br><span class="line">B2--比较 md5, 不同则触发--&gt;B1</span><br><span class="line">B1--事件触发后发布--&gt;B3</span><br><span class="line">B4--监听了--&gt;B3</span><br><span class="line">B3--事件触发后调用--&gt;B5</span><br><span class="line">B5--调用--&gt;B6</span><br><span class="line">B6--调用--&gt;B7</span><br><span class="line">B7--利用--&gt;B8</span><br><span class="line">B7--复制当前容器 environment 对象到--&gt;B9</span><br><span class="line">B8--触发--&gt;C1</span><br><span class="line">C1--获取了最新配置到--&gt;B9</span><br><span class="line">B9--复制最新配置回到--&gt;C2</span><br><span class="line"></span><br><span class="line">C2--更新完配置后发布--&gt;C3</span><br><span class="line">G1(ConfigurationPropertiesRebinder)--监听了--&gt;C3</span><br><span class="line">C3--事件触发后调用--&gt;C4</span><br><span class="line">C4--调用--&gt;C5</span><br><span class="line">C5--获取新配置绑定到--&gt;C6</span><br></pre></td></tr></table></figure>





<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210130001118.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/28/source-code-spring-cloud-openfeign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/28/source-code-spring-cloud-openfeign/" class="post-title-link" itemprop="url">Spring Cloud Openfeign 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-28 13:59:51" itemprop="dateCreated datePublished" datetime="2021-01-28T13:59:51+08:00">2021-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-30 00:14:53" itemprop="dateModified" datetime="2021-01-30T00:14:53+08:00">2021-01-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud-Openfeign/" itemprop="url" rel="index"><span itemprop="name">Spring Cloud Openfeign</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/28/source-code-spring-cloud-openfeign/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/28/source-code-spring-cloud-openfeign/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Cloud-Openfeign-源码笔记"><a href="#Spring-Cloud-Openfeign-源码笔记" class="headerlink" title="Spring Cloud Openfeign 源码笔记"></a>Spring Cloud Openfeign 源码笔记</h1><h2 id="关键类分析"><a href="#关键类分析" class="headerlink" title="关键类分析"></a>关键类分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.FeignAutoConfiguration</span></span><br><span class="line">  配置了一个管理 feign 子容器的工厂(FeignContext). </span><br><span class="line">  配置一个 Targeter, 直接中专 fegin 的 target 方法(DefaultTargeter, 这里扩展可以实现降级哦)</span><br><span class="line">  配置了一个 feign client (ApacheHttpClient), 用于执行 HTTP 请求</span><br><span class="line">  还配备了 ok http client 方式的 feign client, 但默认不启用</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.FeignClientsRegistrar</span></span><br><span class="line">  被 @EnableFeignClients 引入</span><br><span class="line">  扫描带 @FeignClient 注解的接口, 生成代理对象(FeignClientFactoryBean)注册到容器中</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.FeignClientFactoryBean</span></span><br><span class="line">  继承自 FactoryBean, Spring 的东西, getBean() 时调用跳转到 getObject()</span><br><span class="line">  getObject() 会调用通过 feign 对象生成代理对象</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.FeignInvocationHandler</span></span><br><span class="line">	JDK 动态代理生成对象的的方法拦截器</span><br><span class="line">	通过调用 SynchronousMethodHandler 的 invoke() 实现发送请求的功能</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.SynchronousMethodHandler</span></span><br><span class="line">	invoke() 会调用 FeignBlockingLoadBalancerClient 的 execute() 通过负载均衡获取 url 再调用 ApacheHttpClient 的 execute() 发送带实际 url 的 HTTP 请求.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.ParseHandlersByName</span></span><br><span class="line">	具有核心方法 apply, 解析 @FeignClient 接口的所有方法的注解和参数信息, 转化为 RequestTemplate, 可用于构造 HTTP 请求对象. 转化后的信息存于 SynchronousMethodHandler 字段中.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.FeignBlockingLoadBalancerClient</span></span><br><span class="line">	execute() 会调用 LoadBalancerClient 的 choose() 根据 serviceId(即 HTTP 的 host) 获取 url.</span><br><span class="line">	还负责调用 ApacheHttpClient 的 execute() 真正的发送 HTTP 请求.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.LoadBalancerClient</span></span><br><span class="line">  commons 下 loadbalancer 项目的老伙计了... 干啥的来着? 忘了</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.ApacheHttpClient</span></span><br><span class="line">	负责发送 HTTP 请求.</span><br></pre></td></tr></table></figure>



<h2 id="openfeign-原理-EnableFeignClients-生效步骤"><a href="#openfeign-原理-EnableFeignClients-生效步骤" class="headerlink" title="openfeign 原理(@EnableFeignClients 生效步骤)"></a>openfeign 原理(@EnableFeignClients 生效步骤)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.先解析 @EnableFeignClients 导入 FeignClientsRegistrar.class</span><br><span class="line">2.FeignClientsRegistrar 将扫描带 @FeignClient 注解的接口, 注册到容器中</span><br><span class="line">3.注册进容器的是一个 FeignClientFactoryBean</span><br><span class="line">4.FeignClientFactoryBean 其本质是一个 FactoryBean, 会在被 getBean() 时调用 getObject()</span><br><span class="line">5.getObject() 会从容器中取 Feign.Builder builder 对象再根据配置文件进行配置 </span><br><span class="line">6.接着会走 Targeter 对象(默认为 DefaultTargeter)的 target(), 其默认为 builder.target(target); 其中 builder 为 Feign.Builder 对象, target 为 <span class="built_in">type</span>(class), name(serviceId), url(http://name/path)</span><br><span class="line">7.target() 会先调用 build()生成一个 feign 对象, 再调用 feign.newInstance(target) 生成一个代理对象</span><br><span class="line">8.先看 build() 方法, 初始化了重要属性 targetToHandlersByName, 值为 new ParseHandlersByName(), 这个类的 apply() 会在过一会用到. apply() 逻辑是遍历挨个解析方法上的注解(如@RequestMapping, @RequestParam, @PathVariable等等)和参数, 转化后包装成 HTTP 请求相关的实体类, 存到 SynchronousMethodHandler 的字段中, 再返回 SynchronousMethodHandler 对象存到 map 里.</span><br><span class="line">9.再看 feign.newInstance(), 先调用刚说的重要属性 targetToHandlersByName.apply(), 获得一个 map, 里面键大致为类名+方法名+形参组成, 值是 SynchronousMethodHandler 对象(见 SynchronousMethodHandler.Factory.create()), 然后遍历代理类的所有方法, 将方法所对应的 SynchronousMethodHandler 从 map 中取出再存到另一个 map, 这个 map 的键则为 method; 接着使用 JDK 动态代理生成一个代理对象, 其用于拦截方法的类 InvocationHandler 具体为 FeignInvocationHandler, 这个类里面的 invoke 逻辑很简单, 先排除 Object 通用的方法的影响, 对于正常方法会调用 SynchronousMethodHandler 的 invoke()... 闹了半天就是个中转呗, 有类的 Handler 到了方法的 MethodHandler.</span><br><span class="line">10.SynchronousMethodHandler 的 invoke() 的核心代码是 this.client.execute(), 这里会走到 feign.Client 的具体实现类. 可能是 ApacheHttpClient(当 url 有地址时), 那就直接执行请求了, 也可能是 FeignBlockingLoadBalancerClient, 那么会调用 loadBalancerClient 的 choose 方法获取 url, 再执行 feignClient.execute(), 这次这个 feignClient 则肯定是 ApacheHttpClient 了, 于是最终就这样发送了请求.</span><br><span class="line"></span><br><span class="line"><span class="comment">#PS: </span></span><br><span class="line">有人问我(无中生友)发送的 HTTP 请求怎么构建? </span><br><span class="line">其实我上面说的很清楚了, 关键就在于 apply(), 好吧, 我说的具体一点... 关键在于 SpringMvcContract<span class="comment">#parseAndValidateMetadata()</span></span><br><span class="line">这个的入口在 apply() 的第一行, this.contract.parseAndValidateMetadata() 一直往里跳转, 就会进入 SpringMvcContract...  具体代码挺多的... 真的没必要细读... 因为其本身只相当于一个工具类, 而读源码应该放眼大局, 否则每段代码都认真读, 那太难了!!!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 扫描 @FeignClient, 生成代理对象, 扔进容器. 拦截代理对象的方法, 调用方法对应的 SynchronousMethodHandler, 此类调用之前解析好的 RequestTemplate 生成请求对象, 再通过 Client 执行请求, 若配置了负载均衡, 则会调用 LoadBalancerClient 将 serviceId 先解析成具体的地址再转交给 ApacheHttpClient 执行请求.</p>
</blockquote>
<h2 id="代理对象的生成步骤"><a href="#代理对象的生成步骤" class="headerlink" title="代理对象的生成步骤"></a>代理对象的生成步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A1(FeignClientFactoryBean)</span><br><span class="line">A2(Feign.Builder)</span><br><span class="line">A3(Feign)</span><br><span class="line">A4(FeignInvocationHandler)</span><br><span class="line">A5(SynchronousMethodHandler)</span><br><span class="line">A6(FeignBlockingLoadBalancerClient)</span><br><span class="line">A7(ApacheHttpClient)</span><br><span class="line">A8(LoadBalancerClient)</span><br><span class="line">A9(ServiceInstance)</span><br><span class="line">A10(Response)</span><br><span class="line">A11(Decoder 链)</span><br><span class="line"></span><br><span class="line">A1--getObject 触发--&gt;A2</span><br><span class="line">A2--build 得到--&gt;A3</span><br><span class="line">A3--Proxy.newProxyInstance 用到--&gt;A4</span><br><span class="line">A4--invoke 里调用--&gt;A5</span><br><span class="line">A5--invoke 里调用--&gt;A6</span><br><span class="line">A6--execute 中先调用 --&gt;A8</span><br><span class="line">A6--execute 中后调用--&gt;A7</span><br><span class="line">A8--获取--&gt;A9</span><br><span class="line">A7--得到--&gt;A10</span><br><span class="line">A10--交给--&gt;A11</span><br><span class="line">A11--编码得到--&gt;A12(json)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210128204558.png" alt="iShot2021-01-28 20.45.21"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/27/source-code-spring-cloud-ribbon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/27/source-code-spring-cloud-ribbon/" class="post-title-link" itemprop="url">Spring Cloud Commons 之 loadbalancer 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-27 13:10:01 / 修改时间：21:22:50" itemprop="dateCreated datePublished" datetime="2021-01-27T13:10:01+08:00">2021-01-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Cloud/" itemprop="url" rel="index"><span itemprop="name">Spring-Cloud</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/27/source-code-spring-cloud-ribbon/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/27/source-code-spring-cloud-ribbon/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Cloud-Commons-之-loadbalancer-源码笔记"><a href="#Spring-Cloud-Commons-之-loadbalancer-源码笔记" class="headerlink" title="Spring Cloud Commons 之 loadbalancer 源码笔记"></a>Spring Cloud Commons 之 loadbalancer 源码笔记</h1><blockquote>
<p>Spring Cloud Commons 是什么样的? 有什么作用? 如何与 Spring Cloud 和 Cloud Alibaba 整合?<br>让我们带着这些问题去研究源码吧! </p>
</blockquote>
<h2 id="loadbalancer-原理分析"><a href="#loadbalancer-原理分析" class="headerlink" title="loadbalancer 原理分析"></a>loadbalancer 原理分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先来认识一下 Spring Cloud Commons 吧</span></span><br><span class="line">是定义了诸多接口(如ServiceRegistry/DiscoveryClient/LoadBalancerClient)和注解(如!EnableDiscoveryClient/@LoadBalanced)为主, 少量代码实现(如 RandomLoadBalancer). </span><br><span class="line">以及对 Spring 容器(Context) 的扩展(如 NamedContextFactory, bootstrap 配置文件的加载, 容器重启, 容器跟随配置文件刷新等等)</span><br><span class="line">当然还有一些打包好的 starter.</span><br><span class="line">我们要研究的 loadbalancer 就是其中一个子项目.</span><br></pre></td></tr></table></figure>



<h3 id="loadbalancer-关键类解析"><a href="#loadbalancer-关键类解析" class="headerlink" title="loadbalancer 关键类解析"></a>loadbalancer 关键类解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0.惊! 一堆类仅为添加一个拦截器</span></span><br><span class="line">LoadBalancerRequestFactory: 一个工厂, 包装一个为请求对象 HttpRequest 加料的回调 LoadBalancerRequest</span><br><span class="line"></span><br><span class="line">LoadBalancerClient: 用于根据 serviceId 选取一个 ServiceInstance, 执行从 LoadBalancerRequestFactory 获得的那个回调</span><br><span class="line"></span><br><span class="line">LoadBalancerInterceptor: restTemplate 的拦截器, 拦截后调用 LoadBalancerClient 修改 HttpRequest 对象(主要是 url), 且传入调用 LoadBalancerRequestFactory 生成的回调给 LoadBalancerClient</span><br><span class="line"></span><br><span class="line">RestTemplateCustomizer: 为 restTemplate 加上一个拦截器(也可以干点别的, 默认就这一个用处)</span><br><span class="line"></span><br><span class="line">SmartInitializingSingleton: 调用 RestTemplateCustomizer 为容器中所有加了 @LoadBalanced 的 RestTemplate 加上一个拦截器</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.获取对象的工厂, 以 Spring 容器作为载体管理对象.</span></span><br><span class="line">NamedContextFactory</span><br><span class="line">	继承 DisposableBean, 用于类销毁是执行点东西(指创建的好多个子容器)</span><br><span class="line">	继承 ApplicationContextAware, 用于将子容器和当前容器关联起来(所以 Spring 树形扩展这个设计真不错)</span><br><span class="line">	泛型 C extends NamedContextFactory.Specification, 无它, 就是个 POJO, 存个 name 和对应的配置 class, 用于初始化容器的(会被注册进去, 然后解析里面的注解啥的...)</span><br><span class="line">	此类作用就是管理一大堆(取决于你微服务拆分的程度)子容器, 获取其他代码需要的类型对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReactiveLoadBalancer.Factory</span><br><span class="line">  定义了获取 ReactiveLoadBalancer 的接口以及与其相关的扩展</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">LoadBalancerClientFactory</span><br><span class="line">  继承 NamedContextFactory, 构造参数指定了几个属性值</span><br><span class="line">  实现了 ReactiveLoadBalancer.Factory 的接口, 即提供获取 ReactiveLoadBalancer 的方法.</span><br><span class="line">  泛型具体为 LoadBalancerClientSpecification, 还是个POJO</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.包含算法逻辑的负载均衡策略的类</span></span><br><span class="line">Response</span><br><span class="line">	server 的封装类, 一般持有一个 ServiceInstance 对象, 如 DefaultResponse</span><br><span class="line">	</span><br><span class="line">Publisher</span><br><span class="line">	响应式编程的东西, 可获取 Response&lt;T&gt; 对象, 一般为 Response&lt;ServiceInstance&gt;</span><br><span class="line">	</span><br><span class="line">ReactiveLoadBalancer.Factory</span><br><span class="line">	定义了获取 ReactiveLoadBalancer 的接口以及与其相关的扩展</span><br><span class="line"></span><br><span class="line">ReactiveLoadBalancer</span><br><span class="line">	定义了 choose 方法, 即如何选取一个 ServiceInstance, 如轮播, 随机...</span><br><span class="line"></span><br><span class="line">ReactorLoadBalancer</span><br><span class="line">  定义了 choose 方法的另一形式, 仅返回值不同, 为 Mono&lt;Response&lt;T&gt;&gt; 是 Publisher&lt;Response&lt;T&gt;&gt; 的子类, 返回值为抽象类.</span><br><span class="line"></span><br><span class="line">ReactorServiceInstanceLoadBalancer</span><br><span class="line">  继承 ReactorLoadBalancer</span><br><span class="line">	仅仅作为一个标记类, 无新接口</span><br></pre></td></tr></table></figure>



<h3 id="类大致调用图"><a href="#类大致调用图" class="headerlink" title="类大致调用图"></a>类大致调用图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A(SmartInitializingSingleton)</span><br><span class="line">A1(RestTemplateCustomizer)</span><br><span class="line">A2(LoadBalancerInterceptor)</span><br><span class="line">A3(restTemplate)</span><br><span class="line">A4(LoadBalancerClient)</span><br><span class="line">A5(LoadBalancerRequestFactory)</span><br><span class="line">A6(ReactorServiceInstanceLoadBalancer)</span><br><span class="line">A8(LoadBalancerClientFactory)</span><br><span class="line"></span><br><span class="line">A--调用--&gt;A1</span><br><span class="line">A1--添加一个--&gt;A2</span><br><span class="line">A2--到--&gt;A3</span><br><span class="line">A2--调用--&gt;A4</span><br><span class="line">A2--调用--&gt;A5</span><br><span class="line">A5--生成一个回调给--&gt;A4 </span><br><span class="line">A4--调用--&gt;A8</span><br><span class="line">A8--获取--&gt;A6</span><br><span class="line">A6--获取--&gt;A7(ServiceInstance)</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210127212226.png" alt="a copy"></p>
<blockquote>
<p>瞅瞅有哪些负载均衡策略吧(看完发现这才是最简单的… 外面那些结构反而不容易理清)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.RandomLoadBalancer: 就是随机数呗, 0-size, 简单!!</span></span><br><span class="line"><span class="comment">// 在 RandomLoadBalancer#getInstanceResponse() 中</span></span><br><span class="line"><span class="comment">// 觉得这个方法可以做出 protected, 这样有些实现只需要重写这个方法就行了 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Response&lt;ServiceInstance&gt; <span class="title">getInstanceResponse</span><span class="params">(List&lt;ServiceInstance&gt; instances)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">      log.warn(<span class="string">"No servers available for service: "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmptyResponse();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> index = ThreadLocalRandom.current().nextInt(instances.size());</span><br><span class="line"></span><br><span class="line">  ServiceInstance instance = instances.get(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultResponse(instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.RoundRobinLoadBalancer</span></span><br><span class="line"><span class="comment">// 在 RoundRobinLoadBalancer#getInstanceResponse() 中</span></span><br><span class="line"><span class="comment">// 用一个 position 保存位置, 这个主意高啊, 即保证了数据的正确性, 还.... 编不下去了!!</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Response&lt;ServiceInstance&gt; <span class="title">getInstanceResponse</span><span class="params">(List&lt;ServiceInstance&gt; instances)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">      log.warn(<span class="string">"No servers available for service: "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmptyResponse();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> enforce order?</span></span><br><span class="line">  <span class="keyword">int</span> pos = Math.abs(<span class="keyword">this</span>.position.incrementAndGet());</span><br><span class="line"></span><br><span class="line">  ServiceInstance instance = instances.get(pos % instances.size());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultResponse(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这代码简单的, 特别不想分析…. 但其实最开始就是冲着这个来的… 总得看看吧, 咳咳!!</p>
</blockquote>
<h3 id="loadbalancer-原理分析-1"><a href="#loadbalancer-原理分析-1" class="headerlink" title="loadbalancer 原理分析"></a>loadbalancer 原理分析</h3><ol>
<li>先拦截 RestTemplate 对象的请求, 使其调用 LoadBalancerClient 的接口获取真实IP</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration 中</span></span><br><span class="line">1.@Bean 加入一个 LoadBalancerRequestFactory, 并且带有用户自定义的 transformers(作用: 对选取真实 url 后的请求对象进行干预)</span><br><span class="line">2.@Bean 加入一个 LoadBalancerClient, 其作用是, 根据 serviceId 获取/选取真实 url, 以及执行请求</span><br><span class="line">3.@Bean 加入一个 LoadBalancerInterceptor, 即核心拦截器. 逻辑是: 获取 host, 调用 LoadBalancerRequestFactory 生成请求, 用 LoadBalancerClient 执行.</span><br><span class="line">4.@Bean 加入一个 RestTemplateCustomizer, 其作用是: 为给定的 RestTemplate 添加一个 LoadBalancerInterceptor.</span><br><span class="line">5.@Bean 加入一个 SmartInitializingSingleton, 作用是单例都加载后触发回调, 回调代码为:</span><br><span class="line">     遍历所有的 RestTemplateCustomizer 和 restTemplates, 用 RestTemplateCustomizer 对 RestTemplate 做设置. 包括(4)刚刚加入的那个.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 为用户自定义(如配置类中写了个@Bean + return new RestTemplate() 这种形式)的 RestTemplate 添加一个拦截器, 在请求执行前进行拦截, 然后将请求数据的 host 作为 serviceId, 接着使用某个具体的 LoadBalancerClient 实现类调用其方法获取真实的 url. 若对应存在多个 url, 由其算法策略决定如何选择.</p>
</blockquote>
<ol start="2">
<li>再看 LoadBalancerClient 的默认实现类(在 BlockingLoadBalancerClientAutoConfiguration 中配置的), 其逻辑是, 通过工厂获取 ReactorServiceInstanceLoadBalancer 对象并调用其接口执行负载均衡算法.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.loadbalancer.blocking.client.BlockingLoadBalancerClient</span></span><br><span class="line"><span class="comment">// 先进入这个方法, 然后会调用第二个方法.</span></span><br><span class="line"><span class="comment">// 这两个方法其实就是从工厂获取对象执行 choose 后再让其完成请求的执行, 大部分代码都是 LoadBalancerLifecycle 的触发.</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历 LoadBalancerLifecycle 触发 onStart 钩子</span></span><br><span class="line">  <span class="comment">// 调用 choose 方法选取一个 IP:PORT 得到包装类 ServiceInstance</span></span><br><span class="line">  <span class="comment">// 遍历 LoadBalancerLifecycle 触发 onComplete 钩子</span></span><br><span class="line">  <span class="comment">// 执行请求</span></span><br><span class="line">  String hint = getHint(serviceId);</span><br><span class="line">  LoadBalancerRequestAdapter&lt;T, DefaultRequestContext&gt; lbRequest = <span class="keyword">new</span> LoadBalancerRequestAdapter&lt;&gt;(request,</span><br><span class="line">                                                                                                    <span class="keyword">new</span> DefaultRequestContext(request, hint));</span><br><span class="line">  Set&lt;LoadBalancerLifecycle&gt; supportedLifecycleProcessors = LoadBalancerLifecycleValidator</span><br><span class="line">    .getSupportedLifecycleProcessors(</span><br><span class="line">    loadBalancerClientFactory.getInstances(serviceId, LoadBalancerLifecycle<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">DefaultRequestContext</span>.<span class="title">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">ServiceInstance</span>.<span class="title">class</span>)</span>;</span><br><span class="line">  supportedLifecycleProcessors.forEach(lifecycle -&gt; lifecycle.onStart(lbRequest));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 serviceId 对应的容器中获取一个负载均衡算法实现类对象, 即 ReactorServiceInstanceLoadBalancer.</span></span><br><span class="line">  <span class="comment">// 调用其 choose 方法. 从响应中获取 ServiceInstance 并返回.</span></span><br><span class="line">  ServiceInstance serviceInstance = choose(serviceId, lbRequest);</span><br><span class="line">  <span class="keyword">if</span> (serviceInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    supportedLifecycleProcessors.forEach(lifecycle -&gt; lifecycle.onComplete(</span><br><span class="line">      <span class="keyword">new</span> CompletionContext&lt;&gt;(CompletionContext.Status.DISCARD, lbRequest, <span class="keyword">new</span> EmptyResponse())));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可以执行了</span></span><br><span class="line">  <span class="keyword">return</span> execute(serviceId, serviceInstance, lbRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历 LoadBalancerLifecycle 触发 onStartRequest 钩子</span></span><br><span class="line">  <span class="comment">// 调用 request.apply 方法执行请求(即进入之前 LoadBalancerRequestFactory 中的代码)</span></span><br><span class="line">  <span class="comment">// 遍历 LoadBalancerLifecycle 触发 onComplete 钩子</span></span><br><span class="line"></span><br><span class="line">  DefaultResponse defaultResponse = <span class="keyword">new</span> DefaultResponse(serviceInstance);</span><br><span class="line">  Set&lt;LoadBalancerLifecycle&gt; supportedLifecycleProcessors = LoadBalancerLifecycleValidator</span><br><span class="line">    .getSupportedLifecycleProcessors(</span><br><span class="line">    loadBalancerClientFactory.getInstances(serviceId, LoadBalancerLifecycle<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">DefaultRequestContext</span>.<span class="title">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">ServiceInstance</span>.<span class="title">class</span>)</span>;</span><br><span class="line">  Request lbRequest = request <span class="keyword">instanceof</span> Request ? (Request) request : <span class="keyword">new</span> DefaultRequest&lt;&gt;();</span><br><span class="line">  supportedLifecycleProcessors</span><br><span class="line">    .forEach(lifecycle -&gt; lifecycle.onStartRequest(lbRequest, <span class="keyword">new</span> DefaultResponse(serviceInstance)));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 请求调用前先使用 transformers 对原始请求对象进行一些改变处理后再执行请求</span></span><br><span class="line">    T response = request.apply(serviceInstance);</span><br><span class="line">    Object clientResponse = getClientResponse(response);</span><br><span class="line">    supportedLifecycleProcessors</span><br><span class="line">      .forEach(lifecycle -&gt; lifecycle.onComplete(<span class="keyword">new</span> CompletionContext&lt;&gt;(CompletionContext.Status.SUCCESS,</span><br><span class="line">                                                                         lbRequest, defaultResponse, clientResponse)));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException iOException) &#123;</span><br><span class="line">    supportedLifecycleProcessors.forEach(lifecycle -&gt; lifecycle.onComplete(</span><br><span class="line">      <span class="keyword">new</span> CompletionContext&lt;&gt;(CompletionContext.Status.FAILED, iOException, lbRequest, defaultResponse)));</span><br><span class="line">    <span class="keyword">throw</span> iOException;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">    supportedLifecycleProcessors.forEach(lifecycle -&gt; lifecycle.onComplete(</span><br><span class="line">      <span class="keyword">new</span> CompletionContext&lt;&gt;(CompletionContext.Status.FAILED, exception, lbRequest, defaultResponse)));</span><br><span class="line">    ReflectionUtils.rethrowRuntimeException(exception);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>所以再看看工厂是怎么获取和存放对象的, 关键类: LoadBalancerClientFactory, 其继承自 NamedContextFactory</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先看其如何获取对象的 LoadBalancerClientFactory#getInstance()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReactiveLoadBalancer&lt;ServiceInstance&gt; <span class="title">getInstance</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从 serviceId 对应的容器中获取一个负载均衡算法实现类对象, 即 ReactorServiceInstanceLoadBalancer.</span></span><br><span class="line">  <span class="keyword">return</span> getInstance(serviceId, ReactorServiceInstanceLoadBalancer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getInstance(serviceId, ReactorServiceInstanceLoadBalancer.class):</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> context.getBean(type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (NoSuchBeanDefinitionException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getContext(name):</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">        <span class="comment">// 结论: 容器里有点东西, 但不多...  主要是于父容器打通... 所以又啥都有了.</span></span><br><span class="line">        <span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createContext(name):</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.结合实现类 LoadBalancerClientFactory 做出如下注释</span></span><br><span class="line">  <span class="comment">// 1.将 LoadBalancerAutoConfiguration 扫描到 configurations 注册到 name 对应的容器中.</span></span><br><span class="line">  <span class="comment">//     这里的 name 其实就是 serviceId, 也就是说, 若我们想给某个容器加入一些东西, 则实现 LoadBalancerClientSpecification 时, name 需要与 serviceId 对应起来(相同)</span></span><br><span class="line">  <span class="comment">// 2.当我上面那句没说啊... 原来 name 为 default. 开头是可以加入任意 serviceId 对应的容器的.........................(qiao)</span></span><br><span class="line">  <span class="comment">// 3.为容器加入一个占位符解析器, 和一个 defaultConfigType(=LoadBalancerClientConfiguration.class, 作用配置一些 bean)</span></span><br><span class="line">  <span class="comment">//     LoadBalancerClientConfiguration 会加入一个 RoundRobinLoadBalancer, 看来就是默认的负载均衡类了.</span></span><br><span class="line">  <span class="comment">// 4.默认为加了一个名为 loadbalancer 的 PropertySource, 里面有一个 loadbalancer.client.name=serviceId 的配置....</span></span><br><span class="line">  <span class="comment">// 5.设定父容器, 父容器通过 ApplicationContextAware 获得, 这样刚才那么辛苦的注册方式, 就仅适合于特性, 而非通用了.</span></span><br><span class="line">  <span class="comment">// 6.设置名称(啥意义呢?), 然后调用容器的 refresh() 完成容器加载</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name).getConfiguration()) &#123;</span><br><span class="line">      context.register(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">"default."</span>)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">        context.register(configuration);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  context.register(PropertyPlaceholderAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>.<span class="title">defaultConfigType</span>)</span>;</span><br><span class="line">  <span class="comment">// 默认为加了一个名为 loadbalancer 的 PropertySource, 里面有一个 loadbalancer.client.name=serviceId 的配置....</span></span><br><span class="line">  context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(<span class="keyword">this</span>.propertySourceName,</span><br><span class="line">                                                                               Collections.&lt;String, Object&gt;singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">    context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">    <span class="comment">// jdk11 issue</span></span><br><span class="line">    <span class="comment">// https://github.com/spring-cloud/spring-cloud-netflix/issues/3101</span></span><br><span class="line">    context.setClassLoader(<span class="keyword">this</span>.parent.getClassLoader());</span><br><span class="line">  &#125;</span><br><span class="line">  context.setDisplayName(generateDisplayName(name));</span><br><span class="line">  context.refresh();</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据这句 context.register(PropertyPlaceholderAutoConfiguration.class, this.defaultConfigType);</span></span><br><span class="line"><span class="comment">// 而 defaultConfigType 在 LoadBalancerClientFactory 定义为 LoadBalancerClientConfiguration.class, 其配置了一个 bean, 代码如下</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="title">reactorServiceInstanceLoadBalancer</span><span class="params">(Environment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                               LoadBalancerClientFactory loadBalancerClientFactory)</span> </span>&#123;</span><br><span class="line">  String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RoundRobinLoadBalancer(</span><br><span class="line">    loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier<span class="class">.<span class="keyword">class</span>), <span class="title">name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里会与服务发现结合起来, 即 loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class)</span></span><br><span class="line"><span class="comment">// 此方法从容器中获取能提供 ServiceInstanceListSupplier.class 类型的 BeanProvider, 其实就是能获取这种类型的 bean 呗, 然后用这个类来获取 url 列表...  具体实现要看 Nacos / Consul 了.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以默认获取的负载均衡策略就是它了:  RoundRobinLoadBalancer</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 用了一个 LoadBalancerAutoConfiguration, 为 RestTemplate 加一个拦截器使得执行请求前先修改一下请求对象(主要修改url呗), 修改的步骤是 LoadBalancerClient.execute(), 里面则会使用 choose 获取微服务真实url, choose 是 ReactorLoadBalancer  的接口, 代表负载均衡策略. 啊对了, 既然是负载均衡算法, 那就是负责选取, 不负责获取才对… 于是我发现 loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class) 才是得到的对象, 才是获取 url 列表的代码(肯定和consul或nacos有关了)!!</p>
<p>暗示下集出 Nacos!!</p>
</blockquote>
<h2 id="Cloud-Alibaba-和-Spring-Cloud-整合-Spring-Cloud-Commons-步骤-指服务注册与发现"><a href="#Cloud-Alibaba-和-Spring-Cloud-整合-Spring-Cloud-Commons-步骤-指服务注册与发现" class="headerlink" title="Cloud Alibaba 和 Spring Cloud 整合 Spring Cloud Commons 步骤(指服务注册与发现)"></a>Cloud Alibaba 和 Spring Cloud 整合 Spring Cloud Commons 步骤(指服务注册与发现)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.希望别太简单</span><br><span class="line">2.就不写这里了(因为还没写啊!)</span><br><span class="line">3.下集见</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Cloud-整合-spring-cloud-loadbalancer"><a href="#Spring-Cloud-整合-spring-cloud-loadbalancer" class="headerlink" title="Spring Cloud 整合 spring-cloud-loadbalancer"></a>Spring Cloud 整合 spring-cloud-loadbalancer</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.pom 添加依赖即可</span><br><span class="line">2.pom 添加依赖即可</span><br><span class="line">3.pom 添加依赖即可</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">我也没想到, 没多写一个类, 直接就能用...  原理上面分析了 😭😭😭😭😭</span><br></pre></td></tr></table></figure>



<h2 id="Cloud-Alibaba-整合-spring-cloud-loadbalancer"><a href="#Cloud-Alibaba-整合-spring-cloud-loadbalancer" class="headerlink" title="Cloud Alibaba 整合 spring-cloud-loadbalancer"></a>Cloud Alibaba 整合 spring-cloud-loadbalancer</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.pom 添加依赖即可</span><br><span class="line">2.pom 添加依赖即可</span><br><span class="line">3.pom 添加依赖即可</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">我也没想到, 没多写一个类, 直接就能用...  原理上面分析了 😭😭😭😭😭</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 你没卡, 你电脑没问题, 我就是写(zhan)了(tie)两遍!!!</p>
</blockquote>
<h2 id="Spring-Cloud-Commons-的核心类及其作用"><a href="#Spring-Cloud-Commons-的核心类及其作用" class="headerlink" title="Spring Cloud Commons 的核心类及其作用"></a>Spring Cloud Commons 的核心类及其作用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.LoadBalancerClient: 实现它就实现了负载均衡策略</span><br><span class="line">	但其实实现 ReactorServiceInstanceLoadBalancer 更简单</span><br><span class="line">2.DiscoveryClient: 实现它就实现了服务发现</span><br><span class="line">3.ServiceRegistry: 实现它就实现了服务注册</span><br><span class="line">4.ServiceInstance: 代表一个服务, 前面加个 Micro 就是微服务了 :D</span><br></pre></td></tr></table></figure>





<blockquote>
<p>PS: 就这!</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/25/source-code-jdk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/25/source-code-jdk/" class="post-title-link" itemprop="url">source-code-jdk</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-25 23:12:48" itemprop="dateCreated datePublished" datetime="2021-01-25T23:12:48+08:00">2021-01-25</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/25/source-code-jdk/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/25/source-code-jdk/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/25/source-code-spring-mvc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/25/source-code-spring-mvc/" class="post-title-link" itemprop="url">Spring MVC 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-25 23:12:41" itemprop="dateCreated datePublished" datetime="2021-01-25T23:12:41+08:00">2021-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-26 21:25:55" itemprop="dateModified" datetime="2021-01-26T21:25:55+08:00">2021-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-MVC/" itemprop="url" rel="index"><span itemprop="name">Spring MVC</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/25/source-code-spring-mvc/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/25/source-code-spring-mvc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-MVC-源码笔记"><a href="#Spring-MVC-源码笔记" class="headerlink" title="Spring MVC 源码笔记"></a>Spring MVC 源码笔记</h1><h2 id="关键类分析"><a href="#关键类分析" class="headerlink" title="关键类分析"></a>关键类分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">WebMvcConfigurationSupport</span><br><span class="line">	默认注册了很多东西,如 HandlerMapping 几个实现, HandlerAdaptor 几个实现</span><br><span class="line"></span><br><span class="line">HandlerMapping</span><br><span class="line">	添加容器内所有带有 RequestMaping 的类的公开方法到 mappings 中存起来</span><br><span class="line">		(AbstractHandlerMethodMapping<span class="comment">#afterPropertiesSet中)</span></span><br><span class="line">    根据 request 的 uri 查找对应的 HandlerMethod, 步骤概述:</span><br><span class="line">    	把RequestMapping注解内的 path 作为 key 保持到一个 map1</span><br><span class="line">    	其他信息封装成 mapping 作为 key 也保持到另一个 map2</span><br><span class="line">    	根据 uri去 map1 获取 mapping, 再根据 mapping 获取 HandlerMethod</span><br><span class="line">    	封装成 Match 对象, 与其他匹配对象做比较后, 返回 HandlerMethod</span><br><span class="line"></span><br><span class="line">HandlerAdapter</span><br><span class="line">	初始化参数解析，返回值解析等</span><br><span class="line">		(RequestMappingHandlerAdapter<span class="comment">#afterPropertiesSet)</span></span><br><span class="line">	根据 handler 确定对应的 HandlerAdapter, 然后 HandlerAdapter 负责执行这个 handler</span><br><span class="line">    如 RequestMappingHandlerAdapter 则负责执行 HandlerMethod</span><br><span class="line">    	简单说就是封装 HandlerMethod, 根据参数值设置参数, 然后调用方法, 再处理返回值封装成 ModelAndView</span><br><span class="line">    另外，这里如果使用了@ResponseBody，会进入 RequestResponseBodyMethodProcessor</span><br><span class="line">    	然后使用 messageConverters（json）写入到响应流</span><br><span class="line">    	最后 mv 也直接返回null, 不需要render了.</span><br><span class="line"></span><br><span class="line">ViewResolver</span><br><span class="line">	负责将 ModelAndView 解析成HTML, 如JSP, FreeMarker</span><br><span class="line"></span><br><span class="line">HandlerExecutionChian</span><br><span class="line">	管理拦截器和封装Handler, 负责拦截器的实际调用逻辑实现</span><br><span class="line">	</span><br><span class="line">DispatcherServlet</span><br><span class="line">	调度整个HTTP请求响应流程, 调用各个子组件负责执行处理方法, 解析视图, 处理异常等.</span><br></pre></td></tr></table></figure>





<h2 id="SSM项目-Spring-容器和-Spring-MVC-容器的创建过程及关系"><a href="#SSM项目-Spring-容器和-Spring-MVC-容器的创建过程及关系" class="headerlink" title="SSM项目 Spring 容器和 Spring MVC 容器的创建过程及关系"></a>SSM项目 Spring 容器和 Spring MVC 容器的创建过程及关系</h2><h3 id="Spring-容器的创建"><a href="#Spring-容器的创建" class="headerlink" title="Spring 容器的创建"></a>Spring 容器的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.context.ContextLoader<span class="comment">#initWebApplicationContext</span></span><br><span class="line">1.先判断此方法是否重复运行, 若重复则报异常.</span><br><span class="line">2.记录日志, 记录开始时间用于计算启动消耗时间</span><br><span class="line">3.将容器对象存储在本地而非 servletContext, 防止 ServletContext 关闭后无法访问</span><br><span class="line">4.根据配置的类名, 实例化一个容器并赋值给 this.context</span><br><span class="line">5.标准代码, 但其实就是 setParent(null), 前提是不扩展子类咯. 也就是说这个就是顶级容器了</span><br><span class="line">6.根据 web.xml 的配置对容器做相应的配置, 初始化, 将 ServletContext 存入到 environment 对象中; 执行 InitializerClass, 调用容器 refresh 完成容器加载</span><br><span class="line">7.打印容器初始化完成日志和记录耗时</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 监听 ServletContext 创建完毕的事件, 然后创建一个 web 容器, 配置一些东西(id, parent, environment)并初始化(refresh)</p>
</blockquote>
<h3 id="MVC-子容器的创建"><a href="#MVC-子容器的创建" class="headerlink" title="MVC 子容器的创建"></a>MVC 子容器的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.首先是 DispatchServlet 本身是一个 Servlet, 因此他有生命周期 init(), 其父类 init() 会将 ServletConfig 的配置(web.xml 中的 initParams)与 servlet 对象绑定, 这样 DispatchServlet 对象的字段就有值了.</span><br><span class="line">2.然后在 DispatchServlet 的父类 FrameworkServlet<span class="comment">#initServletBean 中, 会创建一个容器并使其加载.(详细见 FrameworkServlet#initWebApplicationContext() )</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 就是利用 Servlet 的生命周期只会执行一次 init 的特性, 查找父容器, 创建子容器.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HttpServletBean#init</span><br><span class="line">    <span class="comment">// 1.把 servletConfig 的 initParameters 都加入 PropertySource, 根据 requiredProperties 判断所需配置项是否齐全</span></span><br><span class="line">		<span class="comment">// 2.将配置项绑定到 Servlet 对象(this) 上(子类的字段也算).</span></span><br><span class="line">		<span class="comment">// 3.调用子类初始化方法</span></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.FrameworkServlet#initServletBean</span><br><span class="line">    <span class="comment">// 0.父类的 init 执行完, 此时 contextConfigLocation 已经有值了</span></span><br><span class="line">		<span class="comment">// 1.记录日志和开始时间</span></span><br><span class="line">		<span class="comment">// 2.创建子容器, 与父容器绑定, 做一些配置, 调用 refresh() 完成加载.</span></span><br><span class="line">		<span class="comment">// 3.打印日志, 打印耗时</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</span><br><span class="line">    <span class="comment">// 1.从 ServletContext 中获取 Spring 容器.(那么谁放进去的呢? 没错, 就是 ContextLoader,监听了 ServletContext 事件)</span></span><br><span class="line">		<span class="comment">// 2.若容器在构造方法处被注入(可能是注解开发 Spring MVC 的方式会触发), 先忽视  -- 来自 web.xml 形式启动分析</span></span><br><span class="line">		<span class="comment">// 3.根据绑定得到的配置的 contextClass 创建一个子容器, 进行一些配置和初始化, 调用 refresh() 完成容器加载</span></span><br><span class="line">		<span class="comment">// 4.防止子容器不支持 refresh, 或子容器不是刚刚创建的, 因此手动触发 onRefresh(), 这个方法会加载一些默认的 bean(用处很大的那种)</span></span><br><span class="line">		<span class="comment">// 5.将容器设置到 ServletContext 中(根据配置, 默认允许)</span></span><br><span class="line">		<span class="comment">// 6.返回创建的子容器对象</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext</span><br><span class="line">    <span class="comment">// 1.根据绑定得到的配置设置容器 id, 若无则生成默认的</span></span><br><span class="line">		<span class="comment">// 2.设置 ServletContext/ServletConfig 对象</span></span><br><span class="line">		<span class="comment">// 3.为子容器添加一个监听只监听子容器刷新事件的监听器, 用于容器加载完毕后调用 FrameworkServlet.onApplicationEvent()</span></span><br><span class="line">		<span class="comment">// 4.将 ServletConfig/ServletContext 加入到 environment 中.</span></span><br><span class="line">		<span class="comment">// 5.执行 web.xml 中配置的 Initializers, 为子容器做的初始化</span></span><br><span class="line">		<span class="comment">// 6.调用子容器的 refresh(), 完成容器的加载</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#initStrategies</span><br><span class="line">    <span class="comment">// 加载文件上传处理 bean</span></span><br><span class="line">		<span class="comment">// 加载国际化处理 bean</span></span><br><span class="line">		<span class="comment">// 加载主题切换处理 bean</span></span><br><span class="line">		<span class="comment">// 加载 HandlerMapping bean</span></span><br><span class="line">		<span class="comment">// 加载 HandlerAdapter bean</span></span><br><span class="line">		<span class="comment">// 加载异常处理 bean</span></span><br><span class="line">		<span class="comment">// 加载 HttpServletRequest 转视图名称处理策略 bean</span></span><br><span class="line">		<span class="comment">// 加载视图解析器</span></span><br><span class="line">		<span class="comment">// 加载 FlashMap 管理 bean</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 每一个加载的逻辑都是类似的, 先从容器中根据 Xxx.class getBean</span></span><br><span class="line">		<span class="comment">// 若无, 则调用 getDefaultStrategy() 从 DispatcherServlet.properties 配置文件中读取</span></span><br></pre></td></tr></table></figure>



<h3 id="DispatchServlet-的创建"><a href="#DispatchServlet-的创建" class="headerlink" title="DispatchServlet 的创建"></a>DispatchServlet 的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Tomcat 会创建配置在 web.xml 的 Servlet</span><br><span class="line">2.接着会触发 init 方法, init 调用了创建子容器的方法后, 还添加了容器加载完毕事件监听来回调 DispatcherServlet<span class="comment">#onRefresh</span></span><br><span class="line">3.DispatcherServlet<span class="comment">#onRefresh 会 initStrategies() 加载很多策略接口 bean.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 和子容器的创建息息相关.</p>
</blockquote>
<h2 id="Dispatch-过程"><a href="#Dispatch-过程" class="headerlink" title="Dispatch 过程"></a>Dispatch 过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.覆盖 HttpServlet 的 service 方法, 调用 FrameworkServlet<span class="comment">#processRequest()</span></span><br><span class="line">2.此方法中进行一些上下文的准备工作, 以及处理日志, 异常(非 controller 异常), 然后调用 DispatcherServlet<span class="comment">#doService()</span></span><br><span class="line">3.doService() 中对 request 做一些准备工作, 然后调用 DispatcherServlet<span class="comment">#doDispatch()</span></span><br><span class="line">4.doDispatch() 先用 handlerMappings 查找合适的 handler(并加入拦截器链), 再通过 handlerAdapters 得到 handler 的适配器, 在合适的地方触发拦截器; 然后调用适配器的 handle() 得到 ModelAndView</span><br><span class="line">5.得到 ModelAndView 后, 先判断是否捕获到了异常, 是则调用 handlerExceptionResolvers 的 resolveException() 处理异常</span><br><span class="line">6.接着, 调用 viewResolvers 的 resolveViewName, 将 viewName 解析成一个 View 对象</span><br><span class="line">7.调用 View 对象的 render(), 将视图通过 response 响应到前端.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: handlerMappings 找 handler 并包装拦截器链, handlerAdapters 找可执行的 HandlerAdapter, viewResolvers 解析视图, 渲染视图.</p>
</blockquote>
<h3 id="超长源码注释"><a href="#超长源码注释" class="headerlink" title="超长源码注释"></a>超长源码注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口 HttpServlet.service</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">  HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">  <span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    processRequest(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.service(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入到 processRequest, 我只写注释了啊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.FrameworkServlet#processRequest</span><br><span class="line">    <span class="comment">// 1.记录启动时间</span></span><br><span class="line">		<span class="comment">// 2.准备国际化处理上下文</span></span><br><span class="line">		<span class="comment">// 3.准备属性管理上下文</span></span><br><span class="line">		<span class="comment">// 4.获取并缓存一个 asyncManager(异步)</span></span><br><span class="line">		<span class="comment">// 5.初始化两个 ContextHolder</span></span><br><span class="line">		<span class="comment">// 6.处理文件上传, 根据不同策略查找可执行的 controller 方法, 查到后加入拦截器, 再通过适配器来执行 controller 方法, 然后把得到的 ModelAndView 解析成视图对象, 并渲染到前端.</span></span><br><span class="line">		<span class="comment">// 7.重置两个 ContextHolder</span></span><br><span class="line">		<span class="comment">// 8.打印日志, 发布事件</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#doService</span><br><span class="line">    <span class="comment">// 1.打印日志, 记录请求信息</span></span><br><span class="line">		<span class="comment">// 2.保存一份请求上下文的快照, 这样嵌套的请求在回归时可以恢复数据</span></span><br><span class="line">		<span class="comment">// 3.将容器中的一些 bean 配置到请求上下文中</span></span><br><span class="line">		<span class="comment">// 4.处理文件上传, 根据不同策略查找可执行的 controller 方法, 查到后加入拦截器, 再通过适配器来执行 controller 方法, 然后把得到的 ModelAndView 解析成视图对象, 并渲染到前端.</span></span><br><span class="line">		<span class="comment">// 5.若需要, 将快照恢复到请求上下文</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#doDispatch</span><br><span class="line">    <span class="comment">// 1.准备一些变量</span></span><br><span class="line">		<span class="comment">// 2.判断并处理文件上传请求, 若是, processedRequest 则变为 MultipartHttpServletRequest 类型的对象.</span></span><br><span class="line">		<span class="comment">// 3.遍历之前加载的 handlerMappings, 调用 getHandler 接口获取执行链对象并返回. 找不到则返回 null</span></span><br><span class="line">		<span class="comment">// 4.根据 handler 获取合适的适配器</span></span><br><span class="line">		<span class="comment">// 5.遍历执行拦截器的 preHandle(), 若遇到 renturn false, 则结束 doDispatch</span></span><br><span class="line">		<span class="comment">// 6.执行实际的 controller 的方法得到 ModelAndView 对象.</span></span><br><span class="line">		<span class="comment">// 7.处理默认的 viewName</span></span><br><span class="line">		<span class="comment">// 8.遍历执行拦截器的 postHandle()</span></span><br><span class="line">		<span class="comment">// 9.若有异常则处理异常: 遍历之前加载的异常处理器策略类, 调用 resolveException()</span></span><br><span class="line">		<span class="comment">//10.若无异常则根据需要根据 ModelAndView的对象的视图名配合之前加载的视图解析器获取 View 对象, 再调用 render() 渲染视图.</span></span><br><span class="line">		<span class="comment">//11.最后执行拦截器的 triggerAfterCompletion</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#getHandler</span><br><span class="line">    <span class="comment">// 遍历之前加载的 handlerMappings, 调用其 getHandler 接口获取 handler 和拦截器封装成 chain 对象并返回. 找不到则返回 null</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter</span><br><span class="line">    <span class="comment">// 遍历之前加载的 handlerAdapters, 调用 supports 判断是否支持 handler, 支持则返回 adapter</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle</span><br><span class="line">    <span class="comment">// 从头到尾遍历拦截器, 执行 preHandle(), 若拦截器返回 false, 则立刻 triggerAfterCompletion, 然后 return false</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#processDispatchResult</span><br><span class="line">    <span class="comment">// 若有异常则处理异常: 遍历之前加载的异常处理器策略类, 调用 resolveException()</span></span><br><span class="line">		<span class="comment">// 若无异常则根据需要根据视图名和视图解析器渲染视图</span></span><br><span class="line">		<span class="comment">// 最后执行拦截器的 triggerAfterCompletion</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#processHandlerException</span><br><span class="line">    <span class="comment">// 遍历之前加载的异常处理器策略类, 调用 resolveException()</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#render</span><br><span class="line">    <span class="comment">// 先遍历视图解析器, 根据视图名获取实际视图对象</span></span><br><span class="line">		<span class="comment">// 最后调用实际视图对象的 render (渲染方法)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#resolveViewName</span><br><span class="line">    <span class="comment">// 遍历视图解析器, 根据视图名获取实际视图对象</span></span><br></pre></td></tr></table></figure>





<h2 id="某些实现原理"><a href="#某些实现原理" class="headerlink" title="某些实现原理"></a>某些实现原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.拦截器原理</span><br><span class="line">2.默认的 HandlerMapping/HandlerAdapter 在何时加入?</span><br><span class="line">3.参数是如何与 HTTP 请求 body 绑定的(序列化, 格式化, 绑定)?</span><br><span class="line">4.参数校验是如何进行的?</span><br><span class="line">5.有关参数与返回值的一些拦截与干预(@RequestBody, @ResponseBody).</span><br></pre></td></tr></table></figure>



<h3 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">何时加入?</span><br><span class="line">	从 WebMvcConfigurationSupport 的子类中调用 addInterceptors </span><br><span class="line">	添加一些拦截器和拦截器的路径配置 InterceptorRegistry 和 MappedInterceptor</span><br><span class="line">    实现拦截器路径匹配, 在 new HandlerExecutionChian 时判断</span><br><span class="line"></span><br><span class="line">何时执行?</span><br><span class="line">	DispatcherServlet 负责在正确的时机调用 HandlerExecutionChian 来调用 preHanlde 等方法.</span><br><span class="line">	拿到 HandlerExecutionChian 后调用 preHanlde</span><br><span class="line">	HandlerAdapter 执行完 handler 后, 调用 postHandle</span><br><span class="line">	解析视图并渲染到response之后, 调用 afterCompletion</span><br><span class="line">	如果中途出现异常, 或 preHandle 提前结束, 则也调用 afterCompletion</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">	DispatcherServlet 去调用 HandlerExecutionChian 去调用 拦截器具体方法. </span><br><span class="line">	复杂点是添加一个拦截器到被加入到 HandlerExecutionChian 比较复杂一点, 以及带路径匹配的拦截器实现略复杂一些.</span><br></pre></td></tr></table></figure>



<h3 id="默认的-HandlerMapping-HandlerAdapter-在何时加入"><a href="#默认的-HandlerMapping-HandlerAdapter-在何时加入" class="headerlink" title="默认的 HandlerMapping/HandlerAdapter 在何时加入?"></a>默认的 HandlerMapping/HandlerAdapter 在何时加入?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.DispatcherServlet#initStrategies</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 加载文件上传处理 bean</span></span><br><span class="line">  <span class="comment">// 加载国际化处理 bean</span></span><br><span class="line">  <span class="comment">// 加载主题切换处理 bean</span></span><br><span class="line">  <span class="comment">// 加载 HandlerMapping bean</span></span><br><span class="line">  <span class="comment">// 加载 HandlerAdapter bean</span></span><br><span class="line">  <span class="comment">// 加载异常处理 bean</span></span><br><span class="line">  <span class="comment">// 加载 HttpServletRequest 转视图名称处理策略 bean</span></span><br><span class="line">  <span class="comment">// 加载视图解析器</span></span><br><span class="line">  <span class="comment">// 加载 FlashMap 管理 bean</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每一个 init 的逻辑都是类似的, 先从容器中根据 Xxx.class getBean</span></span><br><span class="line">  <span class="comment">// 若无, 则调用 getDefaultStrategy() 从 DispatcherServlet.properties 配置文件中读取</span></span><br><span class="line">  initMultipartResolver(context);</span><br><span class="line">  initLocaleResolver(context);</span><br><span class="line">  initThemeResolver(context);</span><br><span class="line">  initHandlerMappings(context);</span><br><span class="line">  initHandlerAdapters(context);</span><br><span class="line">  initHandlerExceptionResolvers(context);</span><br><span class="line">  initRequestToViewNameTranslator(context);</span><br><span class="line">  initViewResolvers(context);</span><br><span class="line">  initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参数是如何与-HTTP-请求-body-绑定的-序列化-格式化-绑定"><a href="#参数是如何与-HTTP-请求-body-绑定的-序列化-格式化-绑定" class="headerlink" title="参数是如何与 HTTP 请求 body 绑定的(序列化, 格式化, 绑定)?"></a>参数是如何与 HTTP 请求 body 绑定的(序列化, 格式化, 绑定)?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.在适配器执行 handler 的时候, 即 RequestMappingHandlerAdapter#invokeHandlerMethod</span><br><span class="line">2.此方法会进行一些其他处理, 然后准备执行方法前解析参数, 即在 InvocableHandlerMethod#getMethodArgumentValues() 中</span><br><span class="line"><span class="number">3</span>.这个方法中会遍历每一个参数, 再遍历配置的所有 resolvers, 通过 supportsParameter 接口判断是否支持参数解析, 是则调用 resolveArgument 接口获得实参</span><br><span class="line">4.这其中, 最重要的是 resolvers, 其一般在 RequestMappingHandlerAdapter#getDefaultArgumentResolvers() 中添加默认和用户自定义的 resoloves.</span><br><span class="line">5.如 RequestResponseBodyMethodProcessor#resolveArgument() 用于处理带 @RequestBody 注解的参数.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 适配器执行具体方法前, 先用反射获取这个方法的 参数(形参)集合, 挨个遍历从 resolvers 找支持解析的类来解析, 得到的返回值作为实参先存起来, 最后调用具体方法时就可以带上实参们执行就实现了将 HTTP 的数据绑定到 controller 的方法参数上的功能.</p>
<p>参考 RequestResponseBodyMethodProcessor#resolveArgument()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">                              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 readWithMessageConverters 读取 body 的数据, 再序列化 json 成相应的 Java Bean</span></span><br><span class="line">  <span class="comment">// 使用 binder 检查 arg 的值是否与 @Valid 的那些注解相关的规则相符, 若有错误, 则抛异常.</span></span><br><span class="line"></span><br><span class="line">  parameter = parameter.nestedIfOptional();</span><br><span class="line">  Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">  String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (binderFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">    <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">      validateIfApplicable(binder, parameter);</span><br><span class="line">      <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mavContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参数校验是如何进行的"><a href="#参数校验是如何进行的" class="headerlink" title="参数校验是如何进行的?"></a>参数校验是如何进行的?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考上面的代码</span></span><br><span class="line"><span class="keyword">if</span> (binderFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">  WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">  <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">    validateIfApplicable(binder, parameter);</span><br><span class="line">    <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mavContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码 validateIfApplicable() 就进行了参数校验, 代码如下:</span></span><br><span class="line"><span class="comment">// 逻辑是: 遍历参数所有的注解, 包含 validatedAnn 或以 Valid 开头的注解都进行校验</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">validateIfApplicable</span><span class="params">(WebDataBinder binder, MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">  Annotation[] annotations = parameter.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">for</span> (Annotation ann : annotations) &#123;</span><br><span class="line">    Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (validatedAnn != <span class="keyword">null</span> || ann.annotationType().getSimpleName().startsWith(<span class="string">"Valid"</span>)) &#123;</span><br><span class="line">      Object hints = (validatedAnn != <span class="keyword">null</span> ? validatedAnn.value() : AnnotationUtils.getValue(ann));</span><br><span class="line">      Object[] validationHints = (hints <span class="keyword">instanceof</span> Object[] ? (Object[]) hints : <span class="keyword">new</span> Object[] &#123;hints&#125;);</span><br><span class="line">      binder.validate(validationHints);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后是 validate 具体的对象.</span></span><br><span class="line"><span class="comment">// 逻辑是: 遍历所有的 validators, 挨个调用 validate 校验</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object... validationHints)</span> </span>&#123;</span><br><span class="line">  Object target = getTarget();</span><br><span class="line">  Assert.state(target != <span class="keyword">null</span>, <span class="string">"No target to validate"</span>);</span><br><span class="line">  BindingResult bindingResult = getBindingResult();</span><br><span class="line">  <span class="comment">// Call each validator with the same binding result</span></span><br><span class="line">  <span class="keyword">for</span> (Validator validator : getValidators()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(validationHints) &amp;&amp; validator <span class="keyword">instanceof</span> SmartValidator) &#123;</span><br><span class="line">      ((SmartValidator) validator).validate(target, bindingResult, validationHints);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (validator != <span class="keyword">null</span>) &#123;</span><br><span class="line">      validator.validate(target, bindingResult);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再往下就没啦... Spring 没有具体的实现, 所以要导入 Hibernate 的啥啥啥包, 这是有原因的.</span></span><br></pre></td></tr></table></figure>





<h3 id="有关参数与返回值的一些拦截与干预-RequestBody-ResponseBody"><a href="#有关参数与返回值的一些拦截与干预-RequestBody-ResponseBody" class="headerlink" title="有关参数与返回值的一些拦截与干预(@RequestBody, @ResponseBody)."></a>有关参数与返回值的一些拦截与干预(@RequestBody, @ResponseBody).</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 RequestMappingHandlerAdapter#afterPropertiesSet()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">  initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">    <span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">    <span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">    <span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由上可知, argumentResolvers/returnValueHandlers 都是此时初始化的, 再点进去看代码发现, 除了默认的, 还有用户自定义的 customArgumentResolvers/customReturnValueHandlers;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找字段的引用发现</span></span><br><span class="line">WebMvcConfigurationSupport#addReturnValueHandlers</span><br><span class="line">WebMvcConfigurationSupport#addArgumentResolvers</span><br><span class="line"><span class="comment">// 这两个方法可以继承后加入加入自己的 ArgumentResolvers/ReturnValueHandlers, 也就是项目里面继承 WebMvcConfiguration 的那个类, 重写这两个方法, 加入自己的类即可实现对参数/返回值的干预; 常用于统一加密/解密, 记录日志等.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除此之外, 两边的默认值都有 RequestResponseBodyMethodProcessor, 这就是用于处理@RequestBody/@ResponseBody 的了, 往里面深入的看, 能看到其使用 messageConverters 读取 body 数据, 然后也会在对应的地方触发 advice 的方法.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters</span></span><br><span class="line"><span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">  Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();</span><br><span class="line">  GenericHttpMessageConverter&lt;?&gt; genericConverter =</span><br><span class="line">    (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (genericConverter != <span class="keyword">null</span> ? genericConverter.canRead(targetType, contextClass, contentType) :</span><br><span class="line">      (targetClass != <span class="keyword">null</span> &amp;&amp; converter.canRead(targetClass, contentType))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message.hasBody()) &#123;</span><br><span class="line">      HttpInputMessage msgToUse =</span><br><span class="line">        getAdvice().beforeBodyRead(message, parameter, targetType, converterType);</span><br><span class="line">      body = (genericConverter != <span class="keyword">null</span> ? genericConverter.read(targetType, contextClass, msgToUse) :</span><br><span class="line">              ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));</span><br><span class="line">      body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, message, parameter, targetType, converterType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="参数的N种绑定方式"><a href="#参数的N种绑定方式" class="headerlink" title="参数的N种绑定方式"></a>参数的N种绑定方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 RequestMappingHandlerAdapter#getDefaultArgumentResolvers</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type-based argument resolution</span></span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Custom arguments</span></span><br><span class="line">  <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Catch-all</span></span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看几个常见的</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.RequestParamMethodArgumentResolver: 负责解析带 @RequestParam 注解的普通参数</span><br><span class="line">2.RequestParamMapMethodArgumentResolver: 负责解析带 @RequestParam 的 Map 参数....</span><br><span class="line">3.PathVariableMethodArgumentResolver/PathVariableMapMethodArgumentResolver: 同上解析带 @PathVariable 注解的参数</span><br><span class="line">4.RequestResponseBodyMethodProcessor: 负责解析带 @RequestBody 的参数</span><br><span class="line">5.RequestHeaderMethodArgumentResolver: 负责解析带 @RequestHeader 的参数 (表示没用过)</span><br><span class="line">6.ServletRequestMethodArgumentResolver: 负责解析 HttpServletRequest 等类型的参数(即 req, 用的贼多)</span><br><span class="line">7.ServletResponseMethodArgumentResolver: 负责解析 HttpServletResponse 等类型的参数(即 resp, 下载接口没少用)</span><br><span class="line">8.RequestParamMethodArgumentResolver: 啥都解析.... 即不带任何注解的普通类型.</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/24/source-code-spring-boot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/source-code-spring-boot/" class="post-title-link" itemprop="url">Spring Boot 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 02:04:22" itemprop="dateCreated datePublished" datetime="2021-01-24T02:04:22+08:00">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-25 23:17:48" itemprop="dateModified" datetime="2021-01-25T23:17:48+08:00">2021-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/24/source-code-spring-boot/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/24/source-code-spring-boot/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Boot-源码分析"><a href="#Spring-Boot-源码分析" class="headerlink" title="Spring Boot 源码分析"></a>Spring Boot 源码分析</h1><h2 id="run-流程"><a href="#run-流程" class="headerlink" title="run 流程"></a>run 流程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.StopWatch 提供的计算耗时的功能, 创建一个后立即开始计时.</span><br><span class="line">2.创建一个引导容器, 并在此时(容器未使用前)把 spring.factories 找到 Bootstrapper 接口的类对应的方法触发, 来给引导容器里注册一些东西(如果有需要)</span><br><span class="line">3.从 spring.factories 找 SpringApplicationRunListener 的类, 实例化后存到 SpringApplicationRunListeners 中.</span><br><span class="line">4.触发所有存入的 SpringApplicationRunListener 的 starting 事件.</span><br><span class="line">5.将 args 内容中的参数们(类似 --spring.port=9999)解析成键值对存到 applicationArguments 对象中.</span><br><span class="line">6.创建了一个 environment 对象, 添加了好几个功能各异的 PropertySource, 触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件</span><br><span class="line">7.根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里, 根据 this.banner 判断打印什么样的 Banner (佛祖保佑.png)</span><br><span class="line">8.根据 web 类型创建不同的 ApplicationContext, 这里的创建, 仅实例化而已, 没有从构造方法调用 loadBeanDefinitions 和 refresh 的逻辑</span><br><span class="line">9.将 applicationStartup (步骤记录器)赋值给 context.</span><br><span class="line">10.对容器做些配置, 然后发布 contextPrepared 事件, 接着关闭引导容器; 然后使用 BeanDefinitionLoader 扫描解析 getAllSources (如Class) 并将得到的 BeanDefinition 注册到容器, 最后发布 contextLoaded 事件</span><br><span class="line">11.注册一个钩子, 当 JVM 关闭时, 相应的关闭 context, 然后调用容器的 refresh 方法(然后进入到 Spring 源码分析那段, 自行脑补)</span><br><span class="line">12.StopWatch 计时器停止计时, 接着打印计时数据</span><br><span class="line">13.发布 started 事件</span><br><span class="line">14.从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span><br><span class="line">15.catch 到异常则发布 failed 事件</span><br><span class="line">16.发布 running 事件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从整体结构下来, 我们发现, 其主要是创建了一个引导容器(似乎也就是事件监听用到了, 其他地方完全无瓜), 然后扫描得到一些 SpringApplicationRunListener 存起来, 之后在合适的地方发布事件, 然后创建以及配置 environment 对象, 创建以及配置 ApplicationContext 对象, 解析 primarySources 来加载 BeanDefinition 到容器, 然后调用容器的 refresh 方法进入 Spring 的加载流程, 最后处理事件和调用 ApplicationRunner/CommandLineRunner 的 bean. 其中 加载 BeanDefinition 和执行  refresh 方法其实就是与 Spring 一样的逻辑.</p>
</blockquote>
<h3 id="SpringApplication-与-ApplicationContext-的关系与联系"><a href="#SpringApplication-与-ApplicationContext-的关系与联系" class="headerlink" title="SpringApplication 与 ApplicationContext 的关系与联系"></a>SpringApplication 与 ApplicationContext 的关系与联系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.SpringApplication 有独特的 environment 对象, 这是因为 application.xml 配置以及 Spring Cloud Config 这些都需要在容器创建前加载配置文件.</span><br><span class="line">2.ApplicationContext 是 new 的时候就会立刻触发 加载 BeanDefinition 和 refresh(), 而 SpringApplication 则是先 new 一个, 配置好后, 才分别调用方法去 加载 BeanDefinition 和 refresh().</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总得来讲, SpringApplication 相比 ApplicationContext 多出的就是 SpringApplicationRunListener 的事件管理, environment 对象加载与配置, 以及 run 方法的生命周期.</span><br></pre></td></tr></table></figure>



<h3 id="这些-SpringApplicationRunListener-事件都被谁监听了-有什么作用"><a href="#这些-SpringApplicationRunListener-事件都被谁监听了-有什么作用" class="headerlink" title="这些 SpringApplicationRunListener 事件都被谁监听了, 有什么作用?"></a>这些 SpringApplicationRunListener 事件都被谁监听了, 有什么作用?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 spring-boot-project/spring-boot/src/main/resources/META-INF/spring.factories</span></span><br><span class="line"><span class="comment">#   有一个 SpringApplicationRunListener, 其作用是:</span></span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br><span class="line">1.构造方法: 初始化一个事件广播器, 并将 SpringApplication 的 listeners 注册进去. (listeners 是在构造方法中从 spring.factories 加载 ApplicationListener 得到的数据)</span><br><span class="line">2.转发 starting,environmentPrepared,contextPrepared,contextLoaded 事件给 ApplicationListener</span><br><span class="line">3.在 contextLoaded 事件时, 遍历所有的 ApplicationListener 对象, 若其实现了 ApplicationContextAware 接口, 则将 context 注入.</span><br><span class="line">4.started,running,failed 事件均直接用 context.publishEvent 发布事件, 与 listeners 无关 (而且 listeners 这些东西如果仅配置在 spring.factories 而没有被扫描到容器内, 那么就是真的无关了)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结: 配置在 spring.factories 的 ApplicationListener 并不会触发所有 run 生命周期的事件. 因此有时实现 SpringApplicationRunListener 还是很有必要的) 当然, 若你写的 ApplicationListener 即配置在 spring.factories 中也会被扫描到容器内, 则无此忧虑.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着看 ApplicationListener 的作用</span></span><br><span class="line">1.ClearCachesApplicationListener: 在 ContextRefreshedEvent(容器加载完后) 清空缓存</span><br><span class="line">2.ParentContextCloserApplicationListener: 给子容器加一个监听, 使得父容器关闭后, 子容器也跟着关闭(还会递归子容器的容器吧.png)</span><br><span class="line">3.FileEncodingApplicationListener: 对比配置的编码格式, 不符合则报异常(若配置了)</span><br><span class="line">4.DelegatingApplicationListener: 新建一个事件广播器, 将配置文件中 context.listener.classes 的 class 实例化并作为监听者注册到广播器, 然后转发所有事件.</span><br><span class="line">5.EnvironmentPostProcessorApplicationListener</span><br><span class="line">    接受 ApplicationEnvironmentPreparedEvent 事件, 然后把从 spring.factories 获得的 EnvironmentPostProcessor 的 classNames 实例化, 然后遍历执行 postProcessEnvironment(), 其中 ConfigFileApplicationListener 用于加载 application.xxx(yml,xml,properties) 文件的配置到 environment 中的 PropertySource 里. (另外一提, Spring Cloud Config 应该也是这里实现的)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结: 原来配置文件是这么被加载进去的, 没有在主流程中写, 而是监听事件, 再调用 EnvironmentPostProcessor, 层层封装, 扩展性好强(读起来也好蓝).</span></span><br></pre></td></tr></table></figure>



<h3 id="超长源码注释"><a href="#超长源码注释" class="headerlink" title="超长源码注释"></a>超长源码注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们从源码的 spring-boot/spring-boot-tests/spring-boot-smoke-tests/spring-boot-smoke-test-tomcat 下, 找到 SampleTomcatApplication.java 类, 直接看它的 main 方法.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SpringApplication.run(SampleTomcatApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着, 我们点进 run 方法, 瞧瞧里面干了啥</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看起来不多嘛......(看前如是写道, 看完已是凌晨四点)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.StopWatch 提供的计算耗时的功能, 创建一个后立即开始计时.</span></span><br><span class="line">  <span class="comment">// 2.创建一个引导容器, 并在此时(容器未使用前)把 spring.factories 找到 Bootstrapper 接口的类对应的方法触发, 来给引导容器里注册一些东西(如果有需要)</span></span><br><span class="line">  <span class="comment">// 3.从 spring.factories 找 SpringApplicationRunListener 的类, 实例化后存到 SpringApplicationRunListeners 中.</span></span><br><span class="line">  <span class="comment">// 4.触发所有存入的 SpringApplicationRunListener 的 starting 事件.</span></span><br><span class="line">  <span class="comment">// 5.将 args 内容中的参数们(类似 --spring.port=9999)解析成键值对存到 applicationArguments 对象中.</span></span><br><span class="line">  <span class="comment">// 6.创建了一个 environment 对象, 添加了好几个功能各异的 PropertySource, 触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件</span></span><br><span class="line">  <span class="comment">// 7.根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里, 根据 this.banner 判断打印什么样的 Banner (佛祖保佑.png)</span></span><br><span class="line">  <span class="comment">// 8.根据 web 类型创建不同的 ApplicationContext, 这里的创建, 仅实例化而已, 没有从构造方法调用 loadBeanDefinitions 和 refresh 的逻辑</span></span><br><span class="line">  <span class="comment">// 9.将 applicationStartup (步骤记录器)赋值给 context.</span></span><br><span class="line">  <span class="comment">//10.对容器做些配置, 然后发布 contextPrepared 事件, 接着关闭引导容器; 然后根据 primarySource 使用 BeanDefinitionLoader 加载 BeanDefinition 到容器, 最后发布 contextLoaded 事件</span></span><br><span class="line">  <span class="comment">//11.注册一个钩子, 当 JVM 关闭时, 相应的关闭 context, 然后调用容器的 refresh 方法(然后进入到 Spring 源码分析那段, 自行脑补)</span></span><br><span class="line">  <span class="comment">//12.计时器停止计时, 接着打印计时数据</span></span><br><span class="line">  <span class="comment">//13.发布 started 事件</span></span><br><span class="line">  <span class="comment">//14.从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span></span><br><span class="line">  <span class="comment">//15.catch 到异常则发布 failed 事件</span></span><br><span class="line">  <span class="comment">//16.发布 running 事件</span></span><br><span class="line"></span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  stopWatch.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个引导容器, 并在此时(容器未使用前)从 spring.factories 扫描一些实现了 Bootstrapper 接口的类, 来给引导容器里注册一些东西(如果有需要)</span></span><br><span class="line">  DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往系统变量里设置一个变量 headless, 看上去和 AWT 有关, 暂且忽略之</span></span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扫描 spring.factories 中配置的实现了 SpringApplicationRunListener 的类们</span></span><br><span class="line">  <span class="comment">//   实例化后放到 SpringApplicationRunListeners (其就是个容器管理类) 存起来.</span></span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发所有存入的 SpringApplicationRunListener 的 starting 事件.</span></span><br><span class="line">  listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将 args 内容中的参数(类似 --spring.port=9999)解析成键值对存到 applicationArguments 对象中.</span></span><br><span class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个 environment 对象, 添加了好几个功能各异的 PropertySource,</span></span><br><span class="line">    <span class="comment">//   触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件</span></span><br><span class="line">    <span class="comment">//   将 environment 中 spring.main 开头的配置数据, 一一对应绑定到 SpringApplication(即this)的字段上去</span></span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 environment 的 spring.beaninfo.ignore 配置复制到 System.Property 去(若不存在)</span></span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里, 根据 this.banner 判断打印什么样的 Banner (佛祖保佑.png)</span></span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 web 类型创建不同的 ApplicationContext, 但其实差别不大, 就时多了 web 容器的特征(如启动 tomcat)</span></span><br><span class="line">    <span class="comment">// 另外与 Spring 源码分析时不同, 这里的创建, 仅实例化而已, 没有从构造方法调用 loadBeanDefinitions 和 refresh 的逻辑</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 applicationStartup (步骤记录器)赋值给 context.</span></span><br><span class="line">    context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 context 做一些配置, 执行 initializers 的 initialize()</span></span><br><span class="line">    <span class="comment">// 发布 contextPrepared 事件</span></span><br><span class="line">    <span class="comment">// 关闭引导容器, 即发布 BootstrapContextClosedEvent 事件给之前加的 closeListener (监听者)</span></span><br><span class="line">    <span class="comment">// 使用 BeanDefinitionLoader 根据 sources 和 run 方法参数 primarySource 加载 BeanDefinition 到容器中.</span></span><br><span class="line">    <span class="comment">// 发布 contextLoaded 事件</span></span><br><span class="line">    prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个钩子, 当 JVM 关闭时, 相应的关闭 context, 然后调用容器的 refresh 方法(然后进入到 Spring 源码分析那段, 自行脑补)</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类扩展吧</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计时器停止计时, 接着打印计时数据</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 started 事件</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span></span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 发布 failed 事件</span></span><br><span class="line">    handleRunFailure(context, ex, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 发布 running 事件</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 发布 failed 事件</span></span><br><span class="line">    handleRunFailure(context, ex, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>温馨提示: 先在想看的地方打断点, 在打开调试模式, 可以清楚的看到对应的变量变化情况, 以此理解代码!</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来看看所有过程涉及方法的注释(大多数)</span></span><br><span class="line">org.springframework.boot.SpringApplication#createBootstrapContext</span><br><span class="line">    <span class="comment">// 1.创建一个引导容器(这个容器作用和 BeanFactory 类似, 但更简单得多, 仅有获取/注册 bean 对象等的功能)</span></span><br><span class="line">		<span class="comment">//   触发存于 this.bootstrappers 的对象的 intitialize 方法来对引导容器进行初始化(即可以在引导容器未使用前往里面注册 bean 对象)</span></span><br><span class="line">		<span class="comment">//   然后 this.bootstrappers 的数据有一部分是从 spring.factories 找 Bootstrapper 的类实例化后得到的, 然后也可以代码手动添加</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#getRunListeners</span><br><span class="line">    <span class="comment">// 扫描 spring.factories 中配置的实现了 SpringApplicationRunListener 的类, 并调用形如 types 的参数的构造函数来实例化得到对象集合</span></span><br><span class="line">		<span class="comment">//   再将这些对象集合放到 SpringApplicationRunListeners(其就是个容器管理类)中.</span></span><br><span class="line">		<span class="comment">// 并绑定 applicationStartup (步骤记录器)</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplicationRunListeners#doWithListeners(java.lang.String, java.util.function.Consumer&lt;org.springframework.boot.SpringApplicationRunListener&gt;, java.util.function.Consumer&lt;org.springframework.core.metrics.StartupStep&gt;)</span><br><span class="line">    <span class="comment">// 遍历持有的所有 SpringApplicationRunListener, 触发对应事件</span></span><br><span class="line">		<span class="comment">// 在触发监听事件前后加入 StartupStep 监听所耗时间</span></span><br><span class="line">		<span class="comment">// 步骤监听器的 accept 处理</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#prepareEnvironment</span><br><span class="line">    <span class="comment">// 1.根据 web 类型创建一个 environment 对象</span></span><br><span class="line">		<span class="comment">// 2.配置 environment</span></span><br><span class="line">		<span class="comment">//     通过 ConversionService 类添加一些类型转换支持(如文件大小1024k=1M等)</span></span><br><span class="line">		<span class="comment">//     将用户设置的 defaultProperties 添加到 environment 的 sources 中, 将 args 解析成一个 PropertySource 后加入到 environment 中</span></span><br><span class="line">		<span class="comment">// 3.为 environment 添加一个名为 configurationProperties 的源, 其作用是将每一个 PropertySource 适配成 ConfigurationPropertySource.</span></span><br><span class="line">		<span class="comment">// 4.触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件.</span></span><br><span class="line">		<span class="comment">// 5.将名为 defaultProperties 的 Property 源移最后(降低优先级), 另此 defaultProperties 不是 this.defaultProperties</span></span><br><span class="line">		<span class="comment">// 6.将用户通过代码设置的要附加的 profile 设置到 activeProfiles 中去 (若存在且 environment 中不存在)</span></span><br><span class="line">		<span class="comment">// 7.将 environment 中 spring.main 开头的配置数据, 一一对应绑定到 SpringApplication(即this)的字段上去</span></span><br><span class="line">		<span class="comment">// 8.若不开启自定义 environment, 则将 environment 转换成 StandardEnvironment(默认行为)</span></span><br><span class="line">		<span class="comment">// 9.由于上一步可能做了转换, 所以需要重新 attach 一次.</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#getOrCreateEnvironment</span><br><span class="line">    <span class="comment">// 1.若存在一个 environment, 则直接返回</span></span><br><span class="line">		<span class="comment">// 2.若不存在, 则根据之前推断得出的 webApplicationType 来创建对应的 Environment 对象.</span></span><br><span class="line">		<span class="comment">// 3.这几个不同的类型区别也不大, 就 StandardServletEnvironment 多了3个 propertySources(其中一个是 JDNI, 比较重要)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#configureEnvironment</span><br><span class="line">    <span class="comment">// 1.通过 ConversionService 类添加一些类型转换支持(如文件大小1024k=1M等)</span></span><br><span class="line">		<span class="comment">// 2.将用户设置的 defaultProperties 添加到 environment 的 sources 中, 将 args 解析成一个 PropertySource 后加入到 environment 中.</span></span><br><span class="line">		<span class="comment">// 3. configureProfiles 是一个空方法, 看来是留给我们实现子类时扩展的.</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.context.properties.source.ConfigurationPropertySources#attach</span><br><span class="line">    <span class="comment">// 为 environment 添加一个名为 configurationProperties 的源, 其作用是将每一个 PropertySource 适配成 ConfigurationPropertySource.</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#configureAdditionalProfiles</span><br><span class="line">    <span class="comment">// 将用户通过代码设置的要附加的 profile 设置到 activeProfiles 中去 (若存在且 environment 中不存在)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#bindToSpringApplication</span><br><span class="line">    <span class="comment">// 将 environment 中的配置数据, 绑定到 SpringApplication(即this)的一些字段上去</span></span><br><span class="line">		<span class="comment">// 绑定规则是 spring.main 开头的配置数据与 SpringApplication 一一对应, 如若存在 spring.main.banner-mode=OFF, 则 this.bannerMode=OFF</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#printBanner</span><br><span class="line">    <span class="comment">// 根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里</span></span><br><span class="line">		<span class="comment">//   this.banner 为文件路径, 若为空, 则打印 Spring Boot 默认准备的文本(这不换个佛祖保佑?)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#createApplicationContext</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 根据 web 类型创建不同的 ApplicationContext, 但其实差别不大, 就几个细节不同罢了</span></span><br><span class="line">		<span class="comment">// 以 AnnotationConfigServletWebServerApplicationContext 为例, 与 AnnotationConfigApplicationContext 的区别大致为</span></span><br><span class="line">		<span class="comment">//   多加了一个 BeanPostProcessor 用于给 ServletContextAware/ServletConfigAware 接口注入 servletContext/servletConfig 对象</span></span><br><span class="line">		<span class="comment">//   onRefresh() 时, 调用 createWebServer() 启动 tomcat/jetty/undertow</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#prepareContext</span><br><span class="line">    <span class="comment">// 1.设置 environment 对象</span></span><br><span class="line">		<span class="comment">// 2.将 beanNameGenerator 注册到容器中 (若存在), 配置容器的 resourceLoader 和 conversionService (从 SpringApplication 获取)</span></span><br><span class="line">		<span class="comment">// 3.将 initializers 根据 @Order 配置排序后, 遍历执行其 initialize 方法.</span></span><br><span class="line">		<span class="comment">// 4.发布 contextPrepared 事件</span></span><br><span class="line">		<span class="comment">// 5.关闭销毁引导容器(毕竟真正的容器已经准备好了, 这玩意就没用了)</span></span><br><span class="line">		<span class="comment">// 6.为容器添加一些特殊的 bean, 对 beanFactory 做点小设置; 然后添加一个懒加载功能的 BeanFactoryPostProcessor, 作用是将所有的 BeanDefinition 的 lazyInit 设置为 true</span></span><br><span class="line">		<span class="comment">// 7.创建一个 BeanDefinitionLoader, 解析 sources 得到 BeanDefinition 再注册到容器中. 和 Spring 的 new 容器时的 load 过程类似.</span></span><br><span class="line">		<span class="comment">// 8.发布 contextLoaded 事件</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#postProcessApplicationContext</span><br><span class="line">    <span class="comment">// 1.将 beanNameGenerator 注册到容器中 (若存在)</span></span><br><span class="line">		<span class="comment">// 2.将 SpringApplication 的 resourceLoader 赋值给容器 (若存在)</span></span><br><span class="line">		<span class="comment">// 3.为容器设置 ConversionService(类型转换工具)对象 (若配置了允许)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#load</span><br><span class="line">    <span class="comment">// 创建一个 BeanDefinitionLoader, 解析 sources 得到 BeanDefinition 再注册到容器中. 和 Spring 的 new 容器时的 load 过程类似.</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplication#refreshContext</span><br><span class="line">    <span class="comment">// 1.注册一个钩子, 当 JVM 关闭时, 相应的关闭 context</span></span><br><span class="line">		<span class="comment">// 2.调用容器的 refresh 方法</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#callRunners</span><br><span class="line">    <span class="comment">// 从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span></span><br><span class="line">		<span class="comment">// 这里有两个不同点</span></span><br><span class="line">		<span class="comment">//    1. XxxRunner 和 ApplicationListener 有何不同?</span></span><br><span class="line">		<span class="comment">//       答案是 XxxRunner 的 run 方法可以直接取到程序启动的 args 参数, 而监听器要取则还需借助 environment</span></span><br><span class="line">		<span class="comment">//    2.ApplicationRunner 和 CommandLineRunner 有何不同?</span></span><br><span class="line">		<span class="comment">//       答案是 run 方法接受的参数形式不同, 一个是 字符串数组(原始的), 一个是解析好的 key:value 方便直接取用.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>规矩我懂得, GitHub在这 <a href="https://github.com/gudqs7/spring-boot/tree/wq-comment" target="_blank" rel="noopener">注意分支哦</a> </p>
</blockquote>
<h2 id="各种实现的原理"><a href="#各种实现的原理" class="headerlink" title="各种实现的原理"></a>各种实现的原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.application.properties 是如何被加载到 Environment 中的?</span><br><span class="line">2.@ConfigurationProperties 如何实现自动注入`application.properties/application.yml`中配置的值?</span><br><span class="line">3.一些只需要改改依赖jar就可以切换(如tomcat-&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)</span><br><span class="line">4.JdbcTemplateAutoConfiguration如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)</span><br><span class="line">5.为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)</span><br></pre></td></tr></table></figure>



<h3 id="application-properties-是如何被加载到-Environment-中的"><a href="#application-properties-是如何被加载到-Environment-中的" class="headerlink" title="application.properties 是如何被加载到 Environment 中的?"></a>application.properties 是如何被加载到 Environment 中的?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1) run方法中创建了 Environment 对象, 当初始化好一些东西后会触发 environmentPrepared 事件</span><br><span class="line">2) 通过 SpringApplicationRunListener 的 EventPublishingRunListener 转发事件给 ApplicationListener 这类监听者, 即 EnvironmentPostProcessorApplicationListener.</span><br><span class="line">3) 这个类接收事件后, 遍历从 spring.factories 获得的 EnvironmentPostProcessor 对象, 执行其 postProcessEnvironment()</span><br><span class="line">4) 其中 ConfigFileApplicationListener<span class="comment">#postProcessEnvironment() 实现了配置文件的加载</span></span><br><span class="line">5) 具体为 postProcessEnvironment 下的 addPropertySources()</span><br><span class="line">6) 此方法将会扫描指定的路径下指定的某些文件</span><br><span class="line">7) 然后使用 spring.factories 下的 PropertySourceLoader 一一尝试解析</span><br><span class="line">8) 文件存在且解析正确则加入到 environment 的 sources 集合中.</span><br><span class="line">	某些路径: getSearchLocations() ,默认: classpath:/,classpath:/config/ ...</span><br><span class="line">	某些文件: getSearchNames() ,默认: application</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS: </span></span><br><span class="line">PropertySourceLoader 有 PropertiesPropertySourceLoader/YamlPropertySourceLoader</span><br><span class="line">一个尝试后缀有 xml/properties, 另一个是 yml/yaml, 因为是遍历后 load, 所以所有可能性有:</span><br><span class="line">    classpath:/application.xml; classpath:/application.properties</span><br><span class="line">	classpath:/application.yml; classpath:/application.yaml</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>



<h3 id="ConfigurationProperties-如何实现自动注入application-properties-application-yml中配置的值"><a href="#ConfigurationProperties-如何实现自动注入application-properties-application-yml中配置的值" class="headerlink" title="@ConfigurationProperties 如何实现自动注入application.properties/application.yml中配置的值?"></a>@ConfigurationProperties 如何实现自动注入<code>application.properties/application.yml</code>中配置的值?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) 首先加了 @EnableConfigurationProperties 也会解析里面的 @Import </span><br><span class="line">2) @Import 则引入了 EnableConfigurationPropertiesRegistrar.class</span><br><span class="line">3) 这是一个 ImportBeanDefinitionRegistrar 的实现类, 因此调用指定方法 registerBeanDefinitions</span><br><span class="line">4) 指定方法 registerBeanDefinitions() 会将 @EnableConfigurationProperties 注解的值对应的类注册到容器中, 如 @EnableConfigurationProperties(RabbitProperties.class) 则会加载 RabbitProperties.class</span><br><span class="line">5) 指定方法还注册了一些工具 bean 和一个重要的 BeanPostProcessor 在 registerInfrastructureBeans()中</span><br><span class="line">6) 即 ConfigurationPropertiesBindingPostProcessor, 当我们要使用配置文件 bean(如 RabbitProperties)时,会实例化 bean 并触发 postProcessorBeforeInitialization()</span><br><span class="line">7) 在 postProcessorBeforeInitialization() 中, 通过 org.springframework.boot.context.properties.ConfigurationPropertiesBinder<span class="comment">#bind() 来完成实际的绑定</span></span><br><span class="line">8) 其本质就是 Binder 的 <span class="built_in">bind</span> 方法, 设定配置文件前缀即可将配置文件中的配置对应的绑定到 bean(如 rabbitProperties 对象) 中.</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS</span></span><br><span class="line">这里的 Binder 和 SpringApplication 里绑定 spring.main 开头配置文件那个类是同一个.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">就是先将 XxxProperties 类注册到容器中, 这样就可以通过 BeanPostProcessor 再实例化后将配置文件与属性绑定.</span><br></pre></td></tr></table></figure>



<h3 id="一些只需要改改依赖jar就可以切换-如tomcat–-gt-undertow-是怎么做到的-ConditionalXxx-的实现原理"><a href="#一些只需要改改依赖jar就可以切换-如tomcat–-gt-undertow-是怎么做到的-ConditionalXxx-的实现原理" class="headerlink" title="一些只需要改改依赖jar就可以切换(如tomcat–&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)"></a>一些只需要改改依赖jar就可以切换(如tomcat–&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1) 在类上加上注解 @Conditional 或带有 @Conditional 的其他注解(即注解的子类亦会扫描)</span><br><span class="line">2) 在所有的扫描类和注解的地方,如解析@Configuration, AnotatedBeanDefinitionReader 等 reader</span><br><span class="line">    会使用 ConditionEvaluator 的 shouldSkip() 判断是否可以加载, 时机点如下</span><br><span class="line">    AnnotatedBeanDefinitionReader<span class="comment">#doRegisterBean() 的第二行代码</span></span><br><span class="line">    ConfigurationClassBeanDefinitionReader<span class="comment">#loadBeanDefinitionsForBeanMethod() 第四行</span></span><br><span class="line">    ConfigurationClassBeanDefinitionReader<span class="comment">#loadBeanDefinitionsForConfigurationClass()</span></span><br><span class="line">    ConfigurationClassParser<span class="comment">#doProcessConfigurationClass() 处理 ComponentScan 那段</span></span><br><span class="line">3) 然后再 shouldSkip 中判断， 判断逻辑大致如下：</span><br><span class="line">    先遍历所有注解取得所有的 @Conditional 的 value, 这个 value 是具体的 Condition 实现, 如 OnClassCondition(实现了 Condition 的 matches 接口, 很多抽象类用以增强代码扩展性), 然后其加入到 conditions 中, 排序后遍历调用 matches(), 一个不匹配则返回 <span class="literal">true</span>, 代表应该跳过.</span><br><span class="line"></span><br><span class="line"><span class="comment"># TIPS:</span></span><br><span class="line">ConditionOutcome 封装了是否匹配和匹配日志信息[为啥成功/为啥失败]</span><br><span class="line">SpringBootCondition 提供了通用的根据 ConditionOutcome 判断是否匹配并记录日志信息的抽象类.</span><br><span class="line">    子类只需实现 getMatchOutcome(): 根据 metadata[注解信息] 返回 ConditionOutcome 对象.</span><br><span class="line">    因此, 如果我们要实现自己的 Condition, 可以继承它.</span><br></pre></td></tr></table></figure>



<h3 id="JdbcTemplateAutoConfiguration-如何确保能够获取到-DataSource-AutoConfigureAfter-的实现原理"><a href="#JdbcTemplateAutoConfiguration-如何确保能够获取到-DataSource-AutoConfigureAfter-的实现原理" class="headerlink" title="JdbcTemplateAutoConfiguration 如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)"></a>JdbcTemplateAutoConfiguration 如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1) 首先所有的 XxxAutoConfiguration 都是借助 AutoConfigurationImportSelector 加载的, 其继承了 DeferredImportSelector.  </span><br><span class="line">2) 这种 DeferredImportSelector 会延迟加载, 原理是 parse 后再加载, 而非 parse 执行过程中就加载.</span><br><span class="line">3) 延迟加载机制 会先调用 process 方法, 将要加载的 class 保存起来, 然后再调用 selectImports 返回.</span><br><span class="line">4) 此时 AutoConfigurationImportSelector.AutoConfigurationGroup 的 selectImports() 会调用 sortAutoConfigurations(), 也就是调用了 AutoConfigurationSorter.getInPriorityOrder()</span><br><span class="line">5) getInPriorityOrder() 调用了 sortByAnnotation() 这个方法根据2个注解 @AutoConfigureBefore/@AutoConfigureAfter 排序.</span><br><span class="line">6) 最后返回的就是有序的了. 另外, 这两个注解只能作用在 spring.factories 中 EnableAutoConfiguration 的类上才有效.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结:</span></span><br><span class="line">利用 DeferredImportSelector 的延迟加载, 将所有的 AutoConfiguration 所引入的 class 先存起来不加载, 然后又加入排序的逻辑, 使得真正加载时会根据排序结果依次加载.</span><br></pre></td></tr></table></figure>



<h3 id="为什么-Spring-Boot-启动-main-方法就能访问-Tomcat-SpringApplication-run-启动-tomcat-实现原理"><a href="#为什么-Spring-Boot-启动-main-方法就能访问-Tomcat-SpringApplication-run-启动-tomcat-实现原理" class="headerlink" title="为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)"></a>为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) main 方法会调用 SpringApplication 的 run 方法, 里面会创建 applicationContext, 如是 webApplicationType = SERVLET, 则实现类为 AnnotationConfigServletWebServerApplicationContext</span><br><span class="line">    另外一提, webApplicationType 是根据 classpath 下是否有哪些类来推断的.</span><br><span class="line">2) 这个类继承了 ServletWebServerApplicationContext</span><br><span class="line">3) ServletWebServerApplicationContext 实现了 onRefresh()</span><br><span class="line">4) onRefresh() 调用了 createWebServer()</span><br><span class="line">5) createWebServer() 使用 ServletWebServerFactory.getWebServer() 获取 webServer 对象</span><br><span class="line">6) ServletWebServerFactory 的具体实现类由 ServletWebServerFactoryAutoConfiguration 引入</span><br><span class="line">    详细见 ServletWebServerFactoryConfiguration.EmbeddedTomcat.class</span><br><span class="line">7) 引入后调用 getWebServer(), 大概为 new Tomcat(), 绑定配置文件到 Tomcat 的一些属性上, 然后启动它.</span><br><span class="line">8) 至此, run() 启动了 tomcat/jetty/undertow.</span><br><span class="line"> </span><br><span class="line"><span class="comment"># TIPS:</span></span><br><span class="line">Spring 使用工厂模式获取不同的 webServer, 而不同的 webServer 实现类其实是用 XxxAutoConfiguration 来自动注入的(还可以配合 @Conditional 决定何时加载).</span><br><span class="line">这样如果新增一种 webServer, 只需要在写一个 XxxAutoConfiguration 注册一个 webServer 实现类的 bean 即可, 非常灵活(非常 nice).</span><br></pre></td></tr></table></figure>





<h2 id="常见的-XxxAutoConfiguration"><a href="#常见的-XxxAutoConfiguration" class="headerlink" title="常见的 XxxAutoConfiguration"></a>常见的 XxxAutoConfiguration</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.连接池</span><br><span class="line">   DataSourceAutoConfiguration 会 Import DataSourceConfiguration.Hikari.class</span><br><span class="line">2.Mybatis</span><br><span class="line">   MybatisAutoConfiguration: 注册并配置了 SqlSessionFactory/SqlSessionTemplate</span><br><span class="line">3.Spring MVC</span><br><span class="line">   DispatcherServletAutoConfiguration: 配置前端控制器和文件上传处理器</span><br><span class="line">   ServletWebServerFactoryAutoConfiguration: 注册 WebServerFactory 的实现类 bean</span><br><span class="line">4.RocketMQ</span><br><span class="line">   RabbitAutoConfiguration: 注册并配置 RabbitTemplate</span><br><span class="line">5.Redis</span><br><span class="line">   RedisAutoConfiguration: 注册并配置 RedisTemplate/StringRedisTemplate</span><br><span class="line">6.邮件发送</span><br><span class="line">   MailSenderAutoConfiguration: 注册并配置 JavaMailSenderImpl</span><br><span class="line">7.MyBatis-Plus</span><br><span class="line">   MybatisPlusAutoConfiguration: 注册 SqlSessionFactory, 并配置了其 plugins, 使 Mybatis-Plus 生效</span><br><span class="line">8.定时任务</span><br><span class="line">   TaskSchedulingAutoConfiguration: 注册 ThreadPoolTaskScheduler</span><br><span class="line">9.AOP</span><br><span class="line">   AopAutoConfiguration: 通过静态内部类加载了 @EnableAspectJAutoProxy</span><br></pre></td></tr></table></figure>



<h2 id="我所见到的设计模式"><a href="#我所见到的设计模式" class="headerlink" title="我所见到的设计模式"></a>我所见到的设计模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.适配器模式: SpringConfigurationPropertySources</span><br><span class="line">    要将 Iterable&lt;PropertySource&lt;?&gt;&gt;</span><br><span class="line">    适配成 Iterable&lt;ConfigurationPropertySource&gt;</span><br><span class="line">    也即是 PropertySource --&gt; ConfigurationPropertySource</span><br><span class="line">  <span class="comment">#其实主要工作是: ConfigurationPropertySource#getConfigurationProperty() 里面调用了 PropertySource#getProperty(), 以此完成适配... 很适配器模式, 存一个未适配的对象, 在适配的方法中调用存储的对象的要适配的方法. </span></span><br><span class="line">  </span><br><span class="line">2.简单工厂模式: org.springframework.boot.ApplicationContextFactory<span class="comment">#create</span></span><br><span class="line">    根据 webApplicationType 创建不同的 ConfigurableApplicationContext</span><br><span class="line">  </span><br><span class="line">3.观察者模式: </span><br><span class="line">	监听者: SpringApplicationRunListener</span><br><span class="line">  观察对象: SpringApplication 的生命周期(starting/environmentPrepared/contextPrepared/contextLoaded/started/running/failed)</span><br><span class="line">  管理者: SpringApplicationRunListeners, 负责遍历监听者广播对应事件</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gudqs7"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">gudqs7</p>
  <div class="site-description" itemprop="description">心累没钱躺尸中</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gudqs7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gudqs7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gudqs7@gmail.com" title="E-Mail → mailto:gudqs7@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gudqs7</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gudqs7s-note.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
