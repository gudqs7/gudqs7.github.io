<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gudqs7.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="心累没钱躺尸中">
<meta property="og:type" content="website">
<meta property="og:title" content="gudqs7&#39;s note">
<meta property="og:url" content="https://gudqs7.github.io/index.html">
<meta property="og:site_name" content="gudqs7&#39;s note">
<meta property="og:description" content="心累没钱躺尸中">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="gudqs7">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gudqs7.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>gudqs7's note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gudqs7's note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">心累没钱躺尸中</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/23/source-code-spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/23/source-code-spring/" class="post-title-link" itemprop="url">Spring 源码笔记</a>
        </h2>

        <div class="post-meta">
			
				<i class="fa fa-thumb-tack"></i>
				<font color="RED">置顶</font>
				<span class="post-meta-divider">|</span>
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-23 18:28:28" itemprop="dateCreated datePublished" datetime="2021-01-23T18:28:28+08:00">2021-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:49:05" itemprop="dateModified" datetime="2021-03-28T19:49:05+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/23/source-code-spring/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/23/source-code-spring/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring源码分析"><a href="#Spring源码分析" class="headerlink" title="Spring源码分析"></a>Spring源码分析</h1><h2 id="关键类介绍"><a href="#关键类介绍" class="headerlink" title="关键类介绍"></a>关键类介绍</h2><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">万能的 applicationContext, 但实际上各种能力都是依赖于其他的类, 比如 getBean 是 beanFactory 的, publishEvent 是事件广播器的, 等等. 其本身是一个综合体, 整合这些能力, 便于开发者调用和理解.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面列一下相关的接口, 抽象类, 和具体类</span></span><br><span class="line">ApplicationContext</span><br><span class="line">	是一个只读的 bean 容器</span><br><span class="line">	可以加载解析配置文件(如xml)</span><br><span class="line">	可以发布事件和注册监听</span><br><span class="line">	具有国际化消息处理能力</span><br><span class="line">ConfigurableApplicationContext</span><br><span class="line">	是一个具有可配置能力的 容器(可设置各个参数, 如id, 父容器)</span><br><span class="line">	具有容器生命周期概念, 如启动,停止,关闭.</span><br><span class="line">AbstractApplicationContext</span><br><span class="line">	模板方法模式的抽象类, 定义了容器的模板(refresh方法), 但由具体的子类实现部分方法</span><br><span class="line">	管理Bean和BeanFactory的PostProcessor</span><br><span class="line">	管理事件的监听和处理</span><br><span class="line">AbstractRefreshableApplicationContext</span><br><span class="line">	为可重复刷新的容器提供基类</span><br><span class="line">	加入了BeanFactory的管理(创建/关闭等)</span><br><span class="line">AbstractRefreshableConfigApplicationContext</span><br><span class="line">	加入了configLocation字段, 用于某些容器初始化BeanFactory和Bean</span><br><span class="line">AbstractXmlApplicationContext</span><br><span class="line">	定义了读取xml配置文件来加载BeanFactory的代码, 使得子类只需提供配置文件地址或Resource</span><br><span class="line">ClassPathXmlApplicationContext</span><br><span class="line">	继承基类, 提供配置文件地址的构造方法, 调用refresh加载BeanFactory</span><br></pre></td></tr></table></figure>

<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">1.核心中的核心, 加载和管理 beanDefinitions(Bean配置信息), 创建和管理 bean 对象实例, 注册和管理 BeanPostProcessor(Bean扩展)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面列一下相关的接口, 抽象类, 和具体类</span></span><br><span class="line">BeanFactory</span><br><span class="line">  定义了 Bean 的基础操作接口, 如 getBean, getType, isSingleton 等</span><br><span class="line"></span><br><span class="line">SingletonBeanRegistry</span><br><span class="line">  定义了单例对象的操作接口 (注册/获取/是否已存在) </span><br><span class="line"></span><br><span class="line">HierarchicalBeanFactory</span><br><span class="line">  定义了父 BeanFactory 的相关操作接口(获取)</span><br><span class="line"></span><br><span class="line">ConfigurableBeanFactory</span><br><span class="line">  定义了对 BeanFactory 做各种配置的操作接口, 包括 BeanPostProcessor, setParentBeanFactory, destroyBean, registerAlias, resolveAliases 等</span><br><span class="line"></span><br><span class="line">DefaultSingletonBeanRegistry</span><br><span class="line">  实现了 SingletonBeanRegistry 接口, 即实现了单例对象的缓存管理, 包括一级/二级/三级(二级三级只依赖循环用上的两个缓存)</span><br><span class="line">  </span><br><span class="line">FactoryBeanRegistrySupport</span><br><span class="line">  继承了 DefaultSingletonBeanRegistry</span><br><span class="line">	实现对使用 FactoryBean 存储和获取 bean 对象实例方式的支持</span><br><span class="line">	</span><br><span class="line">AbstractBeanFactory</span><br><span class="line">  继承了 FactoryBeanRegistrySupport</span><br><span class="line">  实现了 BeanFactory/HierarchicalBeanFactory/ConfigurableBeanFactory 定义的接口</span><br><span class="line">  实现了具体 getBean, 包括缓存管理等</span><br><span class="line">  </span><br><span class="line">AutowireCapableBeanFactory</span><br><span class="line">  定义了根据 class 类型获取 BeanDefinition 信息以及 Bean 对象的接口</span><br><span class="line"></span><br><span class="line">AbstractAutowireCapableBeanFactory</span><br><span class="line">  继承自 AbstractBeanFactory </span><br><span class="line">  实现了 AutowireCapableBeanFactory 中定义的方法(就是实现了根据 class 获取 bean 或 BeanDefinition)</span><br><span class="line">  实现了 createBean, 也就是真正的实例化一个对象的过程, 包括实例化, 为需要赋值的字段注入相应的值</span><br><span class="line">  同时触发了 BeanPostProcessor 的方法调用</span><br><span class="line">  </span><br><span class="line">BeanDefinitionRegistry</span><br><span class="line">  定义了 BeanDefinition 的注册/获取/移除</span><br><span class="line">  </span><br><span class="line">ListableBeanFactory</span><br><span class="line">	定义了 BeanDefinition 的可遍历性</span><br><span class="line">  </span><br><span class="line">ConfigurableListableBeanFactory</span><br><span class="line">  结合 ListableBeanFactory 和 ConfigurableBeanFactory 并补充完善了几个相关接口 (如 getBeanNamesIterator 接口 )</span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory</span><br><span class="line">  继承了 AbstractAutowireCapableBeanFactory</span><br><span class="line">  实现了 BeanDefinitionRegistry/ConfigurableListableBeanFactory 的接口</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 总结:</span></span><br><span class="line">定义处:</span><br><span class="line">BeanFactory(getBean)</span><br><span class="line">SingletonBeanRegistry(addSingleton)</span><br><span class="line">HierarchicalBeanFactory(getParentBeanFactory)</span><br><span class="line">ConfigurableBeanFactory(addBeanPostProcessor)</span><br><span class="line">AutowireCapableBeanFactory(autowireBean)</span><br><span class="line">BeanDefinitionRegistry(registerBeanDefinition)</span><br><span class="line">ListableBeanFactory(getBeanDefinitionNames)</span><br><span class="line">ConfigurableListableBeanFactory(getBeanNamesIterator)</span><br><span class="line"></span><br><span class="line">实现处:</span><br><span class="line">DefaultSingletonBeanRegistry(registerSingleton)</span><br><span class="line">FactoryBeanRegistrySupport(getObjectFromFactoryBean)</span><br><span class="line">AbstractBeanFactory(doGetBean)</span><br><span class="line">AbstractAutowireCapableBeanFactory(createBean)</span><br><span class="line">DefaultListableBeanFactory(registerBeanDefinition)</span><br></pre></td></tr></table></figure>





<h2 id="容器初始化过程"><a href="#容器初始化过程" class="headerlink" title="容器初始化过程"></a>容器初始化过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.setParent(): 处理父容器 </span><br><span class="line">2.setConfigLocations(): 解析并设置xml配置文件路径</span><br><span class="line">3.refresh(): 创建 beanFactory 对象并初始化, 读取 xml 配置文件得到 beanDefinitions, 接着处理两种 PostProcessor, 然后添加国际化处理器和事件广播器以及相应的初始化和一些处理, 最后实例化单例的 bean 等等.</span><br><span class="line"></span><br><span class="line"><span class="comment">#外圈结束, 再看 refresh() 里面的每个方法</span></span><br><span class="line">1.prepareRefresh(): 准备工作, 一些字段值的设置和处理.</span><br><span class="line">2.obtainFreshBeanFactory(): 创建一个 beanFactory 对象并注册到 applicationContext (即赋值到字段上), 然后解析 xml 配置文件(或注解配置)的信息, 解析得到 beanDefinitions 并注册到容器中.</span><br><span class="line">3.然后是一些对 beanFactory 对象的完善配置的代码</span><br><span class="line">4.扫描并执行 BeanFactoryPostProcessor(其作用是为beanFactory对象添加东西提供扩展性), 其中我认识的就只有 ConfigurationClassPostProcessor(这个类作用就是解析 @Configuration/@Component/@Import/@ImportSource/@ComponentScan等基础注解).</span><br><span class="line">5.扫描实现了 BeanPostProcessor 接口的 bean 并注册到 beanFactory 中存起来, 等 createBean 创建对象时会在对应的时机执行一些对应的方法(钩子). 常见的各种 XxxAware 就是靠这个实现的咯.</span><br><span class="line">6.接着, 初始化国际化资源处理器, 事件广播器, 并注册一些需要注册的事件(也注册容器内实现对应接口的 bean)</span><br><span class="line">7.处理一些 beanFactory 的配置, 接着为所有单例且非懒加载的(不就是默认策略嘛) bean 创建实例, 缓存起来.</span><br><span class="line">8.广播容器加载完成了的事件. 以及处理生命周期.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后总结下, 先创建容器, 再将根据配置文件解析得到 BeanDefinition 注册到容器中, 然后处理两大扩展(BeanFactoryPostProcessor/BeanPostProcessor), 接着是Spring的国际化, 以及相当有用的事件广播器, 最后实例化 bean. 整体感觉其实很简单, 但其实有大量的工作交给了 BeanPostProcessor.</p>
</blockquote>
<h3 id="超长源码分析过程"><a href="#超长源码分析过程" class="headerlink" title="超长源码分析过程"></a>超长源码分析过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先随便写个 main 方法, 如我写的, 可测试依赖循环问题和事件监听:</span></span><br><span class="line"><span class="comment">// 包名: cn.gudqs7.spring.tests, 改动则需同步修改xml哦</span></span><br><span class="line"><span class="comment">// 进入对应类代码: 快捷键 Cmd+Option+鼠标点击 (或 Ctrl+Alt+鼠标左键 ); 如果是接口松开 Option(或Alt)键</span></span><br><span class="line"></span><br><span class="line">Test.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ApplicationContext xmlContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application-wq.xml"</span>);</span><br><span class="line">		UserServiceImpl userService = xmlContext.getBean(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		userService.sayHi();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">application-wq.xml</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> <span class="keyword">default</span>-autowire=<span class="string">"byName"</span>&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean name=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.gudqs7.spring.tests.UserServiceImpl"</span>&gt;</span><br><span class="line">		&lt;property name="starter"&gt;&lt;ref bean="serverStarter"/&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;bean name=<span class="string">"serverStarter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.gudqs7.spring.tests.ServerStarter"</span>&gt;</span><br><span class="line">		&lt;property name="userService"&gt;&lt;ref bean="userService"/&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">UserServiceImpl.java</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> ServerStarter starter;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(starter);</span><br><span class="line">		System.out.println(<span class="string">"Hello Spring!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStarter</span><span class="params">(ServerStarter starter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.starter = starter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ServerStarter.java</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStarter</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Inject</span></span><br><span class="line">	<span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">		String applicationName = event.getApplicationContext().getApplicationName();</span><br><span class="line">		System.out.println(applicationName);</span><br><span class="line">		System.out.println(userService);</span><br><span class="line">		System.out.println(<span class="string">"========== started by gudqs7 =============="</span>);</span><br><span class="line">		System.out.println(<span class="string">"========== started by gudqs7 =============="</span>);</span><br><span class="line">		System.out.println(<span class="string">"========== started by gudqs7 =============="</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserServiceImpl userService)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userService = userService;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接下来, 进入ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String) 方法中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其跳转到了</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为容器的 parent 字段赋值, 若 parent 不为空, 且有 ConfigurableEnvironment, 则合并数据(将父容器有的加到子容器中)</span></span><br><span class="line">		<span class="comment">// 即执行了 org.springframework.context.support.AbstractApplicationContext.setParent()</span></span><br><span class="line">		<span class="keyword">super</span>(parent);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为 configLocations 字段赋值(告知配置文件位置), 赋值前会根据环境变量解析(此时环境变量中只有系统环境变量: 如JAVA_HOME).</span></span><br><span class="line">		setConfigLocations(configLocations);</span><br><span class="line">		<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">			<span class="comment">// 注释在下面</span></span><br><span class="line">      refresh();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后具体的看 refresh 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="comment">// 1.设置容器初始的一些属性(时间,状态)，初始化占位符数据源并校验所有 bean 所使用的占位符是否存在, 清空事件和监听</span></span><br><span class="line">		<span class="comment">// 2.清空重置旧的 beanFactory, 再创建新的 beanFactory 并通过解析 xml或注解 加载 beanDefinitions</span></span><br><span class="line">		<span class="comment">// 3.设置了一些 beanFactory 的属性, 添加了几个有用的 BeanPostProcessor, 还添加了几个 bean 到容器中(都是环境相关的 bean)</span></span><br><span class="line">		<span class="comment">// 4.子类对beanFactory 添加自己的特殊的 BeanPostProcessor (如servletContxt/servletConfig注入)</span></span><br><span class="line">		<span class="comment">// 5.扫描容器中实现了 BeanFactoryPostProcessor 接口的 bean 将其注册到 beanFactory 中并执行</span></span><br><span class="line">		<span class="comment">// 6.扫描容器中实现了 BeanPostProcessor 接口的 bean 将其注册到 beanFactory 但不执行(实例化 bean 对象那会有几个执行时机)</span></span><br><span class="line">		<span class="comment">// 7.创建一个国际化资源解析器并注册到 beanFactory; 创建一个事件广播器并注册到 beanFactory.</span></span><br><span class="line">		<span class="comment">// 8.调用子类的其他刷新时需要做的事情(模板方法)</span></span><br><span class="line">		<span class="comment">// 9.扫描容器中实现了 ApplicationListener 接口的 bean, 将其预存到广播器中但不执行</span></span><br><span class="line">		<span class="comment">//10.完成 beanFactory 的一些配置(包括终结一些东西, 如 setTempClassLoader(null) ); 将单例的 bean 创建出来放入容器中(未设置lazy-init=true)的 bean</span></span><br><span class="line">		<span class="comment">//11.广播 ContextRefreshedEvent 事件， 初始化LifeCycleProcessor及调用其 onRefresh 方法.</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			<span class="comment">// 设置容器初始的一些属性(时间,状态)，初始化占位符数据源并校验所有 bean 所使用的占位符是否存在, 清空事件和监听</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			<span class="comment">// 清空重置旧的 beanFactory, 再创建新的 beanFactory 并解析 xml或注解 加载 beanDefinitions</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			<span class="comment">// 设置了一些 beanFactory 的属性, 添加了几个有用的 BeanPostProcessor, 还添加了几个 bean 到容器中(都是环境相关的 bean)</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				<span class="comment">// 子类对beanFactory 添加自己的特殊的 BeanPostProcessor (如servletContxt/servletConfig注入)</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				<span class="comment">// 扫描容器中实现了 BeanFactoryPostProcessor 接口的 bean 将其注册到 beanFactory 中并执行</span></span><br><span class="line">				<span class="comment">//   扫描6次, 2(BeanDefinitionRegistry/BeanFactory) x 3(优先级:高/中/其他)</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				<span class="comment">// 扫描容器中实现了 BeanPostProcessor 接口的 bean 将其注册到 beanFactory 但不执行; 扫描6次: 2(MergedBeanDefinitionPostProcessor/其他) x 3(优先级: 高/中/其他)</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				<span class="comment">// 创建一个国际化资源解析器并注册到 beanFactory.</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				<span class="comment">// 创建一个事件广播器并注册到 beanFactory.</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				<span class="comment">// 调用子类的其他刷新时需要做的事情(模板方法)</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				<span class="comment">// 将可能存在的 applicationListeners 注册到事件广播器中(新建时是不存在的),</span></span><br><span class="line">				<span class="comment">// 然后扫描容器中实现了 ApplicationListener 接口的 bean, 将其预存到广播器中但不执行</span></span><br><span class="line">				<span class="comment">// 将之前 publishEvent() 想广播的事件广播出去, 然后字段 earlyApplicationEvents 赋值为空(代表之后可立即广播)</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				<span class="comment">// 完成 beanFactory 的一些配置(包括终结一些东西, 如 setTempClassLoader(null) )</span></span><br><span class="line">				<span class="comment">// 注册默认的表达式解析器(若无相应的bean存在)</span></span><br><span class="line">				<span class="comment">// 扫描容器中实现了 LoadTimeWeaverAware 接口的 bean, 并触发(getBean)之前注册过的 BeanPostProcessor</span></span><br><span class="line">				<span class="comment">// 将单例的 bean 创建出来放入容器中(未设置lazy-init=true)的 bean</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				<span class="comment">// 广播 ContextRefreshedEvent 事件， 初始化LifeCycleProcessor及调用其 onRefresh 方法.</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">							<span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				<span class="comment">// 销毁缓存的单例对象</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">				<span class="comment">// 变更状态</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				<span class="comment">// 清空公共工具产生的缓存(内存松一口气).</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我错了, 代码都放上去不如给个GitHub地址, 接下来省略代码吧, 只放注释😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挨个看里面的方法</span></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#prepareRefresh</span><br><span class="line">    <span class="comment">// 1.设置容器初始的一些属性, 如启动时间, 当前状态</span></span><br><span class="line">		<span class="comment">// 2.打印开始日志</span></span><br><span class="line">		<span class="comment">// 3.初始化占位符数据源</span></span><br><span class="line">		<span class="comment">// 4.校验所有 bean 所使用的占位符是否存在</span></span><br><span class="line">		<span class="comment">// 5.清空事件和监听</span></span><br><span class="line">		<span class="comment">// Switch to active.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</span><br><span class="line">    <span class="comment">// 1.存在旧的则先摧毁 bean 对象实例及缓存数据, 再将旧的置为 null</span></span><br><span class="line">		<span class="comment">// 2.创建一个新的 beanFactory 对象, 再设置 id及一些配置</span></span><br><span class="line">		<span class="comment">// 3.扫描并加载 beanDefinations</span></span><br><span class="line">		<span class="comment">// 4.设置这个新的 beanFactory 对象为 applicationContext 的 beanFactory 字段值.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</span><br><span class="line">    <span class="comment">// 1.设置 beanFactory 的类加载器</span></span><br><span class="line">		<span class="comment">// 2.设置 beanFactory 的表达式解析器</span></span><br><span class="line">		<span class="comment">// 3.1:注册一个 BeanPostProcessor 用于将实现了ApplicationContext能力相关的Aware接口的 bean, 触发赋值setter 注入 applicationContext 对象</span></span><br><span class="line">		<span class="comment">// 3.2:设置 beanFactory 处理 bean 时要忽略的接口(主要是setter注入时忽视一些也是setter的方法, 因为这些方法会由 PostProcessor 来触发)</span></span><br><span class="line">		<span class="comment">// 4.注册一些特殊的 bean(注入这些bean时会注入 this 对象: 多功能工具人 ApplicationContext, 可见其和普通 bean 的注册方式不一样)</span></span><br><span class="line">		<span class="comment">// 5.注册一个 BeanPostProcessor 用于检测加载的 bean 是否实现了 ApplicationListener 接口, 若是, 则注册到事件广播器中(不是,是暂存在applicationListeners字段中, 等事件广播器创建后才注册)</span></span><br><span class="line">		<span class="comment">// 6.注册一个 BeanPostProcessor 用于触发实现了 LoadTimeWeaverAware 接口的 bean 的 setLoadTimeWeaver() 社会 LTW 实例.</span></span><br><span class="line">		<span class="comment">// 7.注册几个环境相关 bean 到容器中(Spring的环境对象, 以及系统环境变量和系统配置文件)</span></span><br><span class="line"></span><br><span class="line">org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</span><br><span class="line">    <span class="comment">// 1.若 beanFactory 实现了 BeanDefinitionRegistry 接口(new AnnotationConfigApplicationContext 就实现了)</span></span><br><span class="line">		<span class="comment">//    则扫描所有实现了 BeanDefinitionRegistryPostProcessor 接口的 bean, 根据优先级分三类(高/中/其他)依次执行</span></span><br><span class="line">		<span class="comment">// 2.然后扫描所有实现了 BeanFactoryPostProcessor 接口的 bean, 依旧是根据优先级分三类依次执行.</span></span><br><span class="line">		<span class="comment">// 3.每次执行前都会根据 Order 信息排序, 再遍历执行</span></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)</span><br><span class="line">    <span class="comment">// 1.扫描6次: 2(MergedBeanDefinitionPostProcessor/其他) x 3(优先级: 高/中/其他)</span></span><br><span class="line">		<span class="comment">//    将其加入到 beanFactory 的 beanPostProcessors 集合中</span></span><br><span class="line">		<span class="comment">// 2.再次加入 ApplicationListenerDetector (用于处理实现 ApplicationListener 的 bean 注册到事件广播器), 主要是使其在链末尾, 可以最后执行.</span></span><br><span class="line"></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#registerListeners</span><br><span class="line">    <span class="comment">// 1.将可能存在的 applicationListeners 注册到事件广播器中(新建时是不存在的)</span></span><br><span class="line">		<span class="comment">// 2.扫描容器中实现了 ApplicationListener 接口的 bean, 将其预存到广播器中但不执行</span></span><br><span class="line">		<span class="comment">// 3.将之前 publishEvent() 想广播的事件广播出去, 然后字段 earlyApplicationEvents 赋值为空</span></span><br><span class="line">		<span class="comment">//    (因为 publishEvent() 中根据是否为空判断立刻执行或先存着) (另这也解释了 prepareRefresh() 中为何要赋值一个空集合)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</span><br><span class="line">    <span class="comment">// 1.完成 beanFactory 的一些配置</span></span><br><span class="line">		<span class="comment">// 2.注册默认的表达式解析器(若无相应的bean存在)</span></span><br><span class="line">		<span class="comment">// 3.扫描容器中实现了 LoadTimeWeaverAware 接口的 bean, 并触发(getBean)之前注册过的 BeanPostProcessor</span></span><br><span class="line">		<span class="comment">// 4.将单例的 bean 创建出来放入容器中(未设置lazy-init=true)的 bean</span></span><br><span class="line"></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#finishRefresh</span><br><span class="line">    <span class="comment">// 1.清空资源缓存</span></span><br><span class="line">		<span class="comment">// 2.创建一个生命周期管理器(start, refresh, stop等)并注册到 beanFactory</span></span><br><span class="line">		<span class="comment">// 3.触发生命周期管理器的 onRefresh()</span></span><br><span class="line">		<span class="comment">// 4.广播容器刷新完成的事件</span></span><br><span class="line">		<span class="comment">// 5.为 Spring Tool Suite 提供某些便捷(没用过, 不知道...)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可算复制完了, 如果你有幸直接跳读到这里, 那么送上地址 : <a href="https://github.com/gudqs7/spring-framework/tree/wq-comment" target="_blank" rel="noopener">注意分支吧</a> </p>
<p>另外上面方法前带个 <strong>#</strong> 的, 复制到 IDEA 双击 Shift 然后粘贴, 选择 Symbols 搜索更准确呢!</p>
</blockquote>
<h2 id="获取容器对象过程"><a href="#获取容器对象过程" class="headerlink" title="获取容器对象过程"></a>获取容器对象过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从getBean(Class type) 中进入</span></span><br><span class="line">1.检查 applicationContext 和 beanFactory 的状态, 若有异常则给出准确的错误.</span><br><span class="line">2.扫描容器中所有此 <span class="built_in">type</span> 的 beanName, 遍历判断每个 beanName 是否可用</span><br><span class="line">   可用则判断可用的个数是否刚好是一个, 是则直接调用 getBean() 返回对象实例</span><br><span class="line">   若可用的个数超过一个, 则根据 beanDefinition 的 isPrimary 和对比配置的优先级是否为有最高的再返回最高的</span><br><span class="line">   若都不行, 则报错.</span><br><span class="line">3.接着看 getBean, 先试着从单例的缓存中获取, 若存在则返回.</span><br><span class="line">4.若缓存中不存在, 则判断父容器是否存, 若存在则从父容器获取</span><br><span class="line">   若父容器不存在, 则自己新建, 先标记 beanName 到 alreadyCreated 中(表示已经创建了防止重复创建) 再开始创建一个 bean.</span><br><span class="line">5.创建一个新的 bean 实例, 先处理 beanDefinition 的 dependsOn 属性(即若存在则先调用 getBean 获取依赖的 bean)</span><br><span class="line">6.若 beanDefinition 的设置是单例, 则通过闭包对创建对象前后进行一些异常处理和缓存处理(主要是彻底创建完后加入到单例一级缓存, 移除二级和三级缓存[循环依赖相关的两个缓存]).</span><br><span class="line">7.通过反射根据 beanClass 创建一个对象实例, 然后将其添加到 singletonFactories 中(解决依赖循环问题)</span><br><span class="line">8.调用 populateBean() 为对象的字段(属性)注入它所需要的值(可能是@Resource, @Value等); (此时可能会遇到依赖循环问题, 但解决这个问题的缓存在此之前就添加了, 所以不怕)</span><br><span class="line">9.最后调用 initializeBean() 完成 bean 的初始化(调用 bean 的一些方法, 如 afterPropertiesSet), 返回对象实例.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 先根据 type 找到 beanName, 找到后根据 beanName 创建对象; 创建对象前先检查缓存(单例), 再考虑父容器, 最后才是自己创建, 自己创建会先创建 dependsOn 的 bean 对象, 然后才通过反射实例化出一个对象实例(这里反射用到的class和构造方法, 通过实现 SmartInstantiationAwareBeanPostProcessor接口都可进行干预), 实例化后存到二级缓存, 再为字段赋值(注入); 最后调用 bean 的 init 相关的接口(如afterPropertiesSet), 就可以返回这个对象实例了.</p>
</blockquote>
<h3 id="超长源码分析过程-1"><a href="#超长源码分析过程-1" class="headerlink" title="超长源码分析过程"></a>超长源码分析过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从这个方法进入</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 判断容器的状态, 确保 beanFactory 可用.(主要是若不可用, 提示的错误信息会比getBeanFacgtory()中更准确)</span></span><br><span class="line">  <span class="comment">// 使用 beanFactory 的 getBean 方法获取对象并返回.</span></span><br><span class="line">  assertBeanFactoryActive();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(requiredType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后其他所有涉及的核心方法的注释</span></span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveBean</span><br><span class="line">    <span class="comment">// 调用 resolveNamedBean, 如存在 bean 则直接返回. (核心)</span></span><br><span class="line">		<span class="comment">// 若不存在则从父容器中寻找, 父容器实现了 DefaultListableBeanFactory 则调与同子容器相同的方法</span></span><br><span class="line">		<span class="comment">// 若没实现则 通过 getBeanProvider 获取.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveNamedBean(org.springframework.core.ResolvableType, java.lang.Object[], boolean)</span><br><span class="line">    <span class="comment">// 1.调用 getBeanNamesForType 获取所有与 type 相匹配的 beanName 集合.</span></span><br><span class="line">		<span class="comment">// 2.遍历判断每个 beanName 是否可用</span></span><br><span class="line">		<span class="comment">// 3.若可用的 beanName 只有一个, 则调用 getBean(beanName) 获取对象实例并返回</span></span><br><span class="line">		<span class="comment">//   若可用数超过一个, 则试着根据是否主要以及高优先级来确定一个 beanName 实例, 若能确定则返回, 不能则报错.</span></span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</span><br><span class="line">    <span class="comment">// 1.获取完整的 beanName</span></span><br><span class="line">		<span class="comment">// 2.调用 getSingleton1() 检查是否存在缓存, 这层检查可防止依赖循环.</span></span><br><span class="line">		<span class="comment">//     若存在, 则通过 getObjectForBeanInstance() 判断缓存的是 bean 还是 FactoryBean 并返回相应的对象实例.</span></span><br><span class="line">		<span class="comment">// 3.若不存在, 先试着从父容器获取(子容器不存在这个 beanDefinition 且父容器不为空)</span></span><br><span class="line">		<span class="comment">//     没有父容器则 调用 markBeanAsCreated() 标记这个 bean已经创建了 (先标记, 再创建)</span></span><br><span class="line">		<span class="comment">//     获取 beanDefinition, 判断其 dependsOn 属性是否存在, 存在则 先获取依赖的 bean</span></span><br><span class="line">		<span class="comment">//     调用 getSingleton2() 处理单例缓存</span></span><br><span class="line">		<span class="comment">// 4.而 getSingleton2() 中的闭包中 执行的 createBean() 方法中则才是创建实例并调用 BeanPostProcessor</span></span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)</span><br><span class="line">    <span class="comment">// 1.判断是否存在于 singletonObjects 中</span></span><br><span class="line">		<span class="comment">// 2.若不存在则判断 bean 是否处于创建中(未创建完成, 如循环依赖时)</span></span><br><span class="line">		<span class="comment">// 3.若处于创建中, 则同步后判断是否存在于 earlySingletonObjects (也就是 singletonFactories 移除后存入的地方)</span></span><br><span class="line">		<span class="comment">//      (因为FactoryBean占用空间大, 获取对象麻烦且速度更慢, 这是为了防止如果循环依赖链条很长 多次获取浪费CPU的问题)</span></span><br><span class="line">		<span class="comment">// 4.不存于 earlySingletonObjects 则代表第一次(也只会有一次)取 singletonFactories</span></span><br><span class="line">		<span class="comment">//    取出后调用 getObject() 并将其存入到 earlySingletonObjects, 然后从 singletonFactories 中移除. 以后就少走几行代码了.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</span><br><span class="line">    <span class="comment">// 1.先确保是第一次创建单例对象, 防止重复创建</span></span><br><span class="line">		<span class="comment">// 2.进行一些异常处理</span></span><br><span class="line">		<span class="comment">// 3.调用 singletonFactory.getObject() 创建对象</span></span><br><span class="line">		<span class="comment">// 4.创建对象结束添加单例缓存和清空 singletonFactories / earlySingletonObjects 缓存.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</span><br><span class="line">    <span class="comment">// 1.调用 resolveBeanClass 解析得到真正的 bean class, 若解析不为空且处于某些情况下, 则复制一份 beanDefinition 并设置 beanClass 为解析所得</span></span><br><span class="line">		<span class="comment">// 2.执行 BeanPostProcessor 的 postProcessorsBeforeInstantiation() 方法</span></span><br><span class="line">		<span class="comment">// 3.调用 doCreateBean() 创建对象 并返回</span></span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</span><br><span class="line">    <span class="comment">// 1.调用 createBeanInstance() 获得一个 对象实例的 包装类</span></span><br><span class="line">		<span class="comment">// 2.同步锁下执行 BeanFactoryPostProcessor 的 postProcessMergedBeanDefinition().</span></span><br><span class="line">		<span class="comment">// 3.添加 singletonFactories 缓存, 移除 earlySingletonObjects; 解决循环依赖问题.</span></span><br><span class="line">		<span class="comment">// 4.调用 populateBean() 检查字段是否需要注入对象实例, 是则获取对应的 bean 注入. (可能引起循环依赖)</span></span><br><span class="line">		<span class="comment">// 5.调用 initializeBean() 执行对象的一些 Aware 和 init 方法和 BeanPostProcessor 的 postProcessBeforeInitialization.</span></span><br><span class="line">		<span class="comment">// 6.最后返回对象实例.</span></span><br></pre></td></tr></table></figure>





<h2 id="各种实现的原理"><a href="#各种实现的原理" class="headerlink" title="各种实现的原理"></a>各种实现的原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?</span><br><span class="line">2.为何我写的 class 实现 ApplicationListener&lt;XxxEvent&gt; 后并放入容器中, 就能监听我想知道的事件?</span><br><span class="line">3.为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?</span><br><span class="line">4.Spring是如何解决循环依赖的(指用字段注入而非构造方法)?</span><br><span class="line">5.Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?</span><br><span class="line">6.Spring AOP是如何实现的(指@Aspect)?</span><br><span class="line">7.Spring 事务是如何实现的(指@Transaction)?</span><br></pre></td></tr></table></figure>

<h3 id="为何我写的-class-实现一些接口-如ApplicationContextAware-后并放入容器中-就可以获取到一些对象-如applicationContext"><a href="#为何我写的-class-实现一些接口-如ApplicationContextAware-后并放入容器中-就可以获取到一些对象-如applicationContext" class="headerlink" title="为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?"></a>为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) 首先 AbstractApplicationContext#prepareBeanFactory 会添加一个ApplicationContextAwareProcessor</span><br><span class="line">2) 这个 beanPostProcessor 负责在bean初始化之前注入context对象.</span><br><span class="line">3) 这个 beanPostProcessor 的执行时机是在 doCreateBean 中的 postProcessBeforeInitialization()</span><br></pre></td></tr></table></figure>



<h3 id="为何我写的-class-实现-ApplicationListener-后并放入容器中-就能监听我想知道的事件"><a href="#为何我写的-class-实现-ApplicationListener-后并放入容器中-就能监听我想知道的事件" class="headerlink" title="为何我写的 class 实现 ApplicationListener 后并放入容器中, 就能监听我想知道的事件?"></a>为何我写的 class 实现 ApplicationListener<XxxEvent> 后并放入容器中, 就能监听我想知道的事件?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) 在 AbstractApplicationContext#registerListeners() 中扫描容器内所有相关实现类加入到事件监听者集合中</span><br><span class="line">2) 然后在publishEvent时，遍历事件监听者集合调用bean的方法即可。观察者模式！</span><br><span class="line">3) 另外也用了BeanPostProcessor去实现, 叫 ApplicationListenerDetector, 加入时机同1, 执行时机同1.</span><br><span class="line">4) 至于为何使用2种机制, 应该是因为 registerListeners() 时, 扫描只是当前的, 后续可能容器内的 bean 还会增加(我也猜不到啥形式增加, 反正简单写个类肯定不会), 所以还是需要 ApplicationListenerDetector 在这个 Bean 初始化时加入到监听者中去.</span><br></pre></td></tr></table></figure>



<h3 id="为何Spring中遇到各种顺序问题-只需要实现-Ordered-接口-或加上-Order注解-就能使其有序"><a href="#为何Spring中遇到各种顺序问题-只需要实现-Ordered-接口-或加上-Order注解-就能使其有序" class="headerlink" title="为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?"></a>为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?</h3><blockquote>
<p>因为 Spring 预先在执行这些东西之前, 进行一个排序动作, 然后才遍历执行. 包括AOP, BeanFactoryPostProcessor, BeanPostProcessor .</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) 比如说 BeanPostProcesser, 容器扫描后, 会像对bean集合排序, 再遍历执行.</span><br><span class="line">2) 详细过程见 PostProcessorRegistrationDelegate#sortPostProcessors()</span><br></pre></td></tr></table></figure>



<h3 id="Spring是如何解决循环依赖的-指用字段注入而非构造方法"><a href="#Spring是如何解决循环依赖的-指用字段注入而非构造方法" class="headerlink" title="Spring是如何解决循环依赖的(指用字段注入而非构造方法)?"></a>Spring是如何解决循环依赖的(指用字段注入而非构造方法)?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先， 假定有两个单例 bean A 和 B, A 持有 B, B 持有A， 构成循环</span><br><span class="line"><span class="number">2</span>) 此时程序调用getBean获取A，则在 doCreateBean 中 创建后将 bean 缓存到 singletonFactories 中</span><br><span class="line"><span class="number">3</span>) 然后设置属性B, 解析属性, 需要获取B对象</span><br><span class="line"><span class="number">4</span>) 获取B, 则执行doCreateBean 后执行解析属性, 需要获取 A对象 (又一次)</span><br><span class="line"><span class="number">5</span>) 获取A, 进入 doGetBean 中的 getSingleton, 此时判断 singletonFactories 中有A, 则可以直接取出A</span><br><span class="line"><span class="number">6</span>) 获得A后, 即可完成B的属性赋值, 然后会完成B的创建.</span><br><span class="line"><span class="number">7</span>) B创建完后, A就能获得B, 则A也完成了属性赋值, 最后完成创建A.</span><br><span class="line"><span class="number">8</span>) 到此, 返回即可.</span><br><span class="line"></span><br><span class="line">&gt; 总结: 首次获取A, 创建A对象后缓存一个存储A对象的 ObjectFactory 实例, 再解析属性时触发 getBean(B), 同理也会做缓存, 然后也解析属性, 触发getBean(A), 第二次获取A, 进入另一个逻辑, 返回 ObjectFactory 实例中存储的对象A, 即可完成getBean(A), 然后完成getBean(B), 再完成外层的getBean(A).  </span><br><span class="line">  </span><br><span class="line">TIPS:</span><br><span class="line">步骤<span class="number">4</span>中, 会先判断 earlySingletonObjects, 不存在才判断 singletonFactories, 而从 singletonFactories 中取得对象后, 则会将其从 singletonFactories 移除并加入 earlySingletonObjects</span><br><span class="line"></span><br><span class="line">这是因为 singletonFactories 缓存的 FactoryBean, 若反复调用 getObject(), 则每次获取都会调用 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#getEarlyBeanReference 方法, 而此方法会执行 SmartInstantiationAwareBeanPostProcessor 的 getEarlyBeanReference(), 这会导致 BeanPostProcessor 重复执行, 显然是不行的.</span><br></pre></td></tr></table></figure>



<h3 id="Spring可以用注解替换XML配置文件了-是如何实现的呢-常用注解的实现原理"><a href="#Spring可以用注解替换XML配置文件了-是如何实现的呢-常用注解的实现原理" class="headerlink" title="Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?"></a>Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1) 首先是指定包名或指定类名</span><br><span class="line">	如指定包名则 scan 时会执行, 如指定类名则在构造方法初始化 reader 时执行</span><br><span class="line">2) 无论哪种, 最终都会走一段代码 AnnotationConfigUtils#registerAnnotationConfigProcessors()</span><br><span class="line">3) 这段代码会添加一些 BeanFactoryPostProcessor</span><br><span class="line">	如 ConfigurationClassPostProcessor 负责解析 @Configuration&#x2F;@Import&#x2F;@Bean 等注解</span><br><span class="line">    	然后由 ConfigurationClassBeanDefinitionReader 负责将信息转换成BeanDefinition再注册到容器。</span><br><span class="line">	如 AutowiredAnnotationBeanPostProcessor 负责解析 @Autowired&#x2F;@Value 注解</span><br><span class="line">    如 CommonAnnotationBeanPostProcessor 负责解析 @Resource 注解</span><br><span class="line">    解析放在 postProcessProperties() 方法中， 先扫描bean的字段和方法， 然后一一调用方法和为字段注入值</span><br><span class="line">4) 之后, 他会将扫描的类放到 beanDefinitions 中(或指定的类注册进去)</span><br><span class="line">5) BeanFactory加载完毕后, 回到AbstractApplicationContext的refresh逻辑</span><br><span class="line">	如会执行 postProcessBeanFactory(), 调用前面加入的ConfigurationClassPostProcessor</span><br><span class="line">	然后会添加更多的类到容器中.</span><br><span class="line">    </span><br><span class="line">注意事项：</span><br><span class="line">    @Configuration 和 @Component的区别？</span><br><span class="line">    观察发现，即使使用@Component 其下带 @Bean 的方法依然可以注入到容器中。所以似乎两者没有区别？</span><br><span class="line">    仔细查看源码和资料后，发现 postProcessBeanFactory() 方法在 processConfigBeanDefinitions() 后还会调用 enhanceConfigurationClasses()</span><br><span class="line">    而在这个方法中, 对前面解析了class 是 CONFIGURATION_CLASS_FULL (即代表@Configuration)的类</span><br><span class="line">    会生成一个 cglib 的代理, 这样获取@Bean注解的方法的bean时,不会每次调用方法new 一个, 而是有缓存.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 就是利用 BeanFactoryPostProcessor 可获取 BeanDefinitionRegistry 对象, 然后扫描容器内带有注解的 bean, 解析这些注解得到一些 BeanDefinition, 再通过获得的 BeanDefinitionRegistry对象注册到 BeanFactory 中.</p>
</blockquote>
<h3 id="Spring-AOP是如何实现的-指-Aspect"><a href="#Spring-AOP是如何实现的-指-Aspect" class="headerlink" title="Spring AOP是如何实现的(指@Aspect)?"></a>Spring AOP是如何实现的(指@Aspect)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1) 使用 @EnableAspectJAutoProxy</span><br><span class="line">2) @EnableAspectJAutoProxy 中使用了 @Import(AspectJAutoProxyRegistrar.class)</span><br><span class="line">3) ConfigurationClassPostProcessor 会解析@Import, 进入 registerBeanDefinitions() 中</span><br><span class="line">4) registerBeanDefinitions() 中添加了 AnnotationAwareAspectJAutoProxyCreator 到容器中</span><br><span class="line">5) AnnotationAwareAspectJAutoProxyCreator 本质上时一个 BeanPostProcessor</span><br><span class="line">6) 因此在 createBean 时, 会被自动调用. 其中 postProcessAfterInitialization() 负责创建代理对象</span><br><span class="line">7) 而 getAdvicesAndAdvisorsForBean() 则负责查找对应的增强. 然后会调用子类的findCandidateAdvisors</span><br><span class="line">8) 如 AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors() 负责注解编写增强@Before&#x2F;@After等</span><br><span class="line">9) 简单说下逻辑, 就是查找容器所有类, 判断这个类有没有 @Aspect 注解, 然后先找出所有Pointcut</span><br><span class="line">	再遍历所有方法, 找出方法上带有@Before等注解且有关联的Pointcut的方法,</span><br><span class="line">    然后使用这个方法和关联的Pointcut 来new 一个Advisor, 加入到Advisor集合中, 遍历结束后返回即可.</span><br><span class="line">10) 查找到所有的增强后, 再比较Pointcut表达式是否匹配当前的bean, 如可以则加入.</span><br><span class="line">11) 根据找到的Advisor集合, 创建一个带配置(advisor集合等)的代理对象, 代理对象执行方法前</span><br><span class="line">12) 会先根据配置中的advisor集合生成一个执行链, 然后在拦截代理方法处调用. 执行链会负责执行通知.</span><br><span class="line">13) 不同的通知由不同的适配器执行.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结就是通过 @EnableAspectJAutoProxy 的@Import, 使得程序最终会执行 AnnotationAwareAspectJAutoProxyCreator 的 postProcessAfterInitialization(对象初始化后调用) 方法, 这个方法在 BeanFactory创建完对象后触发, 此时便可通过 CGlib 等动态代理技术为 创建的 bean 对象创建一个代理对象, 然后这个代理对象会根据 Pointcut 找到关联的 Advisor,  并在合适的时机执行对应的 Advisor, 如 @Before产生的Advisor 会在执行了 bean 对象的指定方法(看Pointcut配置)后执行.</p>
</blockquote>
<h3 id="Spring-事务是如何实现的-指-Transaction"><a href="#Spring-事务是如何实现的-指-Transaction" class="headerlink" title="Spring 事务是如何实现的(指@Transaction)?"></a>Spring 事务是如何实现的(指@Transaction)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0) 事务是由AOP实现的, 所以需要找到对应的Pointcut 和 Advisor</span><br><span class="line">1) 打开了 @EnableTransactionManagement 注解</span><br><span class="line">2) 然后@Import 了 TransactionManagementConfigurationSelector</span><br><span class="line">3) 之后导入了 ProxyTransactionManagementConfiguration 到容器中</span><br><span class="line">4) ProxyTransactionManagementConfiguration 带有 @Configuration</span><br><span class="line">5) @Bean 注入了一个通用的Advisor: BeanFactoryTransactionAttributeSourceAdvisor</span><br><span class="line">6) 这个Advisor的 Pointcut 是由 TransactionAttributeSourcePointcut 实现的</span><br><span class="line">	实现逻辑是 TransactionAttributeSourcePointcut 的 matches()</span><br><span class="line">    这个方法调用了 getTransactionAttributeSource() 获取 AnnotationTransactionAttributeSource</span><br><span class="line">    然后通过 getTransactionAttribute() 调用了 findTransactionAttribute()</span><br><span class="line">    最终使用SpringTransactionAnnotationParser 类判断方法是否有@Transactional注解</span><br><span class="line">    并解析注解信息然后返回. 另外这个方法还可以获取@Transactional注解的信息, 而这里只用于判断是否需要拦截这个方法.</span><br><span class="line">7) TransactionInterceptor 是一个Advisor</span><br><span class="line">    也可以通过AnnotationTransactionAttributeSource获取@Transactional注解上的信息</span><br><span class="line">    然后在invoke中, 拦截方法, 打开事务, 在执行完方法后, 提交事务, 报错时回滚事务</span><br><span class="line">    这个 Advisor 不同于传统的前置&#x2F;后置, 而是更具体的 MethodInterceptor(动态代理直接相关).</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 就是基于AOP实现的, 只需找到对应的 Pointcut 和 Advisor 即可. Pointcut 就是根据 @Transaction 注解判断方法是否需要代理, 这个很简单; 比较有意思的是 Advisor 不是我们写AOP那种 @Before,@Around之类的, 而是更接近动态代理原始的语法的 MethodInterceptor 即 TransactionInterceptor.</p>
</blockquote>
<h2 id="BeanFactoryPostProcessor-相关类分析"><a href="#BeanFactoryPostProcessor-相关类分析" class="headerlink" title="BeanFactoryPostProcessor 相关类分析"></a>BeanFactoryPostProcessor 相关类分析</h2><h3 id="BeanFactoryPostProcessor-生效原理"><a href="#BeanFactoryPostProcessor-生效原理" class="headerlink" title="BeanFactoryPostProcessor 生效原理"></a>BeanFactoryPostProcessor 生效原理</h3><blockquote>
<p>生效原理就是, ApplicationContext 的 refresh 方法中会扫描出容器中实现了 BeanFactoryPostProcessor 接口的 bean, 将其排序后执行相应的接口, 这样我们写的类实现的相应的接口的方法就被执行了.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常用的 BeanFactoryPostProcessor</span><br><span class="line"><span class="comment"># ConfigurationClassPostProcessor</span></span><br><span class="line">这个类作用就是解析 @Configuration/@Component/@Import/@ImportSource/@ComponentScan 等基础注解. 是注解开发的基石, 更是 Spring Boot 的基石.</span><br></pre></td></tr></table></figure>



<h2 id="BeanPostProcessor-相关类分析"><a href="#BeanPostProcessor-相关类分析" class="headerlink" title="BeanPostProcessor 相关类分析"></a>BeanPostProcessor 相关类分析</h2><h3 id="BeanPostProcessor-生效原理"><a href="#BeanPostProcessor-生效原理" class="headerlink" title="BeanPostProcessor 生效原理"></a>BeanPostProcessor 生效原理</h3><blockquote>
<p>在 refresh() 中会扫描容器中所有 实现了 BeanPostProcessor 接口的类, 添加到 BeanFactory 的 beanPostProcessors 字段中(是个List[CopyOnWriteArrayList自定义版, 自定义加入了清空缓存的逻辑]), 然后在 BeanFactory 创建对象时 createBean() 在适当的时机调用对应的方法.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">有哪几种 BeanPostProcessor (默认的+扩展)</span><br><span class="line">1.InstantiationAwareBeanPostProcessor</span><br><span class="line">	postProcessAfterInstantiation: 对象实例化后调用</span><br><span class="line">	postProcessBeforeInstantiation: 对象实例化前调用</span><br><span class="line">	postProcessProperties: 设置属性值前</span><br><span class="line">	postProcessPropertyValues: 设置属性值前, 若上个方法不处理(返回null)才会触发</span><br><span class="line"></span><br><span class="line">2.SmartInstantiationAwareBeanPostProcessor</span><br><span class="line">  predictBeanType: 获取一个 bean 的 class 类型前调用</span><br><span class="line">  getEarlyBeanReference: 获取一个二级缓存对象(singletonFactories的getObject)时调用</span><br><span class="line">  determineCandidateConstructors: 决定一个 bean 实例化的构造参数是什么时调用</span><br><span class="line">	</span><br><span class="line">3.DestructionAwareBeanPostProcessor</span><br><span class="line">	postProcessBeforeDestruction: 对象销毁前调用</span><br><span class="line">	requiresDestruction: 判断这个类针对某个 bean 是否执行 postProcessBeforeDestruction()</span><br><span class="line">	</span><br><span class="line">4.MergedBeanDefinitionPostProcessor</span><br><span class="line">  postProcessMergedBeanDefinition: 在创建对象前调用, 可对 BeanDefinition 做修改</span><br><span class="line">  resetBeanDefinition: 在重置 BeanDefinition 时调用, 用于清空 PostProcessor 对应的缓存</span><br><span class="line">	</span><br><span class="line">5.BeanPostProcessor(基础)</span><br><span class="line">  postProcessBeforeInitialization: 创建对象后(也设置好了字段), 在调用 init 之前调用</span><br><span class="line">  postProcessAfterInitialization: 在创建对象时, 调用了 init 之后调用</span><br><span class="line">  </span><br><span class="line">总结: </span><br><span class="line">0.对 BeanDefinition 做干预</span><br><span class="line">1.对象实例化过程中(对class/构造参数进行干预)</span><br><span class="line">2.对象实例化前后</span><br><span class="line">3.对象设置属性前, 对属性做干预</span><br><span class="line">4.对象初始化(init)前后</span><br><span class="line">5.对象销毁前</span><br></pre></td></tr></table></figure>

<h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 1.1: InstantiationAwareBeanPostProcessor 的 postProcessAfterInstantiation()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean 第一段</span></span><br><span class="line"><span class="comment">// 1.2: InstantiationAwareBeanPostProcessor 的 postProcessProperties()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean 第二段</span></span><br><span class="line"><span class="comment">// 1.3: InstantiationAwareBeanPostProcessor 的 postProcessPropertyValues</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean 第三段</span></span><br><span class="line"><span class="comment">// 1.4: InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1: SmartInstantiationAwareBeanPostProcessor 的 predictBeanType()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType 中</span></span><br><span class="line"><span class="comment">// 2.2: SmartInstantiationAwareBeanPostProcessor 的 getEarlyBeanReference()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getEarlyBeanReference 中</span></span><br><span class="line"><span class="comment">// 2.3: SmartInstantiationAwareBeanPostProcessor 的 determineCandidateConstructors()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineConstructorsFromBeanPostProcessors 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1: MergedBeanDefinitionPostProcessor 的 postProcessMergedBeanDefinition()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors 中</span></span><br><span class="line"><span class="comment">// 3.2: MergedBeanDefinitionPostProcessor 的 resetBeanDefinition()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.DefaultListableBeanFactory.resetBeanDefinition 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.1: DestructionAwareBeanPostProcessor 的 postProcessBeforeDestruction()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.DisposableBeanAdapter.destroy 中</span></span><br><span class="line"><span class="comment">// 4.2: DestructionAwareBeanPostProcessor 的 requiresDestruction()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.DisposableBeanAdapter.filterPostProcessors 和 org.springframework.beans.factory.support.DisposableBeanAdapter.hasApplicableProcessors 中</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有哪些常用的 BeanPostProcessor</span></span><br><span class="line">1.AsyncAnnotationBeanPostProcessor: 用于在将 @Async 相应的 Advisor 加入到对象的代理中</span><br><span class="line">2.ScheduledAnnotationBeanPostProcessor: 用于处理 @Scheduled 注解, 将 bean 生产代理类</span><br><span class="line">3.AnnotationAwareAspectJAutoProxyCreator: AOP 实现核心类</span><br><span class="line">4.AutowiredAnnotationBeanPostProcessor: 用于处理 @Autowired 注解</span><br><span class="line">5.ApplicationListenerDetector: 用于处理实现 ApplicationListener 接口的 bean 对象, 将其添加到事件广播器的监听者集合中.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2020/05/20/interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/interview/" class="post-title-link" itemprop="url">一顿乱写</a>
        </h2>

        <div class="post-meta">
			
				<i class="fa fa-thumb-tack"></i>
				<font color="RED">置顶</font>
				<span class="post-meta-divider">|</span>
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 08:48:14" itemprop="dateCreated datePublished" datetime="2020-05-20T08:48:14+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:55:35" itemprop="dateModified" datetime="2021-03-28T19:55:35+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/20/interview/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/20/interview/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h2><h3 id="说一下你重构代码都做了什么"><a href="#说一下你重构代码都做了什么" class="headerlink" title="说一下你重构代码都做了什么?"></a>说一下你重构代码都做了什么?</h3><blockquote>
<p>首先是两层改成三层, 把controller 的代码尽量迁移到 service 层. 然后将请求风格和响应数据结构统一. 还有就是处理全局异常, 最后对某些重复代码封装成工具类. 另外还会根据实际业务场景使用一些设计模式, 提高代码可扩展性, 降低代码之间的耦合性.</p>
</blockquote>
<h3 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM?"></a>什么是 JVM?</h3><blockquote>
<p> JVM 就是由编译器, 类加载器, 执行引擎, 运行时数据区组成. 其中数据区包含 堆,栈,本地方法栈, 方法区和程序计数器(PC 寄存器), 其中栈是由局部变量表, 操作数栈, 动态链接, 返回地址组成的.</p>
</blockquote>
<h3 id="你是怎么对-jvm-垃圾回收进行优化的"><a href="#你是怎么对-jvm-垃圾回收进行优化的" class="headerlink" title="你是怎么对 jvm 垃圾回收进行优化的?"></a>你是怎么对 jvm 垃圾回收进行优化的?</h3><blockquote>
<p>根据服务器的配置, 调整青年代和老年代的内存大小及比例, 在回收频率和回收速度上做取舍, 使用 G1 垃圾回收期控制 STW 停顿时间, 提高吞吐量.</p>
</blockquote>
<h3 id="说说-MySQL-优化"><a href="#说说-MySQL-优化" class="headerlink" title="说说 MySQL 优化"></a>说说 MySQL 优化</h3><blockquote>
<p>首先是 SQL 查询优化, 通过对联表字段, 查询条件, 分组字段, 排序字段进行综合分析, 根据最左原则建立一个或多个复合索引, 然后使用 explain 分析SQL执行计划, 判断索引使用情况, 根据分析结果进一步改进索引.</p>
<p>然后是对于数据量大的表, 考虑垂直或水平分表, 读多写少的情况, 可以一主多从集群. 另外对于一些统计类的查询, 可以用定时任务将统计结果存储起来, 而非实时查询.</p>
</blockquote>
<h3 id="你用-Redis-做了什么"><a href="#你用-Redis-做了什么" class="headerlink" title="你用 Redis 做了什么?"></a>你用 Redis 做了什么?</h3><blockquote>
<p>将高访问的首页商品列表缓存到 redis 中, 避免数据库瓶颈, 提高响应速度. </p>
<p>商品同步问题: 定时任务刷新. 或修改商品时更新, 缓存设置失效时间, 失效后自动读取数据库.</p>
<p>将购物车数据存放到 redis, 提高购物车交互体验(加快响应速度).</p>
</blockquote>
<h3 id="你使用消息队列做了什么"><a href="#你使用消息队列做了什么" class="headerlink" title="你使用消息队列做了什么?"></a>你使用消息队列做了什么?</h3><blockquote>
<p>解耦: 如下单系统调用库存系统减库存, 若调用时库存系统挂了或出错了, 下单系统还需要做重试处理, 异常处理, 此时可将减库存请求放到消息队列中, 库存系统读取消息进行处理, 若出错则放回消息队列重试. 这样即使代码 bug 导致一直不成功也可在升级后自动重试, 无需人工干预. 另微信支付回调也可如此处理.</p>
<p>削峰: 如秒杀瞬间请求过高, 可将请求放到消息队列中, 另一端缓慢消费, 可防止系统卡住.</p>
<p>异步: 比如下单后发送下单通知, 有短信通知, 微信公众号通知等, 一个一个发送会导致下单这个请求响应很慢, 因此可以将几个通知做成一个消息, 放到消息队列, 由另一处代码异步执行.</p>
</blockquote>
<h3 id="你使用线程池做了什么"><a href="#你使用线程池做了什么" class="headerlink" title="你使用线程池做了什么?"></a>你使用线程池做了什么?</h3><blockquote>
<p>将线程池封装到一个工具类中, 工具类再做成单例模式. 这样使用到多线程的地方都可以使用同一个公共线程池, 减少线程对象创建销毁. 提高线程的利用率.</p>
<p>一些地方异步操作, 拦截器添加请求日志时异步添加.</p>
</blockquote>
<h3 id="你在代码中使用了哪些设计模式"><a href="#你在代码中使用了哪些设计模式" class="headerlink" title="你在代码中使用了哪些设计模式?"></a>你在代码中使用了哪些设计模式?</h3><blockquote>
<p>单例模式, 静态工厂模式, 模板方法, 观察者, 装饰者, 策略模式, 状态模式, 职责链模式.</p>
<p>观察者: 监听商品信息更新, 根据佣金变化幅度决定是否删除, 根据佣金变化和价格变化幅度决定是否通知用户收藏商品变化.</p>
<p>策略模式: 订单不同类型, 对应的商品源不同, 查询数据方式不同, 因此使用策略模式, 便于新增类型的扩展.</p>
<p>状态模式: 红包状态的变化, 可以做成状态模式, 使得红包新增状态时扩展更简单.</p>
</blockquote>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">重复代码重构, 抽象出工具类, 返回值&#x2F;自定义异常 整理重构, 统一请求风格</span><br><span class="line">使用状态模式&#x2F;策略模式优化 if&#x2F;else</span><br><span class="line">使用工厂模式统一管理需要的实例对象, 如工具类, 邮件服务等</span><br><span class="line">封装通用 CRUD 接口及实现, 减少 Dao 层代码</span><br><span class="line"></span><br><span class="line">模块的拆分, 数据库分库分表, 微服务拆分</span><br></pre></td></tr></table></figure>

<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="MySQL-集群"><a href="#MySQL-集群" class="headerlink" title="MySQL 集群"></a>MySQL 集群</h4><blockquote>
<p>MySQL 默认支持主从架构集群, 可配合 mycat 实现读写分离.</p>
</blockquote>
<h4 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h4><blockquote>
<p>Redis Cluster, Codis</p>
</blockquote>
<h4 id="Tomcat-集群"><a href="#Tomcat-集群" class="headerlink" title="Tomcat 集群"></a>Tomcat 集群</h4><blockquote>
<p>tomcat 集群一般需要考虑 session 共享, 可通过 redis 实现 session 共享.</p>
</blockquote>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><blockquote>
<p>Spring Cloud 是一套分布式开发的解决方案, 集合了分布式调用, 链路追踪, 降级处理, 服务注册发现.</p>
</blockquote>
<h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><blockquote>
<p>Dubbo 是一个分布式 RPC 调用框架, 底层使用 netty 框架.</p>
</blockquote>
<h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><blockquote>
<p>docker 是一个容器, 提供了标准化的接口, 可用于快速构建部署环境, 简化部署流程</p>
</blockquote>
<h4 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h4><blockquote>
<p>docker-compose 使用 yml 文件描述容器间的关系以及容器的配置, 可用于快速构建复杂的运行环境.</p>
</blockquote>
<h4 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h4><blockquote>
<p>K8s 是一个根据容器快速搭建和管理集群的工具.</p>
</blockquote>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h3><blockquote>
<p>每个线程有自己的内存区域, 多线程之间通信主要通过共享内存来实现.</p>
</blockquote>
<ul>
<li>有序性: 在 CPU 执行指令时, 可能会对非 happens-before 指令进行重排, 优化执行效率. 在单线程情况, 往往不会产生问题, 但涉及多线程时, 可能导致 bug.</li>
<li>可见性: 一个线程修改了一个共享变量, 另一个线程不会知道这个改变, 这就是不可见, 要确保可见性, 一般使用 volatile 关键词, 当然, 加锁也可以.</li>
<li>原子性: 即对于某代码, 实际执行时会分为好几个原子指令, 确保原子性必须加锁 (如synchronized) 处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">happens-before:</span><br><span class="line">读后写</span><br><span class="line">写后写</span><br><span class="line">锁后解锁</span><br><span class="line">可传递性</span><br></pre></td></tr></table></figure>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote>
<p>线程是一个进程中的不同执行路径, 一个进程至少有一个主线程.</p>
<p>进程是一个程序的抽象, 一个程序运行后一般为一个进程.</p>
</blockquote>
<p>线程状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.New (新建)</span><br><span class="line">2.Runnable (就绪)</span><br><span class="line">3.Running (运行中)</span><br><span class="line">4.Blocked (阻塞)</span><br><span class="line">5.WAITING (等待)</span><br><span class="line">6.TIMED_WAITING (超时等待)</span><br><span class="line">7.Dead (死亡)</span><br><span class="line"></span><br><span class="line">[t:thread对象, obj: 同步块中的对象]</span><br><span class="line">New: new Thread()</span><br><span class="line">Runnable: t.start(), t.yield()</span><br><span class="line">Running: after t.start() and cpu run it</span><br><span class="line">Blocked: when enter synchronized block</span><br><span class="line">WAITING: obj.wait(), t.join(), LockSupport.park()</span><br><span class="line">TIMED_WAITING: Thread.sleep(x), obj.wait(x), t.join(x)</span><br><span class="line">Dead: when t.run() is over</span><br></pre></td></tr></table></figure>



<h3 id="JVM-对象结构"><a href="#JVM-对象结构" class="headerlink" title="JVM 对象结构"></a>JVM 对象结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对象头:</span><br><span class="line">	Mark Word(hash, 锁状态, 分代年龄)</span><br><span class="line">	类型指针</span><br><span class="line">	[数组长度]</span><br><span class="line">实例数据</span><br><span class="line">对齐</span><br></pre></td></tr></table></figure>



<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">标记算法:</span><br><span class="line">	1.引用计数法</span><br><span class="line">	2.可达性分析算法(根搜索)(根对象: 栈中的对象, 静态属性引用对象, 常量引用对象)</span><br><span class="line">回收算法:</span><br><span class="line">	1.标记-清除算法</span><br><span class="line">	2.标记-整理算法</span><br><span class="line">	3.标记-复制算法</span><br><span class="line">	4.分代算法( Eden 区(复制算法)--&gt; Survivor 区(缓存, 复制算法) --&gt; Old 区(标记-整理)</span><br><span class="line"></span><br><span class="line">回收器: (前 3 个 Young GC 使用, 后面的 Full GC 使用)</span><br><span class="line">	1.Serial (串行, 复制算法)</span><br><span class="line">	2.ParNew (多线程, 复制算法)</span><br><span class="line">	3.Parallel Scavenge (多线程, 改进版, 可控制吞吐量)</span><br><span class="line">	4.Serial Old(单线程, 标记-整理)</span><br><span class="line">	5.Parallel Old (多线程, 控制吞吐量, 标记-整理算法)</span><br><span class="line">	6.CMS (多线程, 低停顿, 标记-清除算法) : 初始(STW)-并发-重新(STW)-清除</span><br><span class="line">	7.G1 (多线程, CMS 升级版, 标记-整理算法): 初始(STW)-并发-最终(STW)-筛选清除(可控制停顿时间)</span><br></pre></td></tr></table></figure>



<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><blockquote>
<p>MySQL 索引一般选择 B+树做为数据结构存储. B+ 树的优点是, 对文件IO的访问次数控制在 3 次, 保证速度的同时, 能存储千万行数据.</p>
</blockquote>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对常用列添加索引, 视具体情况选择单一索引或复合索引(一般为复合)</span><br><span class="line">2.通过 Explain 语句分析执行计划, 将 type 提升到至少 index 级别.</span><br><span class="line">3.通过 Explain 语句分析执行计划, 将 extra 中 Using filesort消除(排序列加索引), Using join buffer消除 (通过给关联表的关联列加索引), Using temporary (一般通过分组列加索引), Using where(根据最左原则对条件列加复合索引)</span><br></pre></td></tr></table></figure>



<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ACID:</span><br><span class="line">A: 原子性, 多个操作要么都做, 要么都不做</span><br><span class="line">C: 一致性, 数据库文件的状态必须从一个一致性状态到另一个一致性状态.</span><br><span class="line">I: 隔离性, 事物之间相互隔离, 互不影响.</span><br><span class="line">D: 持续性, 一个事务一但提交, 则对数据库的改变是永久的.</span><br></pre></td></tr></table></figure>



<h3 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.读未提交: 可读取其他未提交事务的执行结果(如更新了某个字段), 可能会造成读取错误的数据(未提交的事务回滚了), 造成脏读.</span><br><span class="line">2.读已提交: 可读取其他已提交事务的执行结果, 2次读取数据还是可能不一致(其他事务又提交了), 造成不可重复读.</span><br><span class="line">3.可重复读: 确保同一事务内多次读取数据时, 会看到相同的数据. 但可能造成幻读, 如批量修改登录密码后, 另一个事务新增了一条记录, 导致新纪录未修改.</span><br><span class="line">4.串行化: 事务串行化执行, 效率低.</span><br></pre></td></tr></table></figure>

<h4 id="MySQL-默认隔离级别"><a href="#MySQL-默认隔离级别" class="headerlink" title="MySQL 默认隔离级别"></a>MySQL 默认隔离级别</h4><p><code>可重读读</code></p>
<h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁: 分为排它锁(X) 和共享锁(S). 即写锁和读锁.</span><br><span class="line">表锁: 分为元数据锁(MDL)和表锁.</span><br></pre></td></tr></table></figure>

<h4 id="锁触发方式"><a href="#锁触发方式" class="headerlink" title="锁触发方式"></a>锁触发方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁: 隐式(条件带有索引则锁对应列, 不带索引则锁全部行, RR 总会带有 GAP 锁, RC 不会), 显式(使用 for update, lock in share mode)</span><br><span class="line">表锁: 隐式(对整个表不带条件进行增删改, 或任何 DDL 操作) 显示(使用 for update, lock in share mode)</span><br></pre></td></tr></table></figure>



<h2 id="源码和框架"><a href="#源码和框架" class="headerlink" title="源码和框架"></a>源码和框架</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><h4 id="加锁流程-lock"><a href="#加锁流程-lock" class="headerlink" title="加锁流程 lock()"></a>加锁流程 <code>lock()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) acquire(): 尝试获取一个许可证, 获取成功则直接返回(lock结束), 获取失败则需要排队</span><br><span class="line"><span class="number">2</span>) tryAcquire(): 判断当前许可证数量(state), 若为<span class="number">0</span>则尝试获取</span><br><span class="line">     分公平和非公平, 公平锁会判断 hasQueuedPredecessors, 非公平则直接抢 compareAndSetState</span><br><span class="line">     若不为<span class="number">0</span>, 则判断持有锁的人是否为我本身, 是则增加当前许可证数量, 返回<span class="keyword">true</span>获取成功</span><br><span class="line">     不是则 返回 <span class="keyword">false</span>, 获取失败(将排队).</span><br><span class="line"><span class="number">3</span>) addWaiter(): AQS 队列尾部添加一个 Node(waiter=X[独占锁]), 若 tail 不存在, 则先初始化一个 空head[空指不代表任何线程] 后再加入队列</span><br><span class="line"><span class="number">4</span>) acquireQueued: 进入队列的节点, 尝试获取许可证, 失败则 park()</span><br><span class="line">     先判断node的上一个节点是否为 head 节点, 若是, 则要尝试获取一次许可证(因为这说明上一个线程已经在执行过程中了, 也许已经走完了unlock() 方法(即已经运行过唤醒队列下一位的代码了,而因为你那时还不在队列中或没进入睡眠中, 唤醒代码是无意义的), 而你则刚加入队列, 如果你此时直接park()去等待唤醒, 则根本无人唤醒你, 同理你的下一个节点也就等不到你去唤醒它.)</span><br><span class="line">     如果不是, 设置了上一个节点的 waitStatus 为 SINGLE 后, 自己睡眠 park(), 等待唤醒</span><br><span class="line"></span><br><span class="line">唤醒后:  </span><br><span class="line"><span class="number">5</span>) 判断上一个节点是不是 head, 一般来说是(因为unkock唤醒的一般就是head.next)</span><br><span class="line">     如果不是则进入 shouldParkAfterFailedAcquire: 将队列中一些已取消的节点从队列中删除, 重新设置节点的prev</span><br><span class="line">     因为是<span class="keyword">for</span>循环, 所以又会再回来判断, 这时应该是head了, 尝试获取许可证, <span class="number">2</span>种可能, 非公平时被刚lock的人抢了(概率较小吧), 另一种就是获取成功</span><br><span class="line">     获取成功后, 把原head节点删掉, 自己设为head节点(head象征一个拿到许可证的节点,除队列第一次初始化), 然后返回到acquire(), 中途没有线程被打断就正常出方法, lock结束</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">得到方式<span class="number">1</span>: acquire 时 state = <span class="number">0</span>, 且抢到了.</span><br><span class="line">得到方式<span class="number">2</span>: 没抢到或不让抢(公平锁), 进入队列等上一个来唤醒我, 上一个等上上个来唤醒他, 上上个等上上上个唤醒....</span><br><span class="line">    unlock 唤醒队列第二个非取消的线程并删除队列第一个元素 [其他元素移位]</span><br><span class="line">    这样第二个线程就可以唤醒非取消的第三个线程[相对而言的第三个,实际上唤醒时还是第二个, 只是唤醒后会删除第一个, 所以第三变第二]</span><br></pre></td></tr></table></figure>

<h4 id="解锁流程-unlock"><a href="#解锁流程-unlock" class="headerlink" title="解锁流程 unlock()"></a>解锁流程 <code>unlock()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) release(): 释放一个许可证, 并根据当前许可证数量是否为0 判断是否可以唤醒下一个节点</span><br><span class="line">2) tryRelease(): 释放一个许可证, 判断线程是否正确(是不是当前独占锁), 许可证减一</span><br><span class="line">	当前许可证数量是否为 0 返回是否可以唤醒队列的 bool 标识.</span><br><span class="line">3) unparkSuccessor(): 唤醒队列中除head外第一个处于阻塞(非取消)的节点(查找方式, 先看next, next状态不对则从后往前找最前的非取消的节点, 因为next如果为null, 无法找null的next).</span><br><span class="line">4) 唤醒后, 会将head设置为唤醒的节点, 以此达到下次唤醒下一个的目的.</span><br><span class="line"></span><br><span class="line">总结:</span><br><span class="line">唤醒的逻辑就是将排队的所有节点挨个唤醒, 而节点被唤醒后又会出队列; 所以代码将出队列和唤醒逻辑一起做, 先唤醒下一个, 下一个负责把前一个移出队列. 然后唤醒自己的下一个, 以此类推, 就实现了唤醒和出队列的操作.</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><code>ReentrantReadWriteLock</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">读锁</span><br><span class="line">	获取锁 tryAcquireShared(), 若当前没有写锁存在, 则 state + <span class="number">1</span>个读单位, 然后返回获取成功. 防止返回获取失败, 进入队列休眠.</span><br><span class="line">	释放锁 tryReleaseShared(), state - <span class="number">1</span>个读单位, 然后根据 state = <span class="number">0</span> 判断返回是否可以唤醒队列.</span><br><span class="line">	</span><br><span class="line">写锁</span><br><span class="line">	获取锁 tryAcquire(), 若存在读锁, 则失败, 若存在写锁, 判断是否重入获取, 是则返回获取成功. 否则失败; 失败就意味着加队列,休眠.</span><br><span class="line">    释放锁 tryRelease(), state - <span class="number">1</span>, 判断 state 中写锁数量是否为<span class="number">0</span>, 是则可以唤醒队列. 否则代表这时一个可重入锁的释放逻辑.</span><br><span class="line">   </span><br><span class="line">总结: 读写锁也好, 可重入锁也好, CountDownLatch 等工具类也好, 都是对 state 操作为多, 或者说, 实现了 AQS的它们, 只负责操作 state, 而队列, 唤醒, 都交给 AQS 来处理.</span><br></pre></td></tr></table></figure>



<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h3><h4 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a><code>countDown()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1) state 数量减一, 然后判断 state 数量是否为0, 若是则唤醒等待队列的线程.</span><br></pre></td></tr></table></figure>

<h4 id="await"><a href="#await" class="headerlink" title="await()"></a><code>await()</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) new 之后, state 数量大于0, 所以会进入等待队列, 然后线程会进入休眠.</span><br><span class="line">2) 等待countDown释放锁, 释放到许可证为0时, 唤醒等待队列的线程.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结:</p>
<p>利用了加共享锁进入队列等待特性实现 <code>await()</code></p>
<p>释放共享锁减少许可证数量且唤醒队列中的等待的线程 实现 <code>countDown()</code></p>
</blockquote>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><code>Semaphore</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">与 CountDownLatch 相反, 初始数量一般为 0, acquire() 时判断是否有许可证, 有则成功, 无则队列休眠</span><br><span class="line">而 release 则是添加一个许可证, 添加后总是唤醒队列.</span><br></pre></td></tr></table></figure>

<h3 id="CycleBarrier"><a href="#CycleBarrier" class="headerlink" title="CycleBarrier"></a><code>CycleBarrier</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">含义: 凑足一定个数线程, 然后批量唤醒.</span><br><span class="line">await(): 利用 ReenrantLock 的 lock 和 condition 的 await 进入休眠</span><br><span class="line">当凑足后，用condition 的 singleAll 唤醒所有 await 的线程.</span><br></pre></td></tr></table></figure>





<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><code>HashMap</code></h3><h4 id="请简述-HashMap-的底层数据结构"><a href="#请简述-HashMap-的底层数据结构" class="headerlink" title="请简述 HashMap 的底层数据结构"></a>请简述 <code>HashMap</code> 的底层数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 使用了数组加链表, 以数组为主, 链表加红黑树为补充的数据结构来存储键值对.</span><br><span class="line">2. 当键发送冲突(碰撞)时, 数据将串成链表存于数组中, 当链表长度超过指定值(默认 8)时, 链表转成红黑树, 当红黑树长度小于指定值时(默认 6), 则又转成链表</span><br></pre></td></tr></table></figure>

<h4 id="为什么-HashMap-的初始容量以及扩容后的容量均为-2-的指数幂"><a href="#为什么-HashMap-的初始容量以及扩容后的容量均为-2-的指数幂" class="headerlink" title="为什么 HashMap 的初始容量以及扩容后的容量均为 2 的指数幂"></a>为什么 <code>HashMap</code> 的初始容量以及扩容后的容量均为 2 的指数幂</h4><blockquote>
<p>因为计算机做运算时, 取模运算速度远远慢于位运算, 而若容量始终为 2 的指数幂, 则根据 hash 获取数组下标时只需要 使用 <code>(数组长度-1) &amp; hash 值</code> 即可确定数组下标, 与取模得到的下标一样可靠.</p>
<p>而扩容后后, 因为需要进行 rehash 运算来确定 数据的新下标, 多次进行取数组下标则更能体现位运算的优势.</p>
</blockquote>
<h4 id="为什么-HashMap-的加载因子是-0-75-3-4"><a href="#为什么-HashMap-的加载因子是-0-75-3-4" class="headerlink" title="为什么 HashMap 的加载因子是 0.75 (3/4)"></a>为什么 <code>HashMap</code> 的加载因子是 0.75 (3/4)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用排除法:</span><br><span class="line">1.若加载因子为 1. 则每次 HashMap 满了才进行扩容, 必将有更高的几率触发 hash 碰撞导致数组下标一致需要转成链表或红黑树, 导致读取和更新速度降低.</span><br><span class="line">2.若加载因子为 0.5. 则每次 HashMap 都有一半容量剩余, 空间大大浪费, 对内存开销太大. 容易引发 OOM 事故.</span><br><span class="line">3.0.5-1 之间那么多可能, 选哪个都行, 但作为 HashMap 的默认值, 选中间的 0.75, 走中庸之路, 也是解释的通的.</span><br></pre></td></tr></table></figure>



<h4 id="为什么-HashMap-1-8-扩容无需-rehash"><a href="#为什么-HashMap-1-8-扩容无需-rehash" class="headerlink" title="为什么 HashMap 1.8 扩容无需 rehash"></a>为什么 <code>HashMap</code> 1.8 扩容无需 rehash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 因为1.8的获取 hash 值的算法优化了. 无需一个 hashSeed 进行辅助运算 (主因)</span><br><span class="line">2. 由于 hash 值不变, 原链表中的所有节点只有 2 种可能:</span><br><span class="line">	一是 hash 值高于原数组长度, 则属于高位, 这些高位的节点, 新的下标一定是 (当前下标 + 旧数组长度). </span><br><span class="line">	另一种是 hash 值低于原数组长度, 属于低位, 这些节点的下标无需重新计算, 必然与当前下标一致</span><br><span class="line">	(不信自己那几个示例数据用画出完整二进制计算一下)(神奇的位运算)</span><br><span class="line">3. 重新计算下标时, 根据第 2 点可知, 其下标大小一定不高于(当前下标+旧数组长度), 即下一次循环的下标必然比上一次循环的下标要高, 所以 1.8 源码 resize 进行高低位分组然后转移数据时, 无需担心下一次循环会将刚刚放到新数组的值覆盖(下标相同则会覆盖)</span><br><span class="line">4. 1.8 的 resize 优化了算法, 保持了原有的链表顺序(不知道有啥用)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总得来说, 1.8 优化了 hash 算法, 使 <code>hashcode</code> 的高 16 位与 低 16 位进行异或运算, 降低了碰撞率</p>
<p>而 resize 算法也优化链表节点的迁移, 避免了 1.7 的链环产生</p>
<p>最大的区别就是, 1.7 没有将二进制的神奇发挥到极致, 依然像普通 java 程序一般逻辑. 而 1.8 则充分利用了二进制的优点(也充分的让人头晕), 提高了 <code>HashMap</code> 的效率.</p>
</blockquote>
<h4 id="为什么-HashMap-从链表达到-8-个时转成红黑树-达到-6-个时转回链表"><a href="#为什么-HashMap-从链表达到-8-个时转成红黑树-达到-6-个时转回链表" class="headerlink" title="为什么 HashMap 从链表达到 8 个时转成红黑树, 达到 6 个时转回链表?"></a>为什么 <code>HashMap</code> 从链表达到 8 个时转成红黑树, 达到 6 个时转回链表?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.根据 Poisson distribution 定律, 凑齐8个节点碰撞到同一个下标, 组成长度为 8 的链表概率极低, 约为 0.00000006, 而超过 8 个的几率则更低, 大约为千万分之一. 所以将阈值设置为 8, 因为这种概率极低. 因此可以减少链表转红黑树的, 提高增删改效率.</span><br><span class="line">2.若达到 7 个时转回链表, 则可能会导致HashMap 不停的在链表和红黑树之间转换, 所以阈值设置为 6, 可起到缓冲效果.</span><br></pre></td></tr></table></figure>



<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="关键类解析"><a href="#关键类解析" class="headerlink" title="关键类解析"></a>关键类解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext</span><br><span class="line">	是一个只读的 bean 容器</span><br><span class="line">	可以加载解析配置文件(如xml)</span><br><span class="line">	可以发布事件和注册监听</span><br><span class="line">	具有国际化消息处理能力</span><br><span class="line">ConfigurableApplicationContext</span><br><span class="line">	是一个具有可配置能力的 容器(可设置各个参数, 如id, 父容器)</span><br><span class="line">	具有容器生命周期概念, 如启动,停止,关闭.</span><br><span class="line">AbstractApplicationContext</span><br><span class="line">	模板方法模式的抽象类, 定义了容器的模板(refresh方法), 但由具体的子类实现部分方法</span><br><span class="line">	管理Bean和BeanFactory的PostProcessor</span><br><span class="line">	管理事件的监听和处理</span><br><span class="line">AbstractRefreshableApplicationContext</span><br><span class="line">	为可重复刷新的容器提供基类</span><br><span class="line">	加入了BeanFactory的管理(创建&#x2F;关闭等)</span><br><span class="line">AbstractRefreshableConfigApplicationContext</span><br><span class="line">	加入了configLocation字段, 用于某些容器初始化BeanFactory和Bean</span><br><span class="line">AbstractXmlApplicationContext</span><br><span class="line">	定义了读取xml配置文件来加载BeanFactory的代码, 使得子类只需提供配置文件地址或Resource</span><br><span class="line">ClassPathXmlApplicationContext</span><br><span class="line">	继承基类, 提供配置文件地址的构造方法, 调用refresh加载BeanFactory</span><br><span class="line">						</span><br><span class="line">BeanFactoryPostProcessor</span><br><span class="line">	用于给BeanFactory添加插件式功能, 如配置文件解析 $&#123;&#125; 占位符</span><br><span class="line">	如ConfigurationClassPostProcessor 将@Configuration类下的带@Bean的method返回值注册到beanDefinitions 中</span><br><span class="line"></span><br><span class="line">BeanPostProcessor</span><br><span class="line">	用于给bean添加功能, 如ApplicationContextAware的自动注入就是如此实现的</span><br></pre></td></tr></table></figure>

<h4 id="容器初始化流程"><a href="#容器初始化流程" class="headerlink" title="容器初始化流程"></a>容器初始化流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) 从XmlClassPathApplicationContext构造方法中进入 refresh 方法</span><br><span class="line">2) 先设置容器状态</span><br><span class="line">3) 调用子类初始化 BeanFactory</span><br><span class="line">4) 设置BeanFactory 一些属性,添加一些内置的PostProcessor 注册一些 environment 相关的bean</span><br><span class="line">5) 子类设置一些内置的PostProcessor</span><br><span class="line">6) 扫描添加并执行容器内的 BeanFactoryPostProcessor</span><br><span class="line">7) 扫描容器内的 BeanPostProcessor 并注册</span><br><span class="line">8) 初始化国际化消息处理器</span><br><span class="line">9) 初始化事件广播处理器</span><br><span class="line">10) 执行子类的 refresh 逻辑</span><br><span class="line">11) 扫描容器内的 ApplicationEvent (指实现类) 并注册到事件广播处理器</span><br><span class="line">12) 完成BeanFactory的初始化, 并加载一些单例对象(设置了急于加载的bean)</span><br><span class="line">13) 初始化LifcycleProcessor, 调用onRefresh方法, 发布 ContextRefreshedEvent 事件.</span><br><span class="line">14) 清除一些缓存(如反射缓存, 注解等)</span><br></pre></td></tr></table></figure>

<h4 id="某些实现原理"><a href="#某些实现原理" class="headerlink" title="某些实现原理"></a>某些实现原理</h4><h5 id="实现-ApplicationContextAware-为何会自动注入-applicationContext"><a href="#实现-ApplicationContextAware-为何会自动注入-applicationContext" class="headerlink" title="实现 ApplicationContextAware 为何会自动注入 applicationContext?"></a>实现 <code>ApplicationContextAware</code> 为何会自动注入 <code>applicationContext</code>?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) 首先 AbstractApplicationContext#prepareBeanFactory 会添加一个ApplicationContextAwareProcessor</span><br><span class="line"><span class="number">2</span>) 这个 beanPostProcessor 负责在bean初始化之前注入context对象.</span><br><span class="line"><span class="number">3</span>) 这个 beanPostProcessor 的执行时机是在 doCreateBean 中的 postProcessBeforeInitialization()</span><br></pre></td></tr></table></figure>

<h5 id="实现-ApplicationListener-为何会在事件触发时自动执行我们实现的方法"><a href="#实现-ApplicationListener-为何会在事件触发时自动执行我们实现的方法" class="headerlink" title="实现 ApplicationListener 为何会在事件触发时自动执行我们实现的方法?"></a>实现 <code>ApplicationListener</code> 为何会在事件触发时自动执行我们实现的方法?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) 在 AbstractApplicationContext#registerListeners() 中扫描容器内所有相关实现类加入到事件监听者集合中</span><br><span class="line"><span class="number">2</span>) 然后在publishEvent时，遍历事件监听者集合调用bean的方法即可。观察者模式！</span><br><span class="line"><span class="number">3</span>) 另外也用了BeanPostProcessor去实现, 叫 ApplicationListenerDetector, 加入时机同<span class="number">1</span>, 执行时机同<span class="number">1</span>.</span><br><span class="line"><span class="number">4</span>) 至于为何使用<span class="number">2</span>种机制，与多例有关吧！(scope=<span class="string">"prototype"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="实现Order接口或注解时如何自动排序的"><a href="#实现Order接口或注解时如何自动排序的" class="headerlink" title="实现Order接口或注解时如何自动排序的?"></a>实现<code>Order</code>接口或注解时如何自动排序的?</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) 比如说 BeanPostProcesser, 容器扫描后, 会像对bean集合排序, 再遍历执行.</span><br><span class="line">2) 详细过程见 PostProcessorRegistrationDelegate<span class="comment">#sortPostProcessors()</span></span><br></pre></td></tr></table></figure>

<h5 id="单例对象如何实现循环依赖注入？"><a href="#单例对象如何实现循环依赖注入？" class="headerlink" title="单例对象如何实现循环依赖注入？"></a>单例对象如何实现循环依赖注入？</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) 首先， 设定对象A，B， A 持有 B, B 持有A， 构成循环</span><br><span class="line">2) 此时程序调用getBean获取A，则在 doCreateBean 中 创建后将bean缓存到 singletonFactories 中</span><br><span class="line">3) 然后设置属性B, 解析属性, 需要获取B对象</span><br><span class="line">4) 获取B, 则执行doCreateBean 后执行解析属性, 需要获取 A对象 (又一次)</span><br><span class="line">5) 获取A, 进入 doGetBean 中的 getSingleton, 此时判断singletonFactories中有A, 则可以直接取出A</span><br><span class="line">6) 获得A后, 即可完成B的属性赋值, 然后会完成B的创建.</span><br><span class="line">7) B创建完后, A就能获得B, 则A也完成了属性赋值, 最后完成创建A.</span><br><span class="line">8) 到此, 返回即可.</span><br><span class="line"></span><br><span class="line">&gt; 总结: 首次获取A, 创建A对象后缓存一个存储A对象的 ObjectFactory 实例, 再解析属性时触发 getBean(B), 同理也会做缓存, 然后也解析属性, 触发getBean(A), 第二次获取A, 进入另一个逻辑, 返回 ObjectFactory 实例中存储的对象A, 即可完成getBean(A), 然后完成getBean(B), 再完成外层的getBean(A).</span><br></pre></td></tr></table></figure>

<p>TIPS</p>
<blockquote>
<p>观察源码, 发现有2个缓存, 一个是 <code>singletonFactories</code>, 另一个是 <code>earlySingletonObjects</code>.<br>其中<code>earlySingletonObjects</code>的管理都在 <code>getSingleton</code> 方法中做, 而 <code>singletonFactories</code> 则在<code>doCreateBean</code>中加入, 在 <code>getSingleton</code> 中删除(有<code>earlySingletonObjects</code>后就可以删除了).<br>虽然有2个缓存, 但如果你的bean没有使用<code>BeanFactory</code>创建, 则其实一个缓存也足够了<br>(因为这样的话 <code>singletonFactories</code> 每次创建返回的都是同一个, 因为此时 <code>singletonFactories</code>存的只是代码包装的一个内部类, 而非用户自定义的.)</p>
</blockquote>
<h5 id="InstantiationAwareBeanPostProcessor等一些特殊BeanProcessor的扩展方法是何时自动调用的"><a href="#InstantiationAwareBeanPostProcessor等一些特殊BeanProcessor的扩展方法是何时自动调用的" class="headerlink" title="InstantiationAwareBeanPostProcessor等一些特殊BeanProcessor的扩展方法是何时自动调用的?"></a><code>InstantiationAwareBeanPostProcessor</code>等一些特殊<code>BeanProcessor</code>的扩展方法是何时自动调用的?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先 getBeanPostProcessorCache 获取一些特殊的BeanPostProcessor</span><br><span class="line"><span class="number">2</span>) 如 InstantiationAwareBeanPostProcessor/SmartInstantiationAwareBeanPostProcessor</span><br><span class="line"><span class="number">3</span>) 然后 createBean时, 会在正确的时机使用到这些特殊的 PostProcessor, 取出来, 然后执行对应方法</span><br><span class="line"><span class="number">4</span>) 具体何时可以查看 getBeanPostProcessorCache() 的调用位置一一查看.</span><br></pre></td></tr></table></figure>

<h4 id="注解的实现"><a href="#注解的实现" class="headerlink" title="注解的实现"></a>注解的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先是指定包名或指定类名</span><br><span class="line">	如指定包名则scan时会执行, 如指定类名则在构造方法初始化 reader 时执行</span><br><span class="line">2) 无论哪种, 最终都会走一段代码 AnnotationConfigUtils#registerAnnotationConfigProcessors()</span><br><span class="line"><span class="number">3</span>) 这段代码会添加一些 BeanFactoryPostProcessor</span><br><span class="line">	如 ConfigurationClassPostProcessor 负责解析 <span class="meta">@Configuration</span>/<span class="meta">@Import</span>/<span class="meta">@Bean</span> 注解</span><br><span class="line">    	postProcessBeanDefinitionRegistry() 中 parse 所有的带以上注解的 beanDefinitions</span><br><span class="line">    	ConfigurationClassParser 将注解信息解析保存，</span><br><span class="line">    	然后由 ConfigurationClassBeanDefinitionReader 负责注册到容器。</span><br><span class="line">	如 AutowiredAnnotationBeanPostProcessor 负责解析 <span class="meta">@Autowired</span>/<span class="meta">@Value</span> 注解</span><br><span class="line">    如 CommonAnnotationBeanPostProcessor 负责解析 <span class="meta">@Resource</span> 注解</span><br><span class="line">    解析放在 postProcessProperties() 方法中， 先扫描bean的字段和方法， 然后一一调用方法和为字段注入值</span><br><span class="line"><span class="number">4</span>) 之后, 他会将扫描的类放到 beanDefinitions 中(或指定的类注册进去)</span><br><span class="line"><span class="number">5</span>) BeanFactory加载完毕后, 回到AbstractApplicationContext的refresh逻辑</span><br><span class="line">	如会执行 postProcessBeanFactory(), 调用前面加入的ConfigurationClassPostProcessor</span><br><span class="line">	然后会添加更多的类到容器中.</span><br><span class="line">    </span><br><span class="line">注意事项：</span><br><span class="line">    <span class="meta">@Configuration</span> 和 <span class="meta">@Component</span>的区别？</span><br><span class="line">    观察发现，即使使用<span class="meta">@Component</span> 其下带 <span class="meta">@Bean</span> 的方法依然可以注入到容器中。所以似乎两者没有区别？</span><br><span class="line">    仔细查看源码和资料后，发现 postProcessBeanFactory() 方法在 processConfigBeanDefinitions() 后还会调用 enhanceConfigurationClasses()</span><br><span class="line">    而在这个方法中, 对前面解析了<span class="class"><span class="keyword">class</span> 是 <span class="title">CONFIGURATION_CLASS_FULL</span> (即代表@<span class="title">Configuration</span>)的类</span></span><br><span class="line"><span class="class">    会生成一个 <span class="title">cglib</span> 的代理, 这样获取@<span class="title">Bean</span>注解的方法的<span class="title">bean</span>时,不会每次调用方法<span class="title">new</span> 一个, 而是有缓存.</span></span><br></pre></td></tr></table></figure>

<h4 id="AOP-流程"><a href="#AOP-流程" class="headerlink" title="AOP 流程"></a>AOP 流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 使用 <span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="number">2</span>) <span class="meta">@EnableAspectJAutoProxy</span> 中使用了 <span class="meta">@Import</span>(AspectJAutoProxyRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">3) <span class="title">ConfigurationClassPostProcessor</span> 会解析@<span class="title">Import</span>, 进入 <span class="title">registerBeanDefinitions</span>() 中</span></span><br><span class="line"><span class="class">4) <span class="title">registerBeanDefinitions</span>() 中添加了 <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> 到容器中</span></span><br><span class="line"><span class="class">5) <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> 本质上时一个 <span class="title">BeanPostProcessor</span></span></span><br><span class="line"><span class="class">6) 因此在 <span class="title">createBean</span> 时, 会被自动调用. 其中 <span class="title">postProcessAfterInitialization</span>() 负责创建代理对象</span></span><br><span class="line"><span class="class">7) 而 <span class="title">getAdvicesAndAdvisorsForBean</span>() 则负责查找对应的增强. 然后会调用子类的<span class="title">findCandidateAdvisors</span></span></span><br><span class="line"><span class="class">8) 如 <span class="title">AnnotationAwareAspectJAutoProxyCreator</span>#<span class="title">findCandidateAdvisors</span>() 负责注解编写增强@<span class="title">Before</span>/@<span class="title">After</span>等</span></span><br><span class="line"><span class="class">9) 简单说下逻辑, 就是查找容器所有类, 判断这个类有没有 @<span class="title">Aspect</span> 注解, 然后先找出所有<span class="title">Pointcut</span></span></span><br><span class="line"><span class="class">	再遍历所有方法, 找出方法上带有@<span class="title">Before</span>等注解且有关联的<span class="title">Pointcut</span>的方法,</span></span><br><span class="line"><span class="class">    然后使用这个方法和关联的<span class="title">Pointcut</span> 来<span class="title">new</span> 一个<span class="title">Advisor</span>, 加入到<span class="title">Advisor</span>集合中, 遍历结束后返回即可.</span></span><br><span class="line"><span class="class">10) 查找到所有的增强后, 再比较<span class="title">Pointcut</span>表达式是否匹配当前的<span class="title">bean</span>, 如可以则加入.</span></span><br><span class="line"><span class="class">11) 根据找到的<span class="title">Advisor</span>集合, 创建一个带配置(<span class="title">advisor</span>集合等)的代理对象, 代理对象执行方法前</span></span><br><span class="line"><span class="class">12) 会先根据配置中的<span class="title">advisor</span>集合生成一个执行链, 然后在拦截代理方法处调用. 执行链会负责执行通知.</span></span><br><span class="line"><span class="class">13) 不同的通知由不同的适配器执行.</span></span><br></pre></td></tr></table></figure>

<h4 id="Spring-事务实现"><a href="#Spring-事务实现" class="headerlink" title="Spring 事务实现"></a>Spring 事务实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>) 事务是由AOP实现的, 所以需要找到对应的Pointcut 和 Advisor</span><br><span class="line"><span class="number">1</span>) 打开了 <span class="meta">@EnableTransactionManagement</span> 注解</span><br><span class="line"><span class="number">2</span>) 然后<span class="meta">@Import</span> 了 TransactionManagementConfigurationSelector</span><br><span class="line"><span class="number">3</span>) 之后导入了 ProxyTransactionManagementConfiguration 到容器中</span><br><span class="line"><span class="number">4</span>) ProxyTransactionManagementConfiguration 带有 <span class="meta">@Configuration</span></span><br><span class="line"><span class="number">5</span>) <span class="meta">@Bean</span> 注入了一个通用的Advisor: BeanFactoryTransactionAttributeSourceAdvisor</span><br><span class="line"><span class="number">6</span>) 这个Advisor的 Pointcut 是由 TransactionAttributeSourcePointcut 实现的</span><br><span class="line">	实现逻辑是 TransactionAttributeSourcePointcut 的 matches()</span><br><span class="line">    这个方法调用了 getTransactionAttributeSource() 获取 AnnotationTransactionAttributeSource</span><br><span class="line">    然后通过 getTransactionAttribute() 调用了 findTransactionAttribute()</span><br><span class="line">    最终使用SpringTransactionAnnotationParser 类判断方法是否有<span class="meta">@Transactional</span>注解</span><br><span class="line">    并解析注解信息然后返回. 另外这个方法还可以获取<span class="meta">@Transactional</span>注解的信息, 而这里只用于判断是否需要拦截这个方法.</span><br><span class="line"><span class="number">7</span>) TransactionInterceptor 是一个Advisor</span><br><span class="line">    也可以通过AnnotationTransactionAttributeSource获取<span class="meta">@Transactional</span>注解上的信息</span><br><span class="line">    然后在invoke中, 拦截方法, 打开事务, 在执行完方法后, 提交事务, 报错时回滚事务</span><br><span class="line">    这个 Advisor 不同于传统的前置/后置, 而是更具体的 MethodInterceptor.</span><br></pre></td></tr></table></figure>



<h3 id="Spring-Boot-源码"><a href="#Spring-Boot-源码" class="headerlink" title="Spring Boot 源码"></a>Spring Boot 源码</h3><h4 id="简化了多少操作？"><a href="#简化了多少操作？" class="headerlink" title="简化了多少操作？"></a>简化了多少操作？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.MultipartAutoConfiguration</span><br><span class="line">	添加了一个bean StandardServletMultipartResolver, 并设置上传文件大小等属性</span><br><span class="line">	使得Spring MVC中的 DispatcherServlet 可以获取 multipartResolver, 处理文件上传.</span><br><span class="line">    若不是Spring Boot, 需要在xml或注解中手动添加一个 这样的bean才能处理文件上传, 而且配置文件还要自己读取.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.MailSenderAutoConfiguration</span><br><span class="line">    添加了一个 JavaMailSenderImpl 的bean到容器中, 并设置邮箱服务器/账号/密码等属性</span><br><span class="line">    若不是Spring Boot, 需要在xml中配置一个bean即配置他的属性(邮箱配置)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.TransactionAutoConfiguration</span><br><span class="line">    在内部类添加 <span class="meta">@EnableTransactionManagement</span>，剩下的参考上面的 Spring 事务实现</span><br><span class="line">    </span><br><span class="line"><span class="number">4</span>.WebMvcAutoConfiguration</span><br><span class="line">    添加了 RequestMappingHandlerAdapter/RequestMappingHandlerMapping</span><br><span class="line">    添加了 ContentNegotiatingViewResolver</span><br></pre></td></tr></table></figure>

<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 创建 SpringApplicationRunListeners 管理 run 过程的事件, 监听者取自 spring.factories</span><br><span class="line"><span class="number">2</span>) 触发 run 的开始(starting)事件</span><br><span class="line"><span class="number">3</span>) 初始化 environment 对象, 并利用 run 的 environmentPrepared 事件将application.yml的数据注入</span><br><span class="line"><span class="number">4</span>) 打印 Banner, 可自定义 Banner 通过 banner.txt 文件</span><br><span class="line"><span class="number">5</span>) 根据webApplicationType创建一个ApplicationContext 容器</span><br><span class="line">    默认使用 AnnotationConfigApplicationContext</span><br><span class="line"><span class="number">6</span>) 为 context 做一些初始化和设置</span><br><span class="line">    设置环境变量， 使得 context 可以获取 application.yml 中的配置</span><br><span class="line">    调用子类扩展的设置</span><br><span class="line">    加载 容器的 initializers</span><br><span class="line">    触发 run 的 contextPrepared 事件</span><br><span class="line">    打印日志</span><br><span class="line">    添加spring boot 启动参数信息到 bean 容器中</span><br><span class="line">    设置beanFactory的 allowBeanDefinitionOverriding 属性</span><br><span class="line">    设置 懒加载策略， 添加 postProcessor 则会将每个 beanDefinition 的 lazyInit 设置为 <span class="keyword">true</span></span><br><span class="line">    把启动类<span class="class"><span class="keyword">class</span>封装成 <span class="title">BeanDefinition</span> 放到容器中, 使得@<span class="title">Configuration</span>之类的注解生效</span></span><br><span class="line"><span class="class">    触发 <span class="title">run</span> 的 <span class="title">contextLoaded</span> 事件</span></span><br><span class="line"><span class="class">7) 调用 <span class="title">context</span> 的 <span class="title">refresh</span>()</span></span><br><span class="line"><span class="class">    执行 <span class="title">BeanFactoryPostProcessor</span>, 如 <span class="title">ConfigurationClassPostProcessor</span> 解析 @<span class="title">Import</span> 注解</span></span><br><span class="line"><span class="class">    @<span class="title">Import</span> 会实现 @<span class="title">EnableAutoConfiguration</span>, 总之都是熟悉的 <span class="title">spring</span> 套路. <span class="title">boot</span>的东西就少了.</span></span><br><span class="line"><span class="class">8) 调用留给子类的 <span class="title">afterRefresh</span>() 方法, 默认空实现</span></span><br><span class="line"><span class="class">9) 打印启动完毕信息</span></span><br><span class="line"><span class="class">10) 触发 <span class="title">run</span> 的 <span class="title">started</span> 事件</span></span><br><span class="line"><span class="class">11) 调用 容器内所有的 <span class="title">ApplicationRunner</span> 和 <span class="title">CommandLineRunner</span> 实现类, 类似事件监听.</span></span><br><span class="line"><span class="class">12) 使用 <span class="title">spring</span>.<span class="title">factories</span> 中的 <span class="title">exceptionReporters</span> 处理可能出现的异常.</span></span><br><span class="line"><span class="class">13) 触发 <span class="title">run</span> 的 <span class="title">running</span> 事件</span></span><br></pre></td></tr></table></figure>



<h4 id="一些东西的实现原理"><a href="#一些东西的实现原理" class="headerlink" title="一些东西的实现原理"></a>一些东西的实现原理</h4><h5 id="ConfigurationProperties-如何实现自动注入application-properties中配置的值"><a href="#ConfigurationProperties-如何实现自动注入application-properties中配置的值" class="headerlink" title="@ConfigurationProperties 如何实现自动注入application.properties中配置的值?"></a><code>@ConfigurationProperties</code> 如何实现自动注入<code>application.properties</code>中配置的值?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先加了 <span class="meta">@EnableConfigurationProperties</span> 也会解析里面的 <span class="meta">@Import</span> </span><br><span class="line"><span class="number">2</span>) <span class="meta">@Import</span> 则引入了 EnableConfigurationPropertiesRegistrar<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">3) 这是一个 <span class="title">ImportBeanDefinitionRegistrar</span> 的实现类, 会在解析 @<span class="title">Configuration</span> 注解时调用指定方法</span></span><br><span class="line"><span class="class">4) 指定方法 <span class="title">registerBeanDefinitions</span>() 获取 @<span class="title">EnableConfigurationPropertiesRegistrar</span> 的数据</span></span><br><span class="line"><span class="class">    如 @<span class="title">EnableConfigurationProperties</span>(<span class="title">RabbitProperties</span>.<span class="title">class</span>) 加载 <span class="title">RabbitProperties</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    然后, 将这些 <span class="title">class</span> 都注册到容器中</span></span><br><span class="line"><span class="class">5) 指定方法还注册了一些工具<span class="title">bean</span>和一个重要的 <span class="title">BeanPostProcessor</span> 在 <span class="title">registerInfrastructureBeans</span>()中</span></span><br><span class="line"><span class="class">6) <span class="title">registerInfrastructureBeans</span>() 加载了 <span class="title">ConfigurationPropertiesBindingPostProcessor</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">7) 在 <span class="title">postProcessorBeforeInitialization</span>() 中 调用 <span class="title">ConfigurationPropertiesBinder</span></span></span><br><span class="line"><span class="class">8) 调用链很长, 最后 <span class="title">property</span>.<span class="title">setValue</span>(<span class="title">beanSupplier</span>, <span class="title">bound</span>)</span>;设置了值 -- JavaBeanBinder</span><br><span class="line"></span><br><span class="line">总结: 就是先将 XxxProperties 类定义注入到容器中, 这样可以getBean, 然后通过 BeanPostProcessor</span><br><span class="line">    再实例化后将属性值一一绑定.</span><br></pre></td></tr></table></figure>

<h5 id="ConditionalXxx-的实现原理"><a href="#ConditionalXxx-的实现原理" class="headerlink" title="@ConditionalXxx 的实现原理"></a><code>@ConditionalXxx</code> 的实现原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 在类上加上注解 <span class="meta">@Conditional</span> 或 带有 <span class="meta">@Conditional</span> 的其他注解:其他扩展实现</span><br><span class="line"><span class="number">2</span>) 在所有的扫描类和注解的地方,如解析<span class="meta">@Configuration</span>, AnotatedBeanDefinitionReader等reader</span><br><span class="line">    会使用 ConditionEvaluator 的 shouldSkip() 判断是否可以加载, 时机点如下</span><br><span class="line">    AnnotatedBeanDefinitionReader#doRegisterBean() 的第二行代码</span><br><span class="line">    ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod() 第四行</span><br><span class="line">    ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass()</span><br><span class="line">    ConfigurationClassParser#doProcessConfigurationClass() 处理 ComponentScan 那段</span><br><span class="line"><span class="number">3</span>) 然后再 shouldSkip 中判断， 判断逻辑大致如下：</span><br><span class="line">    先遍历所有注解取得所有的 <span class="meta">@Conditional</span> 下的 所有 value, 这个 value 是具体的Condition实现, 如OnClassCondition</span><br><span class="line">    实例化 Condition 然后添加到 conditions中</span><br><span class="line">    排序并遍历调用 matches(), 一个不匹配则返回<span class="keyword">true</span>, 代表应该跳过.</span><br><span class="line"></span><br><span class="line">TIPS:</span><br><span class="line">ConditionOutcome 封装了是否匹配和匹配日志信息[为啥成功/为啥失败]</span><br><span class="line">SpringBootCondition 提供了通用的根据 ConditionOutcome 判断是否匹配并记录日志信息的抽象类.</span><br><span class="line">    子类只需实现 getMatchOutcome(): 根据 metadata[注解信息] 返回 ConditionOutcome 对象.</span><br><span class="line">    因此, 如果我们要实现自己的 Condition, 可以继承它.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另发现 <code>AutoConfigurationImportSelector</code> 也含有判断Condition的逻辑,<br>刚开始以为是 <code>AutoConfiguration</code> 的类没有走之前说到的判断, 所以这里要做判断.<br>后来我一想, 这是 @Import 引入的, 所以, 是走了判断的. 因此这里多出的一个 <code>AutoConfigurationImportFilter</code>, 应该是一个额外的插件, 专门过滤配置在 <code>spring.factories</code> 中的 <code>AutoConfiguration</code> 类的. 而插件的读取, 也是读取 <code>spring.factories</code> 来遍历. </p>
</blockquote>
<h5 id="AutoConfigureAfter-的实现原理"><a href="#AutoConfigureAfter-的实现原理" class="headerlink" title="@AutoConfigureAfter  的实现原理"></a><code>@AutoConfigureAfter</code>  的实现原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先 AutoConfigurationImportSelector 是一个 DeferredImportSelector  </span><br><span class="line"><span class="number">2</span>) 这种 DeferredImportSelector 会延迟加载, 原理是 parse 后再加载, 而非parse执行过程中就加载.</span><br><span class="line"><span class="number">3</span>) 延迟加载机制 会先调用 process 方法, 将要加载的<span class="class"><span class="keyword">class</span>保存起来, 然后再调用 <span class="title">selectImports</span> 返回.</span></span><br><span class="line"><span class="class">4) 此时 <span class="title">AutoConfigurationImportSelector</span>.<span class="title">AutoConfigurationGroup</span> 的 <span class="title">selectImports</span>() 会调用 <span class="title">sortAutoConfigurations</span>(), 也就是调用了 <span class="title">AutoConfigurationSorter</span>.<span class="title">getInPriorityOrder</span>()</span></span><br><span class="line"><span class="class">5) <span class="title">getInPriorityOrder</span>() 调用了 <span class="title">sortByAnnotation</span>() 这个方法根据2个注解 @<span class="title">AutoConfigureBefore</span> @<span class="title">AutoConfigureAfter</span> 排序.</span></span><br><span class="line"><span class="class">6) 最后返回的就是有序的了. 另外, 这两个注解只能作用再 <span class="title">AutoConfiguration</span> 上.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">总结:</span><br><span class="line">所有的 AutoConfiguration 所引入的<span class="class"><span class="keyword">class</span>文件解析完毕后, 再准备加载之前, 进行排序, 然后一一加载.</span></span><br></pre></td></tr></table></figure>



<h5 id="各种-AutoConfiguration-实现大致流程"><a href="#各种-AutoConfiguration-实现大致流程" class="headerlink" title="各种 AutoConfiguration 实现大致流程."></a>各种 <code>AutoConfiguration</code> 实现大致流程.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1) 首先是 @SpringBootApplication 启用了 @EnableAutoConfiguration</span><br><span class="line">2) @EnableAutoConfiguration 又使用 @Import 导入了 AutoConfigurationImportSelector.class</span><br><span class="line">3) 然后 AutoConfigurationImportSelector 导入 spring.factories所有的 EnableAutoConfiguration</span><br><span class="line">4) 最后，当一个项目依赖一个starter-xxx，会继承starter的依赖项, spring-boot-autoconfigure 由此被依赖</span><br><span class="line">5) spring-boot-autoconfigure 带有所有 boot 实现的 AutoConfiguration 和 spring.factories 配置</span><br><span class="line">6) 所以会加载该项目下 spirng.factories 中定义的 EnableAutoConfiguration</span><br><span class="line">7) 每个 AutoConfiguration 实现类被导入到容器中后</span><br><span class="line">	又被 ConfigurationClassPostProcessor 解析@Configuration, @Import 等注解 (老千层饼了)</span><br><span class="line">	这些AutoConfiguration会添加一些提供服务的 bean，或者再嵌套一层@Import，@Configuration等。</span><br><span class="line">	另外, 这些bean还是被自动配置了属性值的, 属性值哪里来? 都在 application.yml 中, 或是默认配置中.</span><br><span class="line">9) 这样，容器中就加入了一个或多个配置好的bean了, 可以直接使用. 如 stringRedisTemplate, jdbcTemplate</span><br></pre></td></tr></table></figure>

<h5 id="Spring-Boot-是如何自动扫描main方法所在类所在包的"><a href="#Spring-Boot-是如何自动扫描main方法所在类所在包的" class="headerlink" title="Spring Boot 是如何自动扫描main方法所在类所在包的?"></a>Spring Boot 是如何自动扫描main方法所在类所在包的?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) 首先是 @SpringBootApplication 启用了 @EnableAutoConfiguration</span><br><span class="line">2) @EnableAutoConfiguration 又使用 @AutoConfigurationPackage</span><br><span class="line">3) @AutoConfigurationPackage 中的 @Import 会被解析, Registrar.class 的registerBeanDefinitions会被执行</span><br><span class="line">4) 最终根据带有 @SpringBootApplication 的类对应的包名, 然后自动扫描到容器中, 效果同 @ComponentScan</span><br></pre></td></tr></table></figure>

<h5 id="application-properties-是如何被加载到Environment中的"><a href="#application-properties-是如何被加载到Environment中的" class="headerlink" title="application.properties 是如何被加载到Environment中的?"></a><code>application.properties</code> 是如何被加载到Environment中的?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) run方法中创建了Environment对象, 当初始化好一些东西后会触发事件</span><br><span class="line"><span class="number">2</span>) 通过 SpringApplicationRunListeners 的 environmentPrepared() 告知监听者</span><br><span class="line"><span class="number">3</span>) 默认存在 spring.factories 中的 EventPublishingRunListener 监听者负责转发事件</span><br><span class="line"><span class="number">4</span>) 事件被转发到 ApplicationListener 下的监听者来处理</span><br><span class="line"><span class="number">5</span>) 监听者配置在 spring.factories 中, 其中 ConfigFileApplicationListener 监听了此事件</span><br><span class="line"><span class="number">6</span>) 此监听者接受 ApplicationEnvironmentPreparedEvent 事件后</span><br><span class="line"><span class="number">7</span>) 加载一些 postProcessor 专门用于处理 environment 对象的 postProcessor</span><br><span class="line"><span class="number">8</span>) 其他的 postProcessor 暂时不管, 真正做了加载的是 postProcessors.add(<span class="keyword">this</span>); 自己的实现</span><br><span class="line"><span class="number">9</span>) 自己的处理方法是: addPropertySources(), 此方法将会扫描指定的路径下指定的某些文件</span><br><span class="line"><span class="number">10</span>) 然后使用 spring.factories 下的 PropertySourceLoader 一一尝试解析</span><br><span class="line"><span class="number">11</span>) 文件存在且解析正确则加入到 environment 的 propertySources.</span><br><span class="line">	某些路径: getSearchLocations() ,默认: classpath:/,classpath:/config/ ...</span><br><span class="line">	某些文件: getSearchNames() ,默认: application</span><br><span class="line"></span><br><span class="line">TIPS: </span><br><span class="line">PropertySourceLoader 有 PropertiesPropertySourceLoader/YamlPropertySourceLoader</span><br><span class="line">一个尝试后缀有 xml/properties, 另一个是 yml/yaml, 所以所有可能性有:</span><br><span class="line">    classpath:/application.xml; classpath:/application.properties</span><br><span class="line">	classpath:/application.yml; classpath:/application.yaml</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<h5 id="SpringApplication-run-如何加载-tomcat-的"><a href="#SpringApplication-run-如何加载-tomcat-的" class="headerlink" title="SpringApplication.run() 如何加载 tomcat 的?"></a><code>SpringApplication.run()</code> 如何加载 tomcat 的?</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) boot 的 run 里面会创建 applicationContext, 如是 webApplicationType = SERVLET, 则实现类为 AnnotationConfigServletWebServerApplicationContext</span><br><span class="line">    另外一提, webApplicationType 是根据 classpath 下是否有哪些类来推断的.</span><br><span class="line"><span class="number">2</span>) 这个类继承了 ServletWebServerApplicationContext</span><br><span class="line"><span class="number">3</span>) ServletWebServerApplicationContext 实现了 onRefresh()</span><br><span class="line"><span class="number">4</span>) onRefresh() 调用了 createWebServer()</span><br><span class="line"><span class="number">5</span>) createWebServer() 使用 ServletWebServerFactory.getWebServer() 获取 webServer 对象</span><br><span class="line"><span class="number">6</span>) ServletWebServerFactory 会被 ServletWebServerFactoryAutoConfiguration 引入</span><br><span class="line">    详细见 ServletWebServerFactoryConfiguration.EmbeddedTomcat<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">7) 引入后调用 <span class="title">getWebServer</span>(), 大概为 <span class="title">new</span> <span class="title">Tomcat</span>(), 设置属性, 然后启动.</span></span><br><span class="line"><span class="class">8) 至此, <span class="title">run</span>() 启动了 <span class="title">tomcat</span> 或 <span class="title">jetty</span>/<span class="title">undertow</span>.</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line">TIPS:</span><br><span class="line">spring 使用工厂模式获取webServer, 然后工厂又通过AutoConfiguration自动注入(还会判断Condition).</span><br><span class="line">    这样如果新增一种 webServer, 只需要在写一个 AutoConfiguration 注入一个 工厂即可. 非常灵活.</span><br></pre></td></tr></table></figure>





<h3 id="Spring-MVC-源码"><a href="#Spring-MVC-源码" class="headerlink" title="Spring MVC 源码"></a>Spring MVC 源码</h3><h4 id="关键类解析-1"><a href="#关键类解析-1" class="headerlink" title="关键类解析"></a>关键类解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">WebMvcConfigurationSupport</span><br><span class="line">	默认注册了很多东西,如HandlerMapping几个实现, HandlerAdaptor几个实现</span><br><span class="line"></span><br><span class="line">HandlerMapping</span><br><span class="line">	添加容器内所有带有RequestMaping的类的公开方法到 mappings 中</span><br><span class="line">		(AbstractHandlerMethodMapping#afterPropertiesSet中)</span><br><span class="line">    根据request的uri查找对应的HandlerMethod, 步骤概述:</span><br><span class="line">    	把RequestMapping注解内的path作为key保持到一个map1</span><br><span class="line">    	其他信息封装成mapping作为key也保持到另一个map2</span><br><span class="line">    	根据uri去 map1 获取 mapping, 再根据mapping 获取 HandlerMethod</span><br><span class="line">    	封装成Match对象, 与其他匹配对象做比较后, 返回 HandlerMethod</span><br><span class="line"></span><br><span class="line">HandlerAdapter</span><br><span class="line">	初始化参数解析，返回值解析等</span><br><span class="line">		(RequestMappingHandlerAdapter#afterPropertiesSet)</span><br><span class="line">	根据Handle确定对应的HandlerAdapter, 然后执行这个 handler</span><br><span class="line">    如RequestMappingHandlerAdapter 则负责执行 HandlerMethod</span><br><span class="line">    	简单说就是封装 HandlerMethod, 根据参数值设置参数, 然后调用方法, 再处理返回值封装成ModelAndView</span><br><span class="line">    另外， 这里如果使用了@ResponseBody，会进入 RequestResponseBodyMethodProcessor</span><br><span class="line">    	然后使用messageConverters（json）写入到响应流</span><br><span class="line">    	最后mv也直接返回null， 不需要render了。</span><br><span class="line"></span><br><span class="line">ViewResolver</span><br><span class="line">	负责将ModelAndView解析成HTML, 如JSP, FreeMarker</span><br><span class="line"></span><br><span class="line">HandlerExecutionChian</span><br><span class="line">	管理拦截器和封装Handler, 负责拦截器的实际调用逻辑实现</span><br><span class="line">	</span><br><span class="line">DispatcherServlet</span><br><span class="line">	调度整个HTTP请求响应流程, 调用各个子组件负责执行处理方法, 解析视图, 处理异常等.</span><br></pre></td></tr></table></figure>

<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET</span><br><span class="line">HttpServlet#service()</span><br><span class="line">HttpServlet#doGet()</span><br><span class="line">FrameworkServlet#doGet()</span><br><span class="line">FrameworkServlet#processRequest()</span><br><span class="line">FrameworkServlet#doService()</span><br><span class="line">DispatcherServlet#doService()</span><br><span class="line">DispatcherServlet#doDispatch()</span><br><span class="line">	调用容器内所有的HandlerMapping的实现类的getHandler方法, 返回HandlerExecutionChain</span><br><span class="line">	调用容器内所有的HandlerAdaptor的实现类寻找适合的当前Hanlder的HandlerAdaptor</span><br><span class="line">	执行拦截器的 preHandle 方法, 并根据返回结果判断是否接续执行</span><br><span class="line">	HandlerAdaptor执行handle方法</span><br><span class="line">	进入RequestMappingHandlerAdaptor执行handle-&gt;handlerInternal-&gt;invokeHandlerMethod</span><br><span class="line">	生成ServletInvocableHandlerMethod(就是实现了反射调用方法和设置参数,处理返回值等操作)</span><br><span class="line">	调用invokeAndHandle--&gt;invokeForRequest</span><br><span class="line">		其中getMethodArgumentValues挨个调用HandlerMethodArgumentResolver获取参数值</span><br><span class="line">	然后执行 doInvoke, 利用反射技术调用 Method, method.invoke(obj, args);</span><br><span class="line">	执行完后, 返回结果, 回到 invokeAndHandle 调用 returnValueHandlers 处理返回结果</span><br><span class="line">	返回后 回到 invokeHandlerMethod, 调用 getModelAndView 获取通用的返回值(可能是空)</span><br><span class="line">	返回ModelAndView后, 回到doDispatch, 设置默认viewName (mv为空则不需要设置)</span><br><span class="line">	执行拦截器的 postHandle 方法</span><br><span class="line">	processDispatchResult 中的 render 解析视图后通过response 响应这个view</span><br><span class="line">	根据异常情况执行异常处理器, 以及执行拦截器的 afterCompletion 方法</span><br></pre></td></tr></table></figure>

<h4 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">何时加入?</span><br><span class="line">	从WebMvcConfigurationSupport的子类中调用addInterceptors </span><br><span class="line">	添加一些拦截器和拦截器的路径配置 InterceptorRegistry 和 MappedInterceptor</span><br><span class="line">    实现拦截器路径匹配, 在 new HandlerExecutionChian 时判断</span><br><span class="line"></span><br><span class="line">何时执行?</span><br><span class="line">	DispatcherServlet 负责在正确的时机调用 HandlerExecutionChian 来调用 preHanlde 等方法.</span><br><span class="line">	拿到 HandlerExecutionChian 后调用 preHanlde</span><br><span class="line">	HandlerAdapter执行完handler后, 调用 postHandle</span><br><span class="line">	解析视图并渲染到response之后, 调用 afterCompletion</span><br><span class="line">	如果中途出现异常, 或preHandle提前结束, 则也调用afterCompletion</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">	DispatcherServlet 去调用 HandlerExecutionChian去调用 拦截器具体方法. </span><br><span class="line">	复杂点是添加一个拦截器到被加入到HandlerExecutionChian比较复杂一点, 以及带路径匹配的拦截器实现略复杂一些.</span><br></pre></td></tr></table></figure>



<h3 id="Mybatis-源码"><a href="#Mybatis-源码" class="headerlink" title="Mybatis 源码"></a><code>Mybatis</code> 源码</h3><h4 id="关键类解析-2"><a href="#关键类解析-2" class="headerlink" title="关键类解析"></a>关键类解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Configuration</span><br><span class="line">	作用: 解析和保存大配置(mybatis全局配置,如数据库连接, 别名等), 小配置(每个mapper文件)信息</span><br><span class="line"></span><br><span class="line">MapperProxy, MapperMethod</span><br><span class="line">	作用: 生成daoImpl代理对象和实现接口方法: 调用sqlSession 操作方法</span><br><span class="line"></span><br><span class="line">Executor</span><br><span class="line">	作用: 协调和管理StatementHandler, ParameterHandler, ResultSetHandler, 解析mapperStatement配置信息成BoundSql.</span><br><span class="line"></span><br><span class="line">StatementHandler</span><br><span class="line">	作用: 生成preparedStatment对象(JDBC的), 调用execute方法.</span><br><span class="line"></span><br><span class="line">ParameterHandler</span><br><span class="line">	作用: 管理并使用TypeHandler为preparedStatment对象设置参数,</span><br><span class="line"></span><br><span class="line">ResultSetHandler</span><br><span class="line">	作用: 将ResultSet结果集转成接口返回值认识的数据, 负责延迟加载.</span><br></pre></td></tr></table></figure>

<h4 id="生命周期与执行流程"><a href="#生命周期与执行流程" class="headerlink" title="生命周期与执行流程"></a>生命周期与执行流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.读取配置文件, 解析xml(或properties)获得配置信息(数据库配置和mapperSql等) Configuration</span><br><span class="line">2.获取数据库连接, 开启事务, 准备执行sql (openSession)</span><br><span class="line">3.使用动态代理技术生成代理类</span><br><span class="line">4.代理类根据代理方法对应的mapperStatement类型调用sqlSession的insert,update,delete,selectXxx方法 (MapperProxy, MapperMethod)</span><br><span class="line">4.sqlSession调用Executor执行sql (Exector, SimpleExecutor, CachingExecutor)</span><br><span class="line">5.Executor 生成StatementHandler对象并解析xml中sql参数, 再使用ParameterHandler设置参数. (BaseExecutor, StatmentHandler, ParameterHandler, TypeHandler 前三个可被插件拦截任意方法)</span><br><span class="line">6.最后使用OGNL表达式解析库对 if,foreach,where等标签解析生成最总sql (ONGL)</span><br><span class="line">7.执行sql后获得resultSet, 使用 ResultSetHandler 处理后返回结果(resultMap, resultType的处理在这里) (ResultSetHandler 可被插件拦截任意方法)</span><br><span class="line">8.根据事务配置提交事务(自动提交), 保存一级缓存</span><br><span class="line">9.如开启二级缓存, Executor还会被装饰器模式包装一层, 将结果缓存到MapperStatement的cache变量中.</span><br><span class="line"></span><br><span class="line">TIPS:</span><br><span class="line">1.插件的使用实在Executor, StatementHandler, ParameterHandler, ResultSetHandler这几个对象实例化的时候, 使用jdk动态代理将配置里配置的形成代理链. 返回代理对象, 但调用方法时, 会判断是否拦截此方法并执行插件的代码.</span><br></pre></td></tr></table></figure>

<h4 id="使用到的设计模式"><a href="#使用到的设计模式" class="headerlink" title="使用到的设计模式"></a>使用到的设计模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.代理模式</span><br><span class="line">	MapperProxy 生成 mapper 实现类 jdk代理</span><br><span class="line">	Plugin 生成代理对象实现插件 jdk代理</span><br><span class="line">	ResultSetHandler(LazyLoad) cblib, javassist</span><br><span class="line">2.装饰者模式</span><br><span class="line">	CachingExecutor: 装饰SimpleExecutor添加二级缓存功能</span><br><span class="line">	Cache,FifoCache... 使用装饰者模式为缓存添加不同特性(功能)</span><br><span class="line">3.适配器模式</span><br><span class="line">	StatementHandler</span><br><span class="line">4.责任链模式</span><br><span class="line">	Interceptor(拦截Executor、StatementHandler、ParameterHandler、ResultSetHandler对象)</span><br><span class="line">5.策略模式			</span><br><span class="line">	StatementHandler</span><br><span class="line">		PreparedStatementHandler,CallableStatementHandler,SimpleStatementHandler</span><br><span class="line">	Executor</span><br><span class="line">		SimpleExecutor,ReuseExecutor,BatchExecutor</span><br><span class="line">	TypeHandler</span><br><span class="line">		UnknownTypeHandler, IntegerTypeHandler, NStringTypeHandler</span><br><span class="line">6.建造器模式</span><br><span class="line">	org.apache.ibatis.mapping.MappedStatement.Builder</span><br><span class="line">	org.apache.ibatis.builder.xml.XMLConfigBuilder</span><br></pre></td></tr></table></figure>

<h4 id="一级缓存实现"><a href="#一级缓存实现" class="headerlink" title="一级缓存实现"></a>一级缓存实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.put时机: </span><br><span class="line">	org.apache.ibatis.executor.BaseExecutor#queryFromDatabase 的 localCache.putObject(key, list)</span><br><span class="line">	</span><br><span class="line">2.get时机:</span><br><span class="line">	org.apache.ibatis.executor.BaseExecutor#query 的 localCache.getObject(key)</span><br><span class="line">	</span><br><span class="line">3.存在哪里</span><br><span class="line">	org.apache.ibatis.executor.BaseExecutor#localCache</span><br><span class="line">	这个类每次openSession会新建一个Executor实例</span><br></pre></td></tr></table></figure>

<h4 id="二级缓存实现"><a href="#二级缓存实现" class="headerlink" title="二级缓存实现"></a>二级缓存实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.put时机: </span><br><span class="line">	org.apache.ibatis.executor.CachingExecutor#query的tcm.putObject</span><br><span class="line">	然后实际上是调用了cache的put, cache实际上来自Configuration解析mapper文件时创建的, 即同一个mapper共用同一个cache.</span><br><span class="line">	</span><br><span class="line">2.get时机:</span><br><span class="line">	org.apache.ibatis.executor.CachingExecutor#query的tcm.getObject, cache实际是: 同上</span><br><span class="line"></span><br><span class="line">3.remove时机:</span><br><span class="line">	org.apache.ibatis.executor.CachingExecutor#flushCacheIfRequired</span><br><span class="line"></span><br><span class="line">注意事项: 上述时机都是TransactionCacheManager的调用, 而TransactionCacheManager会根据事务的提交和回滚来处理缓存的写入与移除时机, 如真实移除时机是下一次commit触发, 真实写入也是commit时触发.</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">4.存在哪里</span><br><span class="line">	org.apache.ibatis.mapping.MappedStatement</span><br><span class="line">	也算是在 org.apache.ibatis.session.Configuration 中</span><br></pre></td></tr></table></figure>





<h3 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a><code>Mybatis-Plus</code></h3><h2 id="IO-网络"><a href="#IO-网络" class="headerlink" title="IO / 网络"></a>IO / 网络</h2><h3 id="AIO-NIO-BIO"><a href="#AIO-NIO-BIO" class="headerlink" title="AIO, NIO, BIO"></a>AIO, NIO, BIO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BIO: 从 jdk1.4 前, 采用 ServerSocket API 进行网络连接, 所有操作都是阻塞的(如监听, 读&#x2F;写)</span><br><span class="line">NIO: 从 jdk1.4 起, 对于所有操作都是依赖事件驱动, 只需较少的线程即可处理大量请求</span><br><span class="line">AIO: jdk1.7 起, 在 NIO 基础上实现异步, 所有事件通知由系统通知, 而非NIO 那样轮询</span><br></pre></td></tr></table></figure>

<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TCP: 是面向连接的协议, 收发数据前, 必须建立可靠的连接(通过三次握手)</span><br><span class="line">UDP: 是无连接的协议, 收发数据不需要建立连接(握手)</span><br><span class="line"></span><br><span class="line">区别:</span><br><span class="line">速度: TCP 满, UDP 快</span><br><span class="line">正确性&#x2F;完整性: TCP 好, UDP 无</span><br><span class="line">顺序性: TCP 好, UDP 无</span><br><span class="line"></span><br><span class="line">应用:</span><br><span class="line">TCP: 文件下载, HTTP, DNS, IM 通讯</span><br><span class="line">UDP: 网络游戏, 直播推流</span><br></pre></td></tr></table></figure>

<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><blockquote>
<p>封装了复杂的NIO接口, 提供了简单的 API 实现服务端和客户端高并发通讯, 并封装了很多工具, 如心跳超时, 半包处理, websocket 等.</p>
</blockquote>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="队列-栈"><a href="#队列-栈" class="headerlink" title="队列,  栈"></a>队列,  栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">队列: 先进先出 FIFO</span><br><span class="line">栈: LIFO</span><br></pre></td></tr></table></figure>

<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单向链表: Node&#123;next: Node&#125;</span><br><span class="line">双向链表: Node&#123;prev: Node, next: Node&#125;</span><br><span class="line">循环链表: Node&#123;first: Node, last: Node, prev: Node, next: Node&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">二叉树:</span><br><span class="line">	先序遍历: 根-&gt;左-&gt;右</span><br><span class="line">	中序遍历: 左-&gt;根-&gt;右</span><br><span class="line">	后序遍历: 左-&gt;右-&gt;根</span><br><span class="line"></span><br><span class="line">红黑树:</span><br><span class="line">	红黑树是一种含有红黑结点并能自平衡的二叉查找树.</span><br><span class="line">	任意一结点到每个叶子结点的路径都包含数量相同的黑结点.</span><br><span class="line">	速度: O(log2 n) 最坏: O(log n)</span><br><span class="line">	对比 BST: 查找更快, 插入更慢.</span><br><span class="line">	对比 AVL: 查找略慢, 插入更快.</span><br><span class="line">	</span><br><span class="line">B+树:</span><br><span class="line">	所有记录节点存放在叶子节点上，且是顺序存放，由各叶子节点指针进行连接。</span><br><span class="line">	如果从最左边的叶子节点开始顺序遍历，能得到所有键值的顺序排序。</span><br><span class="line">	查找速度和树高度有关, 如 MySQL 树高度为 3, 则总是查询 3 次找到子节点, 即得到数据.</span><br></pre></td></tr></table></figure>



<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">快速排序: O(nlog(n))</span><br><span class="line">	将数组分为2半，并计算一个中间值，将左边所有大于中间值的移到右边，把右边所有小于中间值的移到左边，</span><br><span class="line">	然后分别对左边和右边递归处理（再分2半，再取中间值，再移动，再递归），直到无需递归为止。</span><br><span class="line"></span><br><span class="line">归并排序: O(nlog(n))</span><br><span class="line">	将数组不断两两拆分，直到无法拆分（只有2个元素）时开始对拆分后的元素进行排序，然后不断回溯，</span><br><span class="line">	不断排序，直到第一次拆分，即所有元素都是有序的了。排序方式为先取两个部分的第一个下标，</span><br><span class="line">	互相判断，谁小谁放到有序数组中，然后小的那个下标移位，继续判断，直到其中一个部分所有元素取完，</span><br><span class="line">	则将另一部分剩余元素批量直接拷贝到有序数组即可。</span><br><span class="line"></span><br><span class="line">冒泡排序: O(n^2) 最好 O(n)</span><br><span class="line">	进行 n - 1 轮， 每轮遍历数组两两比较交换，从而达到把最大的交换到最后面。下轮遍历数组个数减一。</span><br><span class="line"></span><br><span class="line">选择排序: O(n^2)</span><br><span class="line">	进行 n - 1 轮，每轮遍历选择数组最小值放到最前面，下轮遍历数组个数减一</span><br><span class="line"></span><br><span class="line">插入排序: O(n^2) 最好 O(n)</span><br><span class="line">	分2个数组，有序和无序，开局有序默认含有数组第一个元素，无序含有剩余的元素。</span><br><span class="line">	遍历无序所有元素，从后向前比较大小，然后进行插入到有序数组中或对数组元素移位。</span><br><span class="line"></span><br><span class="line">希尔排序: O(n^1.25)</span><br><span class="line">	对数组进行分组，对每组使用插入排序的移位进行排序，第一次分 数组长度&#x2F;2 组，</span><br><span class="line">	下一次分组为数组长度&#x2F;2再&#x2F;2组，若分 长度&#x2F;2 组，则每组2个， 若分 长度&#x2F;2&#x2F;2 组，</span><br><span class="line">	则每组 2*2 个，直到长度为1. 这是一个将数组后段数据尽可能与前段数据排序，</span><br><span class="line">	改进插入排序后端数据过小导致移位操作过多的问题。</span><br><span class="line"></span><br><span class="line">基数排序: O(n)</span><br><span class="line">	创建10个桶，每个桶大小均为数组长度，然后遍历数组，从元素的最低位（个位）开始，</span><br><span class="line">	取出并放到对应的桶（如个位是8，则放到第8个桶中），放完后，顺序遍历所有桶，</span><br><span class="line">	顺序取出每个元素，组成新数组，再将新数组按以上流程处理十位，再百位，直到数组中的最大数的最高位。</span><br><span class="line">	</span><br><span class="line">堆排序：</span><br><span class="line">	。。。</span><br></pre></td></tr></table></figure>

<h4 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">贪心算法</span><br><span class="line">爬山算法</span><br><span class="line">模拟退火算法</span><br><span class="line">遗传算法</span><br><span class="line">蚁群搜索算法</span><br></pre></td></tr></table></figure>



<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="7-大原则"><a href="#7-大原则" class="headerlink" title="7 大原则"></a>7 大原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单一职责: 每个类只负责一个职责(或每个方法)</span><br><span class="line">接口隔离: 一个类对另一个类的依赖应建立在最小的接口上</span><br><span class="line">依赖倒转: 高层模块不应依赖低层模块, 二者都应该依赖接口而非细节. 细节依赖抽象, 面向接口编程</span><br><span class="line">里式替换: 子类应该做到可以替换父类, 及子类应尽量不重写父类方法.</span><br><span class="line">开闭原则: 对提供者而已可以修改, 对使用者而言不需要修改(即代码兼容性), 尽量使用扩展增加功能, 而非修改原有类</span><br><span class="line">迪米特法则: 一个对象应该对其他对象保持最小了解(最少知道原则)</span><br><span class="line">合成复用原则: 一个类使用另一个类的代码(方法), 尽量使用合成, 而不是继承</span><br></pre></td></tr></table></figure>



<h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原理: 确保一个类只有一个实例，并提供该实例的全局访问点。</span><br><span class="line"></span><br><span class="line">饿汉式:</span><br><span class="line">	静态常量</span><br><span class="line">	静态代码块</span><br><span class="line">懒汉式:</span><br><span class="line">	直接判断(线程不安全)</span><br><span class="line">	方法加 synchronized(线程安全, 效率低)</span><br><span class="line">	判断后再同步(错误写法)</span><br><span class="line">	双重判断(if-同步-if) (推荐写法)</span><br><span class="line">	匿名静态内部类 (简单, 推荐)</span><br><span class="line">	枚举(简单, 但对象方法写在枚举中, 略有不适)</span><br><span class="line">	</span><br><span class="line">示例:</span><br><span class="line">	java.lang.Runtime#getRuntime()</span><br><span class="line">	java.awt.Desktop#getDesktop()</span><br></pre></td></tr></table></figure>

<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原理: 使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象.</span><br><span class="line">示例: Java 的 Object 对象的 clone 方法, java.util.Arrays.ArrayList#toArray()</span><br><span class="line"></span><br><span class="line">浅拷贝: 仅对基础类型及字符串类型的字段拷贝值</span><br><span class="line">深拷贝: 同时对引用类型(如数组,对象) 也进行拷贝</span><br><span class="line"></span><br><span class="line">深拷贝实现:</span><br><span class="line">1.重写 clone, 一一处理每个引用对象(调用对象的 clone), 麻烦, 且若对象之间关系复杂, 其中一个未实现深拷贝则导致 bug.</span><br><span class="line">2.利用序列化和反序列化, 如 Json, 或 Java 自带的序列化方式(二进制)</span><br></pre></td></tr></table></figure>

<h4 id="创建者模式-生成器模式"><a href="#创建者模式-生成器模式" class="headerlink" title="创建者模式(生成器模式)"></a>创建者模式(生成器模式)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	封装一个对象的构造过程，并允许按步骤构造.</span><br><span class="line">	若对象的生成过于复杂(字段极多且赋值还有依赖关系, 需要顺序调用), 则可将赋值过程封装成一个build(), 并放到一个 Builder 类中. 此类对外提供各个字段的赋值方法并先保存起来, 直到调用 build(), 此方法返回对象实例. </span><br><span class="line">	使用此模式, 调用者无需关注构建过程, 只需设置自己想要的值, 然后调用 build() 即可得到对象实例. 且若增加或修改字段, 构造过程变化, 调用者无感知, 无需修改代码. 符合开闭原则.</span><br><span class="line"></span><br><span class="line">示例: StringBuilder, 一些框架的 ConfigurationBuilder(如 xmpp), 用于构建配置.</span><br></pre></td></tr></table></figure>

<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</span><br><span class="line">	此模式可避免多个调用者创建对象时判断创建哪个子类的重复代码, 且若多一个子类, 调用者无需修改代码.</span><br><span class="line">	</span><br><span class="line">示例: Spring ApplicationContext 的 getBean 方法.</span><br></pre></td></tr></table></figure>

<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</span><br><span class="line">	此模式解决了简单工厂每增加一个子类需要修改工厂类的问题.</span><br><span class="line">	此模式存在问题, 若新增一个子类, 需同时新增一个子类工厂, 系统复杂性更高.</span><br><span class="line"></span><br><span class="line">示例: Calendar, NumberFormat</span><br></pre></td></tr></table></figure>

<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	提供一个接口，用于创建 相关的对象家族.</span><br><span class="line">  同上, 由子类工厂决定创建哪些对象.</span><br><span class="line">	此模式是工厂方法的升级版, 不同之处在于它同时创建多个种类的对象(工厂类具有多个方法).</span><br><span class="line">	此模式将一个对象家族的新建集合到一个工厂类创建管理, 这些对象家族相互之间一般有关联, 在创建时就可以处理这些关联. 且对于 2 个子类工厂, 一般可以无缝切换, 使得修改代码极为方便(即换一个子类工厂).</span><br><span class="line">	此模式在新增一个对象家族的成员时非常麻烦(即所有工厂类需要新增一个方法), 但再新增一类对象家族时比较简单(即新增一个子类工厂).</span><br></pre></td></tr></table></figure>



<h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	把一个接口转换成另一个用户需要的接口.</span><br><span class="line">	定义一个类, 实现用户需要的接口, 并聚合一个需要转换的接口对象, 在重写的方法(用户需要的方法)中调用聚合的对象的方法, 若需要返回值, 且返回值类型不一致, 则还需要在方法中处理一番, 然后返回. 这个过程叫做适配.这个类叫做适配器类.</span><br><span class="line">	使用此模式可对一些老旧接口适配兼容.</span><br><span class="line">	</span><br><span class="line">示例: java.util.Arrays#asList() 将数组适配成 List, Spring MVC的 HandlerAdapter</span><br></pre></td></tr></table></figure>

<h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	将一个或多个功能(方法)动态的新增到一个类中.</span><br><span class="line">	把需要新增功能类称为 A,定义一个类B,实现A的上层接口, 并聚合一个A 的实例对象, B类实现的接口中, 对其他不关心的方法直接调用聚合的对象的方法. 对于关心的方法则可以在调用前后进行加料处理(如一个方法返回一个数, 可以在原来的返回值上乘以 2), 同时, B类也可以新增一些其他方法, 这些方法就是多出的功能. B类就是装饰者类, A就是被装饰类.</span><br><span class="line">	此模式的优点是, 装饰类也可以当做被装饰类, 然后再来一层装饰, 可以无限的装饰.</span><br><span class="line">	</span><br><span class="line">示例: java IO 流</span><br></pre></td></tr></table></figure>

<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	控制其他对象的访问(方法级), 将一些前置或后置的处理, 通过代理对象注入到目标对象的方法前后. 面向切面编程.</span><br><span class="line"></span><br><span class="line">类型:</span><br><span class="line">	静态代理: 定义一个代理类实现目标对象的上层接口, 并聚合一个目标对象, 重写方法时将前置后置处理加上.</span><br><span class="line">	动态代理: </span><br><span class="line">		JDK 动态代理: 需要目标对象有上层接口(自然接口内的方法才可以代理) </span><br><span class="line">			使用java.lang.reflect.Proxy#getProxyClass</span><br><span class="line">		CGLIB 动态代理: 是个类就行. 实现原理是 ASM 框架动态生成目标对象类的子类字节码, 然后通过反射生成代理对象.</span><br><span class="line"></span><br><span class="line">示例: Spring AOP</span><br></pre></td></tr></table></figure>

<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	将抽象与实现分离开来，使它们可以独立变化。</span><br><span class="line">	桥接的含义是, 一个桥, 放在哪里都有桥的 2 边, 桥的 2 边可以变化, 但桥始终不变. 此处, 桥代表一个操作(如手机上运行软件), 2 边代表 一个操作的 2 个维度(如手机和软件). 同时, 桥接后的操作也可以视为一个维度, 与另一个维度桥接(如手机上运行软件和人这 2 个维度, 可以进行桥接, 组成 3 维度嵌套桥接).</span><br><span class="line">	</span><br><span class="line">示例: JDBC 获取连接, 获取连接是一个维度, 数据库是一个维度, 数据库有多个, 所以这是一个数据库维度变化, 另一维度不变的桥接模式.</span><br></pre></td></tr></table></figure>

<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</span><br><span class="line">	如常见的 线程池, 常量池等, 使得对象的获取速度加快.</span><br><span class="line">	</span><br><span class="line">示例: java.lang.Integer#valueOf() java.lang.Boolean#valueOf()</span><br></pre></td></tr></table></figure>

<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	将对象组合成树形结构来表示“整体&#x2F;部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</span><br><span class="line">	一般需要部分和整体具有一定的相似度, 才能对其进行抽象.</span><br><span class="line">	对部分&#x2F;整体进行抽象, 得出一个公共抽象类或接口, 再实现类中根据具体角色做不同处理. </span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">	javax.swing.JComponent#add(Component) </span><br><span class="line">  java.util.Map#putAll(Map)</span><br><span class="line">  java.util.List#addAll(Collection)</span><br><span class="line">  java.util.Set#addAll(Collection)</span><br></pre></td></tr></table></figure>

<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用.</span><br></pre></td></tr></table></figure>



<h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><h4 id="职责链-责任链-模式"><a href="#职责链-责任链-模式" class="headerlink" title="职责链(责任链)模式"></a>职责链(责任链)模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	使多个对象都有机会处理请求，将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止, 从而避免请求的发送者和接收者之间的耦合关系。</span><br><span class="line">	</span><br><span class="line">示例:</span><br><span class="line">	javax.servlet.Filter#doFilter()</span><br><span class="line">	netty 的 Handler Chain</span><br></pre></td></tr></table></figure>

<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</span><br><span class="line">	主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</span><br><span class="line"></span><br><span class="line">示例: </span><br><span class="line">	swing 的事件监听(按钮事件, 鼠标事件)</span><br><span class="line">	JS 的 事件监听</span><br></pre></td></tr></table></figure>

<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</span><br><span class="line">	状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为.</span><br></pre></td></tr></table></figure>

<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	定义一系列算法，封装每个算法，并使它们可以互换。</span><br><span class="line">	策略模式可以让算法独立于使用它的客户端。</span><br><span class="line">	策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法.</span><br><span class="line"></span><br><span class="line">示例: java.util.Comparator#compare() javax.servlet.http.HttpServlet</span><br></pre></td></tr></table></figure>

<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	定义算法框架，并将一些步骤的实现延迟到子类。</span><br><span class="line">	通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</span><br><span class="line"></span><br><span class="line">示例: java.util.Collections#sort()</span><br></pre></td></tr></table></figure>

<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	将一个对象(命令接收者)的每个操作拆分到每一个命令类中, 再使用一个命令管理类来管理这些命令. 使得命令可以放入队列中有序执行, 且可以统一记录命令的操作日志, 还可以支持撤销操作(每个命令都实现对应的撤销即可).</span><br><span class="line">	此模式的好处是, 若将命令抽象为几个标准的命令(如开,关), 然后管理多个命令接收者(如灯,电视机,空调)的操作, 可使新增命令接收者变得简单, 即扩展性好.</span><br><span class="line">	</span><br><span class="line">	又称万能遥控器.</span><br></pre></td></tr></table></figure>

<h4 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	集中相关对象之间复杂的沟通和控制方式。降低子系统之间的耦合.</span><br><span class="line">	类似一个消息收发中心, 负责字系统的消息中转, 使得子系统之间可以进行一定的交互.</span><br><span class="line">	</span><br><span class="line">示例: 线程池管理者线程和要执行的任务.</span><br></pre></td></tr></table></figure>

<h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</span><br><span class="line">	如对游戏的当前状态进行一个保存, 然后在后续游戏中死亡后可以读取这个状态重新开始.</span><br></pre></td></tr></table></figure>

<h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原理: </span><br><span class="line">	为一个对象结构（比如组合结构）增加新能力。</span><br><span class="line">	使用访问者模式可实现重载的动态绑定(即伪双分派), 效果与重载方法内使用 instanceof 是一样的, 但使用访问者模式, 可扩展性更好.</span><br></pre></td></tr></table></figure>

<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</span><br><span class="line"></span><br><span class="line">示例: java.util.Iterator</span><br></pre></td></tr></table></figure>

<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	为语言创建解释器，通常由语言的语法和语法分析来定义。</span><br><span class="line"></span><br><span class="line">示例: EL 表达式, Freemaker模板</span><br></pre></td></tr></table></figure>

<h4 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原理:</span><br><span class="line">	使用什么都不做的空对象来代替 NULL, 避免空对象判断, 避免空指针异常.</span><br></pre></td></tr></table></figure>



<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><h3 id="Redis-缓存"><a href="#Redis-缓存" class="headerlink" title="Redis 缓存"></a>Redis 缓存</h3><h4 id="缓存穿透-攻击型"><a href="#缓存穿透-攻击型" class="headerlink" title="缓存穿透(攻击型)"></a>缓存穿透(攻击型)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">含义:</span><br><span class="line">	对于一个不存在的 key 进行访问, 会导致数据库不停地查询这个 key 进行缓存.</span><br><span class="line">	</span><br><span class="line">解决方案:</span><br><span class="line">	1.使用布隆过滤器, 一定不存在的数据会被过滤.</span><br><span class="line">	2.查询后缓存一个空结果, 但很快超时.(有缺点, 但简单)</span><br></pre></td></tr></table></figure>

<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">含义:</span><br><span class="line">	缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</span><br><span class="line">	</span><br><span class="line">解决方案:</span><br><span class="line">	1.设置超时时, 在原有的失效时间基础上增加一个随机值，比如1-5分钟随机</span><br><span class="line">	2.加锁或者队列的方式保证缓存的单线 程（进程）, 避免大量请求打到数据库.</span><br></pre></td></tr></table></figure>

<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">含义:</span><br><span class="line">	单一热点 key 失效时导致大量请求打到数据库。</span><br><span class="line"></span><br><span class="line">解决方案:</span><br><span class="line">	1.分布式互斥锁(redis,zookper)</span><br><span class="line">	2.添加超时字段记录超时(比实际超时小一些), 每次获取数据根据字段判断是否超时, 若是, 则马上延长超时字段, 然后加载数据库重新缓存</span><br><span class="line">	3.redis不设置过期, 通过添加超时字段判断, 超时则代码异步跑一个重新缓存的任务(这里代码需要先本地加锁, 再加分布式锁).</span><br></pre></td></tr></table></figure>



<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><blockquote>
<p>解耦, 异步, 削峰</p>
</blockquote>
<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义:</span><br><span class="line">	为面向服务的架构（SOA）提供基本的最终一致性实现. 即将 2 个系统的交互通过消息队列中转, 以防止某个系统临时挂了导致调用失败.</span><br><span class="line">示例: 下单系统调用库存系统, 若当时库存系统正好挂了, 则导致下单失败. 此时将请求放到消息队列中, 库存系统读取消息进行处理, 若当时库存挂了也没关系, 处理失败也没关系(可重试, 且重试代码比较简单).</span><br></pre></td></tr></table></figure>

<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义:</span><br><span class="line">	对于某些不要求返回值的耗时操作, 可异步处理.</span><br><span class="line">示例:</span><br><span class="line">	用户下单后, 需发送多个下单提醒(微信通知, 短信通知, 邮件通知), 每个操作都比较耗时, 可考虑将其放入消息队列后直接返回, 由另一段代码负责读取消息发送通知.</span><br></pre></td></tr></table></figure>

<h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义:</span><br><span class="line">	将请求高峰打平, 使得系统可以处理过来.</span><br><span class="line">示例:</span><br><span class="line">	某次秒杀 1 分钟过来 1 万请求, 而系统一分钟大概只能处理 1千 请求, 系统要处理完这些请求理论需要 10 分钟, 但如果不做处理, 请求瞬间打过来, 系统直接卡死, 卡住时候一分钟可能只能处理 100 请求. 此时需要将所有请求都打到队列里面, 系统再慢慢从队列中读取处理.</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/07/09/introduction-docer-savior/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/09/introduction-docer-savior/" class="post-title-link" itemprop="url">文档生成插件使用指南</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-09 11:07:44" itemprop="dateCreated datePublished" datetime="2021-07-09T11:07:44+08:00">2021-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-10 11:36:30" itemprop="dateModified" datetime="2021-07-10T11:36:30+08:00">2021-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/idea-plugin/" itemprop="url" rel="index"><span itemprop="name">idea-plugin</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/07/09/introduction-docer-savior/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/07/09/introduction-docer-savior/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文档生成插件使用指南"><a href="#文档生成插件使用指南" class="headerlink" title="文档生成插件使用指南"></a>文档生成插件使用指南</h1><h2 id="根据-Spring-MVC-Controller-下方法生成接口文档"><a href="#根据-Spring-MVC-Controller-下方法生成接口文档" class="headerlink" title="根据 Spring MVC Controller 下方法生成接口文档"></a>根据 Spring MVC Controller 下方法生成接口文档</h2><h3 id="先看示例代码"><a href="#先看示例代码" class="headerlink" title="先看示例代码"></a>先看示例代码</h3><h4 id="UserController"><a href="#UserController" class="headerlink" title="UserController"></a>UserController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.gudqs.business.docer.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.gudqs.business.docer.dto.request.ListUserRequest;</span><br><span class="line"><span class="keyword">import</span> cn.gudqs.business.docer.dto.response.BaseResponse;</span><br><span class="line"><span class="keyword">import</span> cn.gudqs.business.docer.dto.response.ListUserResponse;</span><br><span class="line"><span class="keyword">import</span> cn.gudqs.util.JsonUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/v1/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户信息(分页)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listUserPage 过滤条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户列表数据-分页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/listUser"</span>)</span><br><span class="line">    <span class="keyword">public</span> BaseResponse&lt;List&lt;ListUserResponse&gt;&gt; listUserPage(ListUserRequest listUserPage) &#123;</span><br><span class="line">        <span class="comment">// todo 查询分页数据</span></span><br><span class="line">        log.info(<span class="string">"listUserPage--&gt; "</span>+ JsonUtils.getJsonString(listUserPage));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BaseResponse.success(<span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BaseResponse"><a href="#BaseResponse" class="headerlink" title="BaseResponse"></a>BaseResponse</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.gudqs.business.docer.dto.response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码</span></span><br><span class="line"><span class="comment">     * 0: 代表成功</span></span><br><span class="line"><span class="comment">     * -1: 代表未知异常</span></span><br><span class="line"><span class="comment">     * &gt;0: 代表已知异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否成功</span></span><br><span class="line"><span class="comment">     * true: 代表成功, 此时 code = 0</span></span><br><span class="line"><span class="comment">     * false: 代表失败, 此时 code != 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页-总条数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long totalCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BaseResponse&lt;T&gt; <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BaseResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success(data, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个成功的 BaseResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 携带的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> totalCount 分页-总条数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> BaseResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BaseResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data, Long totalCount)</span> </span>&#123;</span><br><span class="line">        BaseResponse&lt;T&gt; baseResponse = <span class="keyword">new</span> BaseResponse&lt;&gt;();</span><br><span class="line">        baseResponse.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        baseResponse.setCode(<span class="number">0</span>);</span><br><span class="line">        baseResponse.setMessage(<span class="string">"success"</span>);</span><br><span class="line">        baseResponse.setData(data);</span><br><span class="line">        baseResponse.setTotalCount(totalCount);</span><br><span class="line">        <span class="keyword">return</span> baseResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ListUserResponse"><a href="#ListUserResponse" class="headerlink" title="ListUserResponse"></a>ListUserResponse</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.gudqs.business.docer.dto.response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUserResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户昵称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户手机号</span></span><br><span class="line"><span class="comment">     * #example 110</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户性别</span></span><br><span class="line"><span class="comment">     * 0: 保密</span></span><br><span class="line"><span class="comment">     * 1: 男</span></span><br><span class="line"><span class="comment">     * 2: 女</span></span><br><span class="line"><span class="comment">     * #example 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer userGender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户年龄</span></span><br><span class="line"><span class="comment">     * #example 1024</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer userAge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户头像地址</span></span><br><span class="line"><span class="comment">     * #example https://mp.weixin.com/p/jewagheiajifejgihewjg.ifew</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userAvatar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最近一次登录时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date lastLoginTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ListUserRequest"><a href="#ListUserRequest" class="headerlink" title="ListUserRequest"></a>ListUserRequest</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.gudqs.business.docer.dto.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户-过滤条件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUserRequest</span> <span class="keyword">extends</span> <span class="title">BasePageRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模糊搜索词</span></span><br><span class="line"><span class="comment">     * 支持用户昵称, 用户姓名, 用户手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String searchKeyword;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户性别</span></span><br><span class="line"><span class="comment">     * 0: 保密</span></span><br><span class="line"><span class="comment">     * 1: 男</span></span><br><span class="line"><span class="comment">     * 2: 女</span></span><br><span class="line"><span class="comment">     * #example 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤年龄范围-起始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer ageStart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤年龄范围-结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer ageEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤登录时间范围-开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date loginTimeStart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤登录时间范围-结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date loginTimeEnd;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BasePageRequest"><a href="#BasePageRequest" class="headerlink" title="BasePageRequest"></a>BasePageRequest</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.gudqs.business.docer.dto.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePageRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页-当前页码</span></span><br><span class="line"><span class="comment">     * #example 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页-分页大小</span></span><br><span class="line"><span class="comment">     * #example 20</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote>
<p>以上都是大家常写的分页代码，此时我在 <code>listUserPage</code> 这个方法上右键，弹出菜单中选择：生成Api接口文档（restful），如图</p>
</blockquote>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210710095319.png" alt="image-20210710095313814"></p>
<p>然后就会得到一个弹框，当然如果你根据提示点了 <code>OK</code>，则直到下次重启，都不会再出现</p>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210710113051.png" alt="image-20210710100138879"></p>
<p>弹框中内容如下，此内容区域可滚动预览，全选复制粘贴</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"># 查询用户信息(分页)</span><br><span class="line">## 请求信息</span><br><span class="line"></span><br><span class="line">### 请求地址</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">http:&#x2F;&#x2F;192.168.0.104:8080&#x2F;api&#x2F;v1&#x2F;user&#x2F;listUser</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">### 请求方法</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">POST</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">### 请求体类型</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">application&#x2F;x-www-form-urlencoded</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">## 入参</span><br><span class="line">### 入参示例(Postman&#x3D;&#x3D;&gt; Bulk Edit)</span><br><span class="line">&#39;&#39;&#39;json</span><br><span class="line">pageNumber:1</span><br><span class="line">pageSize:20</span><br><span class="line">searchKeyword:模糊搜索词&lt;br&gt;支持用户昵称, 用户姓名, 用户手机号</span><br><span class="line">gender:2</span><br><span class="line">ageStart:0</span><br><span class="line">ageEnd:0</span><br><span class="line">loginTimeStart:过滤登录时间范围-开始</span><br><span class="line">loginTimeEnd:过滤登录时间范围-结束</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">### 入参字段说明</span><br><span class="line">| **字段** | **类型** | **必填性** | **含义** | **其他信息参考** |</span><br><span class="line">| -------- | -------- | -------- | -------- | -------- |</span><br><span class="line">| pageNumber     | **Integer**     | 否  |  分页-当前页码 |   |</span><br><span class="line">| pageSize     | **Integer**     | 否  |  分页-分页大小 |   |</span><br><span class="line">| searchKeyword     | **String**     | 否  |  模糊搜索词&lt;br&gt;支持用户昵称, 用户姓名, 用户手机号 |   |</span><br><span class="line">| gender     | **Integer**     | 否  |  用户性别&lt;br&gt;0: 保密&lt;br&gt;1: 男&lt;br&gt;2: 女 |   |</span><br><span class="line">| ageStart     | **Integer**     | 否  |  过滤年龄范围-起始 |   |</span><br><span class="line">| ageEnd     | **Integer**     | 否  |  过滤年龄范围-结束 |   |</span><br><span class="line">| loginTimeStart     | **Date**     | 否  |  过滤登录时间范围-开始 |   |</span><br><span class="line">| loginTimeEnd     | **Date**     | 否  |  过滤登录时间范围-结束 |   |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 出参</span><br><span class="line">### 出参示例</span><br><span class="line">&#39;&#39;&#39;json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 0,</span><br><span class="line">  &quot;message&quot;: &quot;错误信息&quot;,</span><br><span class="line">  &quot;success&quot;: false,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;nickName&quot;: &quot;用户昵称&quot;,</span><br><span class="line">      &quot;realName&quot;: &quot;用户姓名&quot;,</span><br><span class="line">      &quot;phoneNumber&quot;: &quot;110&quot;,</span><br><span class="line">      &quot;userGender&quot;: 2,</span><br><span class="line">      &quot;userAge&quot;: 1024,</span><br><span class="line">      &quot;userAvatar&quot;: &quot;https:&#x2F;&#x2F;mp.weixin.com&#x2F;p&#x2F;jewagheiajifejgihewjg.ifew&quot;,</span><br><span class="line">      &quot;lastLoginTime&quot;: &quot;最近一次登录时间&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;totalCount&quot;: 0</span><br><span class="line">&#125;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">### 返回字段说明</span><br><span class="line">| **字段** | **类型** | **含义** | **其他信息参考** |</span><br><span class="line">| -------- | -------- | -------- | -------- |</span><br><span class="line">| code     | **Integer**     | 否  |  状态码&lt;br&gt;0: 代表成功&lt;br&gt;-1: 代表未知异常&lt;br&gt;\&gt;0: 代表已知异常 |   |</span><br><span class="line">| message     | **String**     | 否  |  错误信息 |   |</span><br><span class="line">| success     | **Boolean**     | 否  |  是否成功&lt;br&gt;true: 代表成功, 此时 code &#x3D; 0&lt;br&gt;false: 代表失败, 此时 code !&#x3D; 0 |   |</span><br><span class="line">| data     | **List\&lt;ListUserResponse\&gt;**     | 否  |  返回数据 |   |</span><br><span class="line">|└─ nickName     | **String**     | 否  |  用户昵称 |   |</span><br><span class="line">|└─ realName     | **String**     | 否  |  用户姓名 |   |</span><br><span class="line">|└─ phoneNumber     | **String**     | 否  |  用户手机号 |   |</span><br><span class="line">|└─ userGender     | **Integer**     | 否  |  用户性别&lt;br&gt;0: 保密&lt;br&gt;1: 男&lt;br&gt;2: 女 |   |</span><br><span class="line">|└─ userAge     | **Integer**     | 否  |  用户年龄 |   |</span><br><span class="line">|└─ userAvatar     | **String**     | 否  |  用户头像地址 |   |</span><br><span class="line">|└─ lastLoginTime     | **Date**     | 否  |  最近一次登录时间 |   |</span><br><span class="line">| totalCount     | **Long**     | 否  |  分页-总条数 |   |</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于文章本身就是Markdown格式，所以上面中 <code>```</code> 我用 <code>&#39;&#39;&#39;</code> 代替，我用截图来展示下效果：截图使用 Chrome 插件打开 HTML 滚动截屏得到，HTML 是由 typora 生成的！</p>
</blockquote>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210710101322.png" alt="screencapture-file-Users-wq-File-TempFile-html-2021-07-10-10_09_50"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>如果有多个方法，想一次性生成，则可在 UserController 上右键，点击生成Api文档（restful） ，如图：</p>
</blockquote>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210710101619.png" alt="image-20210710101618777"></p>
<blockquote>
<p>此时生成的文档，就是多个方法单独生成的文档的简单的拼接。</p>
</blockquote>
<h2 id="根据-Spring-MVC-Controller-的接口信息导出到-Postman"><a href="#根据-Spring-MVC-Controller-的接口信息导出到-Postman" class="headerlink" title="根据 Spring MVC Controller 的接口信息导出到 Postman"></a>根据 Spring MVC Controller 的接口信息导出到 Postman</h2><h3 id="项目视图选择类、包，点右键"><a href="#项目视图选择类、包，点右键" class="headerlink" title="项目视图选择类、包，点右键"></a>项目视图选择类、包，点右键</h3><blockquote>
<p>还是沿用上面的代码，但是考虑到单个方法单独导出到 Postman 非常费时费力，可用性不高，因此方法级别的右键导出，并没有实现！但是单个文件级别，还是OK的，只需在文件导航视图找到 UserController 类，右键，点击 导出Api到Postman即可！如图</p>
</blockquote>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210710102304.png" alt="image-20210710102303483"></p>
<blockquote>
<p>另外这个右键，其实不管是类，包，还是文件夹，乃至根目录，都可以点击导出到 Postman，只是导出的范围不同！</p>
<p>由于范围比较大，因此过滤了非 @Controller、@RestController 注解的类，可放心使用。</p>
</blockquote>
<p>点击导出后，会将 Postman 的json 生成到项目下的 api-doc/postman 文件夹，如图</p>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210710102848.png" alt="image-20210710102846460"></p>
<h3 id="打开Postman点击-File-–-gt-Import"><a href="#打开Postman点击-File-–-gt-Import" class="headerlink" title="打开Postman点击 File –&gt; Import"></a>打开Postman点击 File –&gt; Import</h3><p>此时我们打开 Postman，使用快捷键 <code>Ctrl + O</code> 或 <code>Command + O</code> , 接着拖拽文件过去，或点击 UploadFiles，弹框选择文件打开，如图</p>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210710103245.png" alt="image-20210710103242732"></p>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210710103323.png" alt="image-20210710103321866"></p>
<h3 id="最终得到一个-Collection"><a href="#最终得到一个-Collection" class="headerlink" title="最终得到一个 Collection"></a>最终得到一个 Collection</h3><p>如图：不管是请求，返回示例，文档，或者说 url 变量，body和参数处理，都帮你搞定了，你只需要修改下参数的实际值（如果使用 #example，则这步也可以省略），然后点蓝色的 Send 按钮就 ok 了（千万别忘记启动项目）！</p>
<blockquote>
<p>这里简单说下，url 的组成</p>
<p>1.http:// 这个本地开发一般不用 https 对吧，嘿嘿</p>
<p>2.ip: 这个使用代码遍历网卡，过滤掉 ipv6，127.0.0.1 后得出的局域网 ip，如果没搞虚拟机啥的，一般获取比较准确，要还是错了，点击 Collection 名称，在 Variables 下修改 NaN 的 Current Value 就好了</p>
<p>3.port: 这个默认8080，然后支持 Spring Boot 项目，即读取 application.yml/application.properties 文件获取 server.port 的值，嗯~~ 若存在 application-xxx 这种情况，还真不好取，只能读取 spring.profiles.active 但是也未必准确，毕竟有很多地方支持设置。理论性idea的东西都可以获取，但idea的插件开发文档找不到这方面的信息，大概是不会花精力搞了，毕竟错了直接改变量就好了，改一处，所有请求生效。</p>
<p>4.剩下的部分就是 Controller 的 @RequestMapping 注解 + 方法的 @RequestMapping（或@GetMapping之类）注解的值拼凑起来。若方法为 GET，则参数会以?xxx=xxx&amp;xx=xx 形式拼接上去，也可在 Params 下查看</p>
</blockquote>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210710104429.png" alt="image-20210710104427563"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>总得来说，这个插件还是太简单了，其实不用使用指南，知道在哪右键起什么作用，就OK了，因为处了右键点击，其他一概不用你管（包括复制）！可谓是偷懒极了。。。。。 </p>
</blockquote>
<p>说下这个插件的发展史。</p>
<blockquote>
<p>一开始是用于微服务的接口方法，根据参数和返回值来生成文档给其他开发看，当时还是自己写了个 Util，然后传 Class 作为参数来解析得到参数、返回值等信息，最终生成文档，当时的所有中文备注，都是通过 Swagger 的注解来实现的，没办法，运行时注释早干掉了，得不到。</p>
<p>后来觉得这东西可以抽出来，不要被项目束缚，先是想到了idea插件，但是发现 Api 及其不同，idea中也无法获取 Class，也就是当时写的代码无法复用，于是又考虑 maven 插件，发现这个是可以取到 Class，进行复用的。</p>
<p>写完后，又发现使用这个插件，必须设置参数，也就是你要生成那个类的文档，很麻烦啊这，于是想到之前看idea插件的一些api可以获取到这些信息，干脆来了个结合，idea右键获取Class 的全限定名，传给maven插件，maven插件来生成，最后idea弹框展示。其实这样也不错，但是又有个巨大的问题，就是maven插件其实依赖于 target 文件中的信息，这部分必须 compile 后才有，使得每次运行插件都要先跑compile 再生成，本来maven运行速度就慢，这样就更慢了。加上进度条后还是感觉体验极差！！！</p>
<p>最终，在某个夜黑风高的晚上，我死活睡不着觉，干脆打开电脑，点击备忘录，记下明天摸鱼时间要写个纯idea插件，然后躺下数羊！啊那是不可能的。</p>
<p>不过这插件最终确实都是在闲的没活干的摸鱼时间写的，最终把原来代码拷贝一份到idea插件项目中，一边参照一边使用idea提供的Api修改代码，最终得到了纯idea插件版本！</p>
<p>之后遇到了比较坑的点就是泛型的解析和参数的解析，目前都解决了，可以说是随便怎么写，都能识别了。比如最上面的示例代码的 <code>T data</code>，这还是小 case，如果改成 <code>List&lt;T&gt;</code> 呢? 如果再来一个带泛型的类 <code>PageInfo&lt;T&gt;</code> ,而我加个字段 <code>PageInfo&lt;T&gt; pageData;</code>来把 T 传给 PageInfo 呢，解析会有问题吗？刚开始会，后来解决了！！！只能说我自己都快绕晕了，但最终还是解决了。这其实值得复盘的，不过我这人比较懒，就不搞了。其实这种情况繁多的时候，要写代码不能只考虑部分情况，或是来一种情况加一种情况，必须找到通用的方法，当然未必什么时候都有通用的方法，不过还是要去追求的！！</p>
</blockquote>
<p>后续还会和大家分享一些我插件中的核心代码，包括idea插件提供的api，自己百度找的工具类等等。</p>
<p>另外我上面说的微服务那个接口文档，其实就是不带（restful）后缀的菜单选项，其生产的文档不含有HTTP协议相关的信息，而是纯粹的入参、出参、code含义等。另外文件视图右键有三个选项，另外另个就是批量生成 Markdown文件，毕竟一个一个复制粘贴很累的，而很多笔记软件都支持批量导入Markdown文件，这样就不就简单了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/04/01/simple-principle-spring-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/simple-principle-spring-md/" class="post-title-link" itemprop="url">简单说 Spring 原理</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-01 21:49:19 / 修改时间：23:45:54" itemprop="dateCreated datePublished" datetime="2021-04-01T21:49:19+08:00">2021-04-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/simple-principle/" itemprop="url" rel="index"><span itemprop="name">simple-principle</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/04/01/simple-principle-spring-md/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/04/01/simple-principle-spring-md/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简单说-Spring-原理"><a href="#简单说-Spring-原理" class="headerlink" title="简单说 Spring 原理"></a>简单说 Spring 原理</h2><blockquote>
<p>我先来，千万别较真，千万别较真，千万别较真！</p>
</blockquote>
<p>先看官网介绍哈</p>
<blockquote>
<p>The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform.</p>
<p>A key element of Spring is infrastructural support at the application level: Spring focuses on the “plumbing” of enterprise applications so that teams can focus on application-level business logic, without unnecessary ties to specific deployment environments.</p>
</blockquote>
<p>我来翻译一下，就是说（等等，我软件呢？谁动了啊！）</p>
<p>额，就是说：</p>
<blockquote>
<p>Spring框架为任何类型的部署平台上的基于Java的现代企业应用程序提供了全面的编程和配置模型。</p>
<p>Spring的一个关键元素是在应用程序级别的基础架构支持：Spring专注于企业应用程序的“管道”，以便团队可以专注于应用程序级别的业务逻辑，而不必与特定的部署环境建立不必要的联系。</p>
</blockquote>
<p>简单理解呢就是让你关注业务而非琐碎的、无关紧要的其他东西。好的，那么 Spring 是怎么做到的呢？其实也不难，先这样，再这样，然后再那样，最后再这样（啊，放错了）</p>
<p>其实也不难，主要是它有两大法宝，唉，知道的同学肯定要说了啊；我知道，IOC、AOP嘛！没错就是这两玩意，哪怕是还没内卷那会，我也听腻了，今天我们就来唠叨唠叨这两玩意它的一些原理或者说特点。</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>咱先说这 IOC，英文那就是 Inversion of Control，什么意思呢？控制反转，不让你控制我了，我要自己控制自己，这就是控制反转，我说那还得了，这程序它不听话了都！唉，不是这样理解的，其实啊，这代表这程序，它成熟了，它呀，可以自己干自己该干的事情了，不需要你管它了；这样子有什么好处呢？有啊，就像你家的熊孩子，还小的时候，特别黏人，不能没人带，你呢，总是需要找人帮忙看看，自己才有空闲出去玩，后来呢，它长大了，它就会自己出去玩了，熊是熊了点，但你也空闲不少啊，有时间可以看看书，喝喝茶，多好啊！咱说回来啊，这控制反转呢，就是让你少花费心思在这些地方，这样不就可以像官网说的 “可以专注于应用程序级别的业务逻辑”了吗。</p>
<p>那前面呢，其实只是IOC的一个思想，它不是一个实现，毕竟啊，你不能指望它真的能自己控制自己。所以呢，我们偷偷引入一个东西，也就是容器，由这个容器来管理它。这个啊，就像你把你家小孩送幼儿园，你交钱，剩下交给幼儿园。那么说到这里啊，大家应该也明白了，它呢，并不能自己控制自己，还是得靠容器；那么这个容器，又是何方神圣呢？</p>
<p>其实这个容器呢，也不难，名副其实，就是一个装东西的东西，有人说你套娃呢？我没有，不过这容器确实不禁止你往容器放容器，比如父子容器，就像子容器塞进了父容器里面，有时候呢，就会穿过子容器，从父容器取东西。好了咱说回来，容器就是一存东西的，这东西很常见啊，Java 集合框架啊，大学学过，还学了好几个，我现在还记得，什么 List，Map，Set 啥的。对！没错，真让你蒙对了！原理确实是这个，这个东西呢，选来选取，我们就选 Map 吧。众所周知，Map 是数组+链表为底层实现的键值对容器啊，因为有这个键值对的存在呢，我们就可以非常准确无误的存放和读取，就像银行账户吧，你往你账户存钱，再从你账户就能取到之前存的钱，非常有效的避免了“乱拿乱放”问题。好的，那我们就说完了容器的第一个特点，就是能存能取，这时候你就会说，这不废话吗？啊确实！行，我们整点正常的特点，那其实接下来要说的特点呢，都是围绕着取这个动作的。</p>
<p>其实上面的特点呢，说的不是特别清晰，这存的是什么？取的又是什么？总不可能和银行一样，都是钱吧！当然不是，这存的呢，一般是 Class。什么是 Class？ Class 就是一设计图，照着这个设计图呢，容器 Duang 的一下，就给了一个对象！你说还有这好事？写个代码还有对象领？不是的，这个对象呢，不是那个对象哈，这个呢，是 Java 实例化出来的对象，用来调用方法，获取字段的。那么也就是说，这个容器，它还是个工厂？它还能生产对象呢！没错，但严格说对象其实也不是它生产的，对象呢，其实是 JVM 生产的对不对？它呢，就负责加工，所以说，其实也就是个加工工厂。所以咱这第二个特点呢，就是工厂，能照着设计图加工一个对象出来。你肯定要说啦，这有啥用，这不产生中间商差价了，我直接找 JVM 爸爸行不行？别急，可以是可以，但咱用这个东西，就一点有它的用处，对不对？这不，第三个特点就来了！</p>
<p>那么聪明的小伙伴呢，肯定已经知道我要讲什么了？对，没错！就是依赖注入，前面说了 Class 是一个设计图，但没说清楚，这个设计图呢，它只是一个小零件的设计图，但和真正的零件设计图还是有一些不一样的，比方说啊，它会告诉你它与另一个零件的关系，有了这个关系呢，工厂的作用就有了，工厂生产到一半，发现这个零件要加工好啊，还需要另一个零件，那它又转头去生产另一个零件（是不是非常不科学，不应该先批量生产出来，之后再一起组装吗？），生产好了呢，又回过来按设计图把另一个零件加到这个零件上去。如果生产另一个零件的时候发现，也依赖另外某个零件，那也照旧，先生产依赖的。这时候你肯定会说了，套娃就算了，万一你依赖我，我依赖你，那不无限套娃了吗？这个问题呢？有办法解决，但是这文章太短了，我写不下！（请叫我费马 · 心累）</p>
<p>最后说下容器的另一个特点，其实都是层层递进的，你甚至可以认为，只有一个特点，都行，看你怎么看！</p>
<p>这个特点呢就是插件 DIY！之前咱也说了，工厂呢，不搞生产，光做加工了，那这个加工过程啊，除了依赖注入啊，一些属性配置注入这样的通过配置的方式去影响对象，能不能开放一个接口，我想怎么 DIY，自己写代码来实现呢？当时是可以的啊！这样的接口呢，Spring 早就准备好了，您呢，只需要实现这个接口，写点代码，再把它放到容器里面去，工厂呢，就会在合适的时机执行你的代码。而且他这个接口呢，一共有好几个，每个接口呢，也好好几个方法，每个方法啊，都是代表了相应的时机。这时候你就要问了，这有什么用呢？别急，咋看看 Spring 怎么用的！（再多嘴一句啊，干预加工过程算什么，干预工厂本身才牛逼呢！我说的啥，懂得都懂！）</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>Spring 的 AOP 啊，终于说到了，其实呢，就是干预加工过程的一个产物！著名历史事件狸猫换太子大家都听过吧，AOP 呢，那是一模一样。著名的曹操挟天子以令诸侯都听过吧，AOP 呢，还是一模一样！</p>
<p>这两个呢，一个是说的 AOP 的实现原理，另一个说的，就是它的特点：把真正的对象当傀儡使！</p>
<p>咱先说说实现原理啊，其实也不难（请问这是第几遍？），工厂都被咱劫持了，加工的时候，得到成品了的时候，做一个壳子：代理对象，把真正的对象装进去，这样呢，有什么方法被调用，都是先到代理对象这里，代理对象呢，操纵着真正的对象，心情好了，就执行一下真正的对象对应的方法，得到劳动果实后呢，再返回出去，谁也不知道真正的对象。就好像光听着收音机，不知道的还以为声音都是收音机生产的，其实那就是个代理，真正创造声音的人，远在天涯呢！所以说啊，AOP 的特点是不是如我所言呢！</p>
<p>OK各位，这就是这期文章的全部内容啦，非常感谢你能看到这里，如果你觉得写的还不错的话，求赞，求收藏，求硬币（这啥玩意），求转发，最重要的是点个大大的关注！你的支持就是我做文章的最大动力！OK各位，我们下期再见！（动作指导：何同学）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/02/04/principle-jvm-memo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/principle-jvm-memo/" class="post-title-link" itemprop="url">JVM 底层探秘笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-04 11:07:44" itemprop="dateCreated datePublished" datetime="2021-02-04T11:07:44+08:00">2021-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:53:51" itemprop="dateModified" datetime="2021-03-28T19:53:51+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/02/04/principle-jvm-memo/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/02/04/principle-jvm-memo/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM-底层探秘笔记"><a href="#JVM-底层探秘笔记" class="headerlink" title="JVM 底层探秘笔记"></a>JVM 底层探秘笔记</h1><h2 id="JVM-速记"><a href="#JVM-速记" class="headerlink" title="JVM 速记"></a>JVM 速记</h2><h3 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM?"></a>什么是 JVM?</h3><blockquote>
<p> JVM 就是由编译器, 类加载器, 执行引擎, 运行时数据区组成. 其中数据区包含 堆,栈,本地方法栈, 方法区和程序计数器(PC 寄存器), 其中栈是由局部变量表, 操作数栈, 动态链接, 返回地址组成的.</p>
</blockquote>
<h3 id="你是怎么对-jvm-垃圾回收进行优化的"><a href="#你是怎么对-jvm-垃圾回收进行优化的" class="headerlink" title="你是怎么对 jvm 垃圾回收进行优化的?"></a>你是怎么对 jvm 垃圾回收进行优化的?</h3><blockquote>
<p>根据服务器的配置, 调整青年代和老年代的内存大小及比例, 在回收频率和回收速度上做取舍, 使用 G1 垃圾回收期控制 STW 停顿时间, 提高吞吐量.</p>
</blockquote>
<h3 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h3><blockquote>
<p>每个线程有自己的内存区域, 多线程之间通信主要通过共享内存来实现.</p>
</blockquote>
<ul>
<li>有序性: 在 CPU 执行指令时, 可能会对非 happens-before 指令进行重排, 优化执行效率. 在单线程情况, 往往不会产生问题, 但涉及多线程时, 可能导致 bug.</li>
<li>可见性: 一个线程修改了一个共享变量, 另一个线程不会知道这个改变, 这就是不可见, 要确保可见性, 一般使用 volatile 关键词, 当然, 加锁也可以.</li>
<li>原子性: 即对于某代码, 实际执行时会分为好几个原子指令, 确保原子性必须加锁 (如synchronized) 处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">happens-before:</span><br><span class="line">读后写</span><br><span class="line">写后写</span><br><span class="line">锁后解锁</span><br><span class="line">可传递性</span><br></pre></td></tr></table></figure>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote>
<p>线程是一个进程中的不同执行路径, 一个进程至少有一个主线程.</p>
<p>进程是一个程序的抽象, 一个程序运行后一般为一个进程.</p>
</blockquote>
<p>线程状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.New (新建)</span><br><span class="line">2.Runnable (就绪)</span><br><span class="line">3.Running (运行中)</span><br><span class="line">4.Blocked (阻塞)</span><br><span class="line">5.WAITING (等待)</span><br><span class="line">6.TIMED_WAITING (超时等待)</span><br><span class="line">7.Dead (死亡)</span><br><span class="line"></span><br><span class="line">[t:thread对象, obj: 同步块中的对象]</span><br><span class="line">New: new Thread()</span><br><span class="line">Runnable: t.start(), t.yield()</span><br><span class="line">Running: after t.start() and cpu run it</span><br><span class="line">Blocked: when enter synchronized block</span><br><span class="line">WAITING: obj.wait(), t.join(), LockSupport.park()</span><br><span class="line">TIMED_WAITING: Thread.sleep(x), obj.wait(x), t.join(x)</span><br><span class="line">Dead: when t.run() is over</span><br></pre></td></tr></table></figure>



<h3 id="JVM-对象结构"><a href="#JVM-对象结构" class="headerlink" title="JVM 对象结构"></a>JVM 对象结构</h3><ul>
<li><strong>对象头</strong>: 存储对象运行时数据和类型指针<ul>
<li><strong>Mark Word</strong>: 运行时数据<ul>
<li>标志位为01-未锁定: 对象 hash 码, 对象分代年龄</li>
<li>标志位为00-轻量级锁定: 指向锁记录的指针</li>
<li>标志位为10-重量级锁定: 执行重量级锁的指针</li>
<li>标志位为11-GC标记: 空, 不需要记录信息</li>
<li>标志位为01-可偏向: 偏向线程ID、偏向时间戳、对象分代年龄</li>
</ul>
</li>
<li><strong>类型指针</strong>： 指向对象的类的元数据的指针</li>
<li><strong>[数组长度]</strong>： 若对象时数组，则会保存数组长度</li>
</ul>
</li>
<li><strong>实例数据</strong>： 保存字段内容，包括父级</li>
<li><strong>对齐</strong>： 确保 8 字节，凑整</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h4><ol>
<li><strong>引用计数法</strong>: 通过计算对象的引用数来判断对象是否可回收. 缺点是无法处理循环引用的问题.</li>
<li><strong>可达性分析算法</strong>: 从根对象(两个栈引用的对象、静态属性引用的对象、常量引用的对象)出发, 寻找所有引用的对象, 形成根对象的引用链, 判断对象是否与根对象的引用链相关联来决定对象是否可回收.</li>
</ol>
<h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><ol>
<li><strong>标记-清除算法</strong>：标记后直接清除, 效率低, 产生内存碎片</li>
<li><strong>标记-复制算法</strong>：需要两个大小相同的内存区域, 其中一块保持空闲, 先标记可用对象, 然后将可用对象复制到空闲区域, 再清空整块内存, 使其满足一块保持空闲, 如此循环即可.</li>
<li><strong>标记-整理算法</strong>：标记后移动内存, 令内存使用的区域与未使用的区域均无碎片, 缺点是效率低, 有的是空间占用少.</li>
<li><strong>分代算法</strong>：将堆分为新生代与老年代，根据自个区域的特定采用不同的回收算法. 新生代又分为 Eden 区(复制算法)、 Survivor 区(因使用复制算法, 分为 From、To 两块内存区域).</li>
</ol>
<h4 id="回收器"><a href="#回收器" class="headerlink" title="回收器"></a>回收器</h4><blockquote>
<p>(前 3 个 Young GC 使用, 后面的 Full GC 使用)</p>
</blockquote>
<ol>
<li><strong>Serial</strong> ：单线程，使用复制算法，整个过程一直 STW</li>
<li><strong>ParNew</strong> ：多线程，使用复制算法，还是一直 STW</li>
<li><strong>Parallel Scavenge</strong> ：多线程，使用复制算法，与 ParNew 不同之处在于其关注吞吐量，并可通过调节参数对吞吐量进行控制</li>
<li><strong>Serial Old</strong>：单线程，使用标记-整理算法，老年代使用</li>
<li><strong>Parallel Old</strong> ：多线程，使用标记-整理算法，与<strong>Parallel Scavenge</strong>一样，关注吞吐量。</li>
<li><strong>CMS</strong> ：多线程，使用标记-清除算法，其步骤为：初始标记(STW)-并发标记-重新标记(STW)-清除，具有低停顿的性质，缺点是占用CPU资源严重，且产生内存碎片，整理内存碎片依旧会STW</li>
<li><strong>G1</strong> ：多线程，与CMS类似，使用标记-整理算法，步骤为：初始标记(STW)-并发标记-最终标记(STW)-筛选清除(可控制停顿时间)，其优点是引入 Region 概念，优先清理垃圾更多的 Region</li>
</ol>
<h4 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h4><ul>
<li>对象优先在 Eden 去分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将进入老年代，可配置多少岁进入（默认15岁），熬过一次 Minor GC 涨一岁</li>
<li>动态对象年龄判定， Survivor 区空间中相同年龄所有对象大小的总和大于空间的一半，则年龄大于或等于该年龄的对象直接进入老年代；</li>
<li>空间分配担保，即防止新生代的对象大量存活时，Survivor 区装不下，则需要判定老年代是否还有足够大的连续空间（大于新生代Eden区或开启参数则取历代存活平均值），若有则可无需 FullGC，反之需要FullGC</li>
</ul>
<h2 id="JVM-详记"><a href="#JVM-详记" class="headerlink" title="JVM 详记"></a>JVM 详记</h2><h3 id="组成图"><a href="#组成图" class="headerlink" title="组成图"></a>组成图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">R(JVM)</span><br><span class="line"></span><br><span class="line">A(编译器)</span><br><span class="line">B(类加载器)</span><br><span class="line">C(执行引擎)</span><br><span class="line">D(运行时数据区)</span><br><span class="line"></span><br><span class="line">D1(堆)</span><br><span class="line">D2(栈)</span><br><span class="line">D3(本地方法栈)</span><br><span class="line">D4(方法区)</span><br><span class="line">D5(程序计数器 Program Count Register)</span><br><span class="line"></span><br><span class="line">D2A(局部变量表)</span><br><span class="line">D2B(操作数栈)</span><br><span class="line">D2C(动态链接)</span><br><span class="line">D2D(返回地址)</span><br><span class="line"></span><br><span class="line">R--&gt;A</span><br><span class="line">R--&gt;B</span><br><span class="line">R--&gt;C</span><br><span class="line">R--&gt;D</span><br><span class="line"></span><br><span class="line">D--&gt;D1</span><br><span class="line">D--&gt;D2</span><br><span class="line">D--&gt;D3</span><br><span class="line">D--&gt;D4</span><br><span class="line">D--&gt;D5</span><br><span class="line"></span><br><span class="line">D2--&gt;D2A</span><br><span class="line">D2--&gt;D2B</span><br><span class="line">D2--&gt;D2C</span><br><span class="line">D2--&gt;D2D</span><br></pre></td></tr></table></figure>

<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>JVM</strong>: </p>
<ul>
<li><strong>编译器</strong>：对 Java 代码做优化，并将代码中结构、数据、实际代码编译成字节码。</li>
<li><strong>类加载器</strong>：<ul>
<li><strong>类加载过程</strong>: 加载（把字节码二进制流加载到方法区，如文件到内存）、验证（文件格式、元数据合法性、字节码指令等的校验）、准备（静态变量分配内存、初始化零值）、解析（字符符号引用解析成直接引用）、初始化（执行生成的 cinit 方法，里面是对静态变量的赋值指令和 static 块代码）</li>
<li><strong>new 对象过程</strong>: 先进行类加载(若未加载), 接着为对象分配内存(内存大小是固定的), 接着讲内存空间的字段值初始化为零值(即内存中的值都是根据字段类型所对应的默认值), 对对象进行必要的设置(如与类信息绑定, 对象头的数据初始化等), 到此, 一个对象产生了, 然后再执行它的 init 方法(构造方法)就 ok 了.</li>
</ul>
</li>
<li><strong>执行引擎</strong>：主要负责方法的分派，执行指令控制操作数栈。</li>
<li><strong>运行时数据区</strong>：<ul>
<li><strong>堆</strong>: 最大的内存区域, <strong>线程共享</strong>, 主要用于存放对象实例数据, 由于垃圾回收的原因, 也可分为新年代与老年代, 新年代具体可分为 Eden 区, From Survivor 区, To Surviovr 区.</li>
<li><strong>本地方法栈</strong>: 与栈功能类似, 但服务于 Native 方法, 而Native 方法使用何种语言实现由具体虚拟机实现.</li>
<li><strong>方法区</strong>: 用于存储加载的类信息、常量、静态变量等，<strong>线程共享</strong>.</li>
<li><strong>程序计数器 Program Count Register</strong>: 一块较小的内存空间, <strong>线程私有</strong>. 存储线程所执行的字节码指令的行号, 分支、循环、跳转、异常处理、线程恢复等功能都需要依赖此内存. 当运行本地方法时, 值为空.</li>
<li><strong>栈</strong>: 是Java方法执行的内存模型, <strong>线程私有</strong>, 生命周期与线程相同, 每个方法执行时会创建一个栈桢, 方法的调用和结束对应着栈桢的入栈和出栈. (总结: 栈像个集合, 存储着每个方法的栈桢)<ul>
<li>(以下属于栈桢)</li>
<li>局部变量表: 一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量</li>
<li>操作数栈: 是一个后入先出的栈，数据的写入与写出都由字节码指令控制，一开始是空的；这很像CPU的操作</li>
<li>动态链接: 指向运行时常量池中该栈桢所属方法的引用，为了支持方法调用过程中的动态链接。</li>
<li>方法出口(返回地址): 提供用于回到方法被调用的位置的地址，一般为进入前PC计数器中的值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结: 编译Java源代码, 创建内存并划分区域, 加载类字节码, 从入口开始执行指令, 本质上, 所有的执行都是方法直接的组合或嵌套而成, 因此最终所有的指令, 都在方法栈执行, 也就是操作数栈. 所以需要了解常用的指令, 如内存相关, 锁相关, 方法跳转, 指令间跳转(if/for).</p>
</blockquote>
<h3 id="指令（操作数栈）"><a href="#指令（操作数栈）" class="headerlink" title="指令（操作数栈）"></a>指令（操作数栈）</h3><ul>
<li><strong>字节码与数据类型</strong><ul>
<li>i 开头代表对 int 类型的数据操作</li>
<li>l 开头代表对 long 类型的数据操作</li>
<li>s 开头代表对 short 类型的数据操作</li>
<li>b 开头代表对 byte 类型的数据操作</li>
<li>c 开头代表对 char 类型的数据操作</li>
<li>f 开头代表对 float 类型的数据操作</li>
<li>d 开头代表对 double 类型的数据操作</li>
<li>a 开头代表对 reference 类型的数据操作</li>
</ul>
</li>
<li><strong>加载和存储指令</strong><ul>
<li>讲一个局部变量加载到操作栈: iload、iload_<n>  即 <strong>load</strong></li>
<li>将一个数值从操作数栈存储到局部变量表: istore、istore_<n> 即 store</li>
<li>将一个常量加载到操作数栈: bipush、sipush、ldc</li>
<li>扩充局部变量表的访问所以的指令： wide</li>
</ul>
</li>
<li><strong>运算指令</strong><ul>
<li>加法（iadd、ladd）、减法（isub、lsub）、乘法（imul、lmul）、除法（idiv、ldiv）、求余（irem、lrem）</li>
<li>取反（ineg、lneg）、位移（ishl、ishr、iushr）、按位或（ior、lor）、按位与（iand、land）、按位异或（ixor、lxor）</li>
<li>局部变量自增指令（iinc）</li>
<li>比较指令（dcmpg、dcmpl、fcmpg、fcmpl）</li>
</ul>
</li>
<li><strong>类型转换指令</strong><ul>
<li>宽化不需要转换（隐式）</li>
<li>宅化有 i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f</li>
</ul>
</li>
<li><strong>对象创建于访问指令</strong><ul>
<li>创建实例的指令：new</li>
<li>创建数组的指令：newarray、anewarray、multianewarray</li>
<li>访问类字段（static 字段）和实例字段的指令：getfield、putfield、getstatic、putstatic</li>
<li>把一个数组元素度加载到操作数栈：baload、caload、saload；即 aload</li>
<li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、即 astore</li>
<li>取数组长度的指令:arraylength</li>
<li>检查类实例类型的指令：instanceof、checkcast</li>
</ul>
</li>
<li><strong>操作数栈管理指令</strong><ul>
<li>将操作数栈的站定一个或两个元素出栈：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1</li>
<li>将栈顶最顶端的两个值互换： swap</li>
</ul>
</li>
<li><strong>控制转移指令</strong><ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq…</li>
<li>复合条件分支：tableswitch、lookupswitch</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li>
</ul>
</li>
<li><strong>方法调用和返回指令</strong><ul>
<li>invokevirtual 调用对象的实例方法，根据对象的实际类型进行分派</li>
<li>invokeinterface 调用接口方法，搜索实现了接口方法的对象，找出适合的方法调用</li>
<li>invokespecial 调用一些需要特殊处理的方法，包括实例初始化方法、私有方法、父类方法</li>
<li>invokestatic 调用静态方法 （static 方法）</li>
<li>invokedynamic 指令用于在运行时动态解析出调用点限定符所引用的方法</li>
<li>返回指令 ireturn、lreturn、freturn、dreturn、areturn、return（ void 返回值时）</li>
</ul>
</li>
<li><strong>异常处理指令</strong> athrow；其他异常由涉及的指令抛出；另外 catch 不是由字节码指令实现，而是采用异常表</li>
<li><strong>同步指令</strong><ul>
<li>monitorenter 以栈顶元素作为锁开始同步</li>
<li>monitorexit 推出同步</li>
</ul>
</li>
</ul>
<h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><ul>
<li><strong>魔数</strong> 0xCAFEBABE  和<strong>主版本号</strong>(判断兼容性)</li>
<li><strong>常量池</strong><ul>
<li>文本字符串</li>
<li>声明为 final 的常量值</li>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li><strong>常量池类型</strong>: 字符, 字段, 方法, 类名, 普通类型常量<ul>
<li>字符串 CONSTANT_Utf8_info: tag u1, length u2, bytes, u1[]</li>
<li>Integer, Float, Double,String</li>
<li>类 CONSTANT_Class_info: tag u1, index u2 (指向字符串)</li>
<li>CONSTANT_Name-AndType_info: tag u1, index u2, index u2</li>
<li>字段 CONSTANT_Fieldref_info: tag u1, index u2(指向 CONSTANT_Class_info), index u2(指向CONSTANT_Name-AndType_info)</li>
<li>字段 CONSTANT_Methodref_info: tag u1, index u2(指向 CONSTANT_Class_info), index u2(指向CONSTANT_Name-AndType_info)</li>
</ul>
</li>
<li><strong>访问标识</strong>: 两个字节, 标识类还是接口, 是否 public, 是否 final, 是否 abstract, 是否注解, 枚举…</li>
<li><strong>类索引、父类索引、接口索引集合</strong> ：都是 CONSTANT_Class_info，其实就是全限定名</li>
<li><strong>字段表集合</strong>： 由多个字段表组成，下面为字段表的构成<ul>
<li>access_flags 字段修饰符： 描述字段是否 public ，是否 private，是否 protected 等等</li>
<li>name_index 字段的简单名称</li>
<li>descriptor_index 字段的数据类型, 如 B（byte）、C（char）、D（double）、F（float）、L（对象类型）、[L（对象数组类型）</li>
<li>attribute_info 字段的额外信息, 如字段为常量时会含有额外信息</li>
</ul>
</li>
<li><strong>方法表集合</strong>：有多个方法表组成， 下面为方法表的构成<ul>
<li>access_flags 方法修饰符：修饰方法是否为 public、是否为 private、是否为 static、是否 synchronized 等等</li>
<li>name_index 方法的简单名称</li>
<li>descriptor_index 方法的参数类型和返回值类型, 先参数，后返回值，且参数被括号包围，如 ()V、(LLDF)L</li>
<li>attribute_info 方法的额外信息, 里面有名为 Code 的属性, 存放方法代码编译成的字节码指令</li>
</ul>
</li>
<li><strong>属性表集合</strong>：类、字段和方法的额外信息存放处，类型有<ul>
<li>方法表的 Code：</li>
<li>字段表的 ConstantValue</li>
<li>方法表的异常信息 Exceptions</li>
<li>类中的内部类 InnerClasses</li>
<li>源码行号与字节码行号的对应关系 LineNumberTable</li>
<li>栈桢中局部变量表中变量与Java源码定义变量直接的关系 LocalVariableTable</li>
<li>泛型的签名信息 Signature</li>
</ul>
</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul>
<li><strong>加载</strong><ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的惊天存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象,作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
<li><strong>验证</strong><ul>
<li>文件格式验证（如魔数，版本号、常量的类型等等）会简单校验字节流，将字节流转为内存里的数据结构</li>
<li>元数据验证（这个类是否有父类、继承的类是否合法、非抽象类是否实现了所有抽象方法等等）</li>
<li>字节码验证（校验方法代码中的字节码指令语义是否正确、保证方法的类型转换时有效的）</li>
<li>符号引用验证（校验常量区的符号引用是否正确，确保解析阶段能正常执行）</li>
</ul>
</li>
<li><strong>准备</strong><ul>
<li>为静态变量分配内存，并初始化为零值</li>
</ul>
</li>
<li><strong>解析</strong><ul>
<li>类或接口的解析：解析的符号引用的类不是数组则需要先加载这个类，再校验访问权限</li>
<li>字段解析：先从自身找，自身无且实现了接口，则找继承的接口中的引用，自身无也无实现接口，则找父类，都找不到则报错，找到则校验权限。</li>
<li>方法解析：与字段类似，从自身到实现的接口、继承的父类中找，找到后校验权限。</li>
<li>接口方法解析：从自身接口中或父接口中找、找到无需校验权限（都是 public）</li>
</ul>
</li>
<li><strong>初始化</strong><ul>
<li>执行 cinit 方法，方法中执行对静态变量的赋值指令和 static 快</li>
<li>父类的初始化方法一定先于子类执行</li>
<li>执行时会加锁同步执行、因此不要进行耗时操作</li>
</ul>
</li>
</ul>
<blockquote>
<p>顺带一提类加载器，作用是加载字节码二进制流到虚拟机中，除了系统顶级的类加载器（用于加载 rt.jar）是由 C++ 实现外，其他的类加载器都是 Java代码，通过组合一个类加载器（即父类加载器），实现双亲委派模型：即总是先通过父类加载类，除非父类加载失败；若自己实现一个类加载器，一般需要组合 ClassLoader.getSystemClassLoader()</p>
<p>系统的类加载器有:</p>
<ul>
<li>启动类加载器 Bootstrap ClassLoader 加载 JAVA_HOME/lib 下的类，如 rt.jar</li>
<li>扩展类加载器 Extension ClassLoader 加载 JAVA_HOME/lib/ext 下的类</li>
<li>应用程序类加载器 Application ClassLoader 加载 classpath 下的类</li>
</ul>
</blockquote>
<h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p>主要是为了屏蔽调各种硬件和操作系统的内存访问差异，以实现 Java 程序在各种平台下都能达到一致的内存访问效果。可有效防止不同平台的并发访问因平台差异有所不同引发线程安全问题。</p>
<ul>
<li><strong>主内存与工作内存</strong>：这里变量不包括线程私有的内存区域<ul>
<li>所有变量都存储主内存中</li>
<li>每条线程有自己的工作内存</li>
<li>线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝</li>
<li>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存的变量。</li>
<li>不同线程之间无法直接访问对方工作内存中的变量</li>
<li>线程间变量值的传递均需要通过主内存来完成</li>
<li>主内存类似于物理硬件中的内存，而工作内存优先存储于寄存器和高速缓存中（看 JVM 具体实现）</li>
</ul>
</li>
<li><strong>内存间交互操作</strong><ul>
<li>lock：作用于主内存的变量，它把一个变量表示为一条线程独占的状态。</li>
<li>unlock：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用</li>
<li>load：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令都会执行这个操作。</li>
<li>assign：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个需要给变量赋值的字节码指令时执行这个操作。</li>
<li>store：存储作用于工作内存的变量，它把工作内存中一个变量的值传递给主内存中，以便随后的 write 操作使用</li>
<li>write：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存中的变量中。</li>
</ul>
</li>
<li><strong>对于 volatile 型变量的特殊规则</strong><ul>
<li>保证此变量对所有线程的可见性，但不保证原子性，因此部分操作仍是线程不安全的， 如 i++</li>
<li>禁用指令重排序优化， 即保证变量的赋值操作的顺序与代码中的顺序一致；其他变量可能会因指令重排序优化而不一致。</li>
</ul>
</li>
<li><strong>对于 long 和 double 型变量的特殊规则</strong><ul>
<li>对于这两类型变量， JVM 规范不严格要求对 8个操作（read、load等）都具有原子性</li>
<li>但大多数虚拟机实现仍保证了这一点，所有不需要把这类型的变量特别的添加 volatile 修饰</li>
</ul>
</li>
<li><strong>原子性、可见性、有序性</strong><ul>
<li><strong>原子性</strong>：有 Java 内存模型来直接保证原子性变量操作包括（read、load、assign、use、store、write），基本可以认为基本数据类型的访问读写是具有原子性的，可使用 synchronized 实现原子性</li>
<li><strong>可见性</strong>：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile、synchronized、final 可实现可见性</li>
<li><strong>有序性</strong>：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。可使用 volatile、synchronized 实现有序性</li>
</ul>
</li>
<li><strong>先行发生原则</strong><ul>
<li>程序次序规则：在一个线程中，按照程序代码顺序，书写在前的操作先行发生于书写在后的操作。</li>
<li>管程锁定规则：一个 unlock 操作先行发生与后面对同一个锁的 lock 操作。</li>
<li>volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</li>
<li>线程启动规则：Thread 对象的 start 方法先行发生于此线程的每一个动作</li>
<li>线程终止规则：线程中所有操作都先行发生于对此线程的终止检测。</li>
<li>线程中断规则：对线程 interrupt 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的 finalize 方法的开始</li>
<li>传递性：如果操作 A 先行发生于操作 B， 操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</li>
</ul>
</li>
</ul>
<h3 id="Java-线程安全"><a href="#Java-线程安全" class="headerlink" title="Java 线程安全"></a>Java 线程安全</h3><blockquote>
<p>定义: 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外同步（就是调用者不需要额外同步，代码本身可使用同步），或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象时线程安全的。 </p>
<p>作者说：把“调用这个对象的行为” 限定为 “单词调用” ，也可称为线程安全。这是个弱化。</p>
</blockquote>
<ul>
<li><strong>Java 语言中的线程安全</strong><ul>
<li><strong>不可变</strong>：不可变的对象一定是线程安全的；如 String</li>
<li><strong>绝对线程安全</strong>：与定义等同，过于严格</li>
<li><strong>相对线程安全</strong>：仅保证对这个对象单独的操作是线程安全的，如 Vector。</li>
<li><strong>线程兼容</strong>：对象本身不安全，但通过操作前后加同步手段来保证操作线程安全。则称为线程兼容，如 ArrayList。</li>
<li><strong>线程对立</strong>：即使使用同步手段，还是无法做到线程安全的代码。比如 System.setIn()</li>
</ul>
</li>
<li><strong>线程安全的实现方法</strong><ul>
<li><strong>互斥同步</strong>：即只被一个线程使用，如 synchronized </li>
<li><strong>非阻塞同步</strong>：一般指乐观锁，即先进行操作，若无其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就采用其他的补偿措施（通常是重试）；依赖 CAS 原子操作，即系统底层支持</li>
<li><strong>无同步方案</strong>：一般指 ThreadLocal，将变量控制在线程中，不与其他线程共享，则也是线程安全的。</li>
</ul>
</li>
<li><strong>锁优化</strong><ul>
<li><strong>自旋锁与自适应锁</strong>：自旋指线程在等待锁时不让出CPU资源，而是循环的重试来获取锁；自然，可以配置重试次数，可以配置是否开启。自适应指的是自旋的时间或者说次数，根据虚拟机统计的自旋获得锁的成功与否，来增长或缩短自旋的时间。</li>
<li><strong>锁消除</strong>：即 JVM 判断某些代码的变量无需使用同步，因为这些变量不会被其他线程锁读写，如方法里是局部变量的 StringBuffer 对象的 append 方法。其使用 synchronized，但局部变量都是线程私有的，并不会被其他线程读写。</li>
<li><strong>锁粗化</strong>：避免锁粒度太小导致频繁的互斥，带来额外的开销，虚拟机会对这种情况将锁的范围粗化。</li>
<li><strong>轻量级锁</strong>：即当一个锁没有两条以上的线程争用的时候，通过 CAS 操作加锁和解锁，比重量级锁开销更少。若超过两个线程争用，则通过修改对象头标志位将锁升级为重量级锁，因为此时再使用 CAS 反而是一种消耗（这是因为 CAS 总是会失败）</li>
<li><strong>偏向锁</strong>：即一个线程第一次通过 CAS 获得这个锁后，之后再获取将不再需要加锁（即使释放了锁也没关系），这是因为在第一次获取时会将对象头的标志改为偏向锁，并记录线程 ID（这个动作也是通过 CAS 进行的），这样以后只需要对比线程 ID，刷脸入场。</li>
</ul>
</li>
</ul>
<h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><ol>
<li>编译器编译 .java 后缀文件得到字节码文件 .class；</li>
<li>类加载器加载字节码文件到运行时区域；</li>
<li>执行器为类的方法创建栈桢，并结合操作数栈执行字节码指令，遇到方法调用的指令，则可能需要根据对象类型判断执行哪个具体的方法，然后执行对应的字节码指令。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/02/03/principle-redis-memo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/03/principle-redis-memo/" class="post-title-link" itemprop="url">Redis 底层探秘</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-03 19:06:58" itemprop="dateCreated datePublished" datetime="2021-02-03T19:06:58+08:00">2021-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:53:21" itemprop="dateModified" datetime="2021-03-28T19:53:21+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/02/03/principle-redis-memo/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/02/03/principle-redis-memo/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis-底层探秘"><a href="#Redis-底层探秘" class="headerlink" title="Redis 底层探秘"></a>Redis 底层探秘</h1><h2 id="Redis-数据结构实现原理"><a href="#Redis-数据结构实现原理" class="headerlink" title="Redis 数据结构实现原理"></a>Redis 数据结构实现原理</h2><blockquote>
<p>copy from <a href="https://juejin.cn/post/6844903856313368589#heading-3" target="_blank" rel="noopener">https://juejin.cn/post/6844903856313368589#heading-3</a></p>
</blockquote>
<h3 id="1-string"><a href="#1-string" class="headerlink" title="1.string"></a>1.string</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sdshdr64 变成 sdshdr32, 则相应的 len 和 alloc 变成 uint32_t</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; </span><br><span class="line">    <span class="keyword">uint64_t</span> alloc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  len：已使用的长度，即字符串的真实长度</span></span><br><span class="line"><span class="comment">  alloc：除去标头和终止符('\0')后的长度</span></span><br><span class="line"><span class="comment">  flags：低3位表示字符串类型，其余5位未使用（我暂时没发现redis在哪里使用过这个属性）</span></span><br><span class="line"><span class="comment">  buf[]：存储字符数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis 写的字符串库有以下4个优点：</p>
</blockquote>
<ul>
<li>降低获取字符串长度的时间复杂度到O(1)</li>
<li>减少了修改字符串时的内存重分配次数</li>
<li>兼容c字符串的同时，提高了一些字符串工具方法的效率</li>
<li>二进制安全（数据写入的格式和读取的格式一致）</li>
</ul>
<blockquote>
<p>总结: string 就是字符串, 但 Redis 其实有实现自己的类库提高各方面的速度, 只能说, 专业!!!</p>
</blockquote>
<h3 id="2-list"><a href="#2-list" class="headerlink" title="2.list"></a>2.list</h3><h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h4><p>ziplist并不是一个类名，其结构是下面这样的： <code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;entries&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</code></p>
<p>其中各部分代表的含义如下：</p>
<ul>
<li>zlbytes：4个字节（32bits），表示ziplist占用的总字节数</li>
<li>zltail：4个字节（32bits），表示ziplist中最后一个节点在ziplist中的偏移字节数</li>
<li>entries：2个字节（16bits），表示ziplist中的元素数</li>
<li>entry：长度不定，表示ziplist中的数据</li>
<li>zlend：1个字节（8bits），表示结束标记，这个值固定为ff（255）</li>
</ul>
<p>这些数据均为小端存储，所以可能有些人查看数据的二进制流与其含义对应不上，其实是因为读数据的方式错了</p>
<p>ziplist内部采取数据压缩的方式进行存储，压缩方式就不是重点了，我们仅从宏观来看，ziplist类似一个封装的数组，通过zltail可以方便地进行追加和删除尾部数据、使用entries可以方便地计算长度</p>
<h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* ziplist所有节点的个数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* quicklistNode节点的个数 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">fill</span> : <span class="number">16</span>;              <span class="comment">/* 单个节点的填充因子 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* 压缩端结点的深度 */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<p>我们可以明显地看出，quicklist是一个双向链表的结构，但是内部又涉及了ziplist，我们可以这么说，在宏观上，quicklist是一个双向链表，在微观上，每一个quicklist的节点都是一个ziplist</p>
<p>在redis.conf中，可以使用下面两个参数来进行优化：</p>
<ul>
<li>list-max-ziplist-size：表示每个quicklistNode的字节大小。默认为2，表示8KB</li>
<li>list-compress-depth：表示quicklistNode节点是否要压缩。默认为0，表示不压缩</li>
</ul>
<p>这种存储方式的优点和链表的优点一致，就是插入和删除的效率很高，而链表查询的效率又由ziplist来进行弥补，所以quicklist就成为了list数据结构的首选</p>
<blockquote>
<p>总结: 是一个双向链表 + ziplist, 同时具有两者的优点(指插入速度和查询速度, 具体咋回事, 怎么做到的.. 完全不知道啊).</p>
</blockquote>
<h3 id="3-hash"><a href="#3-hash" class="headerlink" title="3.hash"></a>3.hash</h3><h4 id="ziphash"><a href="#ziphash" class="headerlink" title="ziphash"></a>ziphash</h4><p>zipmap其格式形如下面这样： <code>&lt;zmlen&gt;&lt;len&gt;&quot;foo&quot;&lt;len&gt;&lt;free&gt;&quot;bar&quot;&lt;len&gt;&quot;hello&quot;&lt;len&gt;&lt;free&gt;&quot;world&quot;</code></p>
<p>各部分的含义如下：</p>
<ul>
<li>zmlen：1个字节，表示zipmap的总字节数</li>
<li>len：1~5个字节，表示接下来存储的字符串长度</li>
<li>free：1个字节，是一个无符号的8位数，表示字符串后面的空闲未使用字节数，由于修改与键对应的值而产生</li>
</ul>
<p>这其中相邻的两个字符串就分别是键和值，比如在上面的例子中，就表示<code>&quot;foo&quot; =&gt; &quot;bar&quot;, &quot;hello&quot; =&gt; &quot;world&quot;</code>这样的对应关系</p>
<p>这种方式的缺点也很明显，就是查找的时间复杂度为O(n)，所以只能当作一个轻量级的hashmap来使用</p>
<h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;	<span class="comment">/* 指向自定义类型的指针，可以存储各类型数据 */</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">/* 私有数据的指针 */</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];	<span class="comment">/* 两个hash表，一般只有h[0]有效，h1[1]只在rehash的时候才有值 */</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* -1：没有在rehash的过程中，大于等于0：表示执行rehash到第几步 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; 	<span class="comment">/* 正在遍历的迭代器个数 */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>很明显是一个链表，我们知道这是采用链式结构存储就足够了</p>
<p>这种方式会消耗较多的内存，所以一般数据较少时会采用轻量级的zipmap</p>
<blockquote>
<p>总结: 是个链表, 缺点是消耗内存高, 因此数据较少会采用 zipmap 这种…. 按字节精打细算的方式存储.</p>
</blockquote>
<h3 id="4-set"><a href="#4-set" class="headerlink" title="4.set"></a>4.set</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>其中各字段含义如下：</p>
<ul>
<li>encoding：数据编码格式，表示每个数据元素用几个字节存储（可取的值有2、4，和8）</li>
<li>length：元素个数</li>
<li>contents：柔性数组，这部分内存单独分配，不包含在intset中</li>
</ul>
<p>intset有一个数据升级的概念，比方说我们有一个16位整数的set，这时候插入了一个32位整数，所以就导致整个集合都升级为32位整数，但是反过来却不行，这也就是柔性数组的由来</p>
<p>如果集合过大，会采用dict的方式来进行存储</p>
<blockquote>
<p>总结: 底层是个数组的 inset 结构体, 另外集合过大会采用 dict 来存储.</p>
</blockquote>
<h3 id="5-zset"><a href="#5-zset" class="headerlink" title="5.zset"></a>5.zset</h3><p>zset，有很多地方也叫做sorted set，是一个键值对的结构，其键被称为member，也就是集合元素（zset依然是set，所以member不能相同），其对应的值被称为score，是一个浮点数，可以理解为优先级，用于排列zset的顺序</p>
<p>其也有两种存储方式，一种是ziplist/zipmap的格式，这种方式我们就不过多介绍了，只需要了解这种格式将数据按照score的顺序排列即可</p>
<p>另一种存储格式是采用了skiplist，意为跳跃表，可以看成平衡树映射的数组，其查找的时间复杂度和平衡树基本没有差别，但是实现更为简单，形如下面这样的结构（图来源<a href="https://www.cnblogs.com/thrillerz/p/4505550.html" target="_blank" rel="noopener">跳跃表的原理）</a>：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b042094c9cec82?imageView2/0/w/1280/h/960/ignore-error/1" alt="例图"></p>
<blockquote>
<p>总结: 看不懂….</p>
<p>再看看这个吧… 更细致一点! <a href="https://juejin.cn/post/6844904192042074126" target="_blank" rel="noopener">https://juejin.cn/post/6844904192042074126</a></p>
</blockquote>
<h2 id="Redis-的持久化"><a href="#Redis-的持久化" class="headerlink" title="Redis 的持久化"></a>Redis 的持久化</h2><blockquote>
<p> 摘记一下: copy from <a href="https://mp.weixin.qq.com/s/zfkhQFEBkKSRsfKF63R94A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zfkhQFEBkKSRsfKF63R94A</a></p>
</blockquote>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>写RDB文件是Redis的一种持久化方式。在指定的时间间隔内将内存中的数据写入到磁盘，RDB文件是一个紧凑的二进制文件，每一个文件都代表了<strong>某一个时刻</strong>（执行fork的时刻）Redis完整的数据快照，恢复数据时，将快照文件读入内存即可。</p>
<p><strong>触发保存RDB文件4种情况</strong></p>
<ol>
<li>手动执行save命令、bgsave</li>
<li>满足配置文件中配置的save相关配置项时，自动触发</li>
<li>手动执行flushall</li>
<li>关闭redis , 执行 shutdown 命令</li>
</ol>
<p><strong>如何让redis加载rdb文件？</strong></p>
<p>只需要将rdb文件放在redis的启动目录下，redis其中时会自动加载它。</p>
<p><strong>RDB模式的优缺点：</strong></p>
<p>优点：RDB过程中，由子进程代替主进程进行备份的IO操作。保证了主进程仍然提供高性能的服务。适合大规模的数据备份恢复过程。</p>
<p>缺点：</p>
<ol>
<li>默认情况下，它是每隔一段时间进行一次数据备份，所以一旦出现最后一次持久化的数据丢失，将丢失大规模的数据。</li>
<li>fork()子进程时会占用一定的内存空间，如果在fork()子进程的过程中，父进程夯住了，那也就是redis卡住了，不能对外提供服务。所以不要让生成RDB文件的时间间隔太长，不然每次生成的RDB文件过大对Redis本身也是有影响的。</li>
</ol>
<img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210203195703.png" alt="image-20210203195701943" style="zoom:50%;" />

<blockquote>
<p>总结: 每隔一段时间(一般比较久)触发的全量备份, 备份速度取决于使用情况, 备份时 Redis 仍然可读可写, 但写还是有些问题. 缺点是宕机容易丢失较久的数据.</p>
</blockquote>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>Append Only File，他也是Redis的持久化策略。即将所有的写命令都以日志的方式追加记录下来（只追加，不修改），恢复的时候将这个文件中的命令读出来回放。</p>
<p><strong>aof模式的优缺点</strong><br><strong>优点</strong>：</p>
<ol>
<li>aof是用追加的形式写，没有随机磁盘IO那样的寻址开销，性能还是比较高的。</li>
<li>aof可以更好的保护数据不丢失或者尽可能的少丢失：设置让redis每秒同步一次数据，即使redis宕机了，最多也就丢失1秒的数据。</li>
<li>即使aof真的体积很大，也可以设置后台重写，不影响客户端的重写。</li>
<li>aof适合做灾难性的误删除紧急恢复：比如不小心执行了flushall，然后可以在发生rewrite之前 快速备份下aof文件，去掉末尾的 flushall，通过恢复机制恢复数据。</li>
</ol>
<p><strong>缺点</strong>：使用aof一直追加写，导致aof的体积远大于RDB文件的体积，恢复数据、修复的速度要比rdb慢很多。</p>
<p>aof的重写</p>
<blockquote>
<p>AOF采取的是文件追加的方式,文件的体积越来越大,为了优化这种现象,增加了重写机制,当aof文件的体积到达我们在上面的配置文件上的阕值时,就会触发重写策略,只保留和数据恢复相关的命令。</p>
</blockquote>
<p>手动触发重写</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis会fork出一条新的进程</span></span><br><span class="line"><span class="comment"># 同样是先复制到一份新的临时文件,最后再rename,遍历每一条语句,记录下有set的语句</span></span><br><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure>

<h3 id="RDB和AOF的选择"><a href="#RDB和AOF的选择" class="headerlink" title="RDB和AOF的选择"></a>RDB和AOF的选择</h3><ul>
<li>如果我们的redis只是简单的作为缓存，那两者都不要也没事。</li>
<li>如果数据需要持久化，那不要仅仅使用RDB，因为一旦发生故障，你会丢失很多数据。</li>
<li>同时开启两者: 在这种情况下,redis优先加载的是aof,因为它的数据很可能比rdb更全,但是并不建议只是用aof,因为aof不是那么的安全,很可能存在潜在的bug。</li>
</ul>
<p><strong>推荐：</strong></p>
<ul>
<li>建议在从机slave上只备份rdb文件，而且只要15分钟备份一次就够了。</li>
<li>如果启动了aof,我们尽量减少rewrite的频率,基础大小设置为5G完全可以,起步也要3G。</li>
<li>如果我们不选择aof, 而是选择了主从复制的架构实现高可用同样可以,能省掉一大笔IO操作,但是意外发生的话,会丢失十几分钟的数据。</li>
</ul>
<img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210203195723.png" alt="image-20210203195722608" style="zoom:50%;" />



<blockquote>
<p>总结: AOF 记录的是对Redis数据库做更改的命令列表, 类似 MySQL 的 binlog.</p>
</blockquote>
<h2 id="一致性-Hash-算法"><a href="#一致性-Hash-算法" class="headerlink" title="一致性 Hash 算法"></a>一致性 Hash 算法</h2><blockquote>
<p>copy from <a href="https://juejin.cn/post/6844903670430040078#heading-1" target="_blank" rel="noopener">https://juejin.cn/post/6844903670430040078#heading-1</a></p>
</blockquote>
<blockquote>
<p>总计: 一个选取集群内服务器的算法, 使其在大量的请求下可做到流量均匀的落到每台服务器上.</p>
<p>首先引入一个概念, 就是 hash 环, 其是 hash 的取值范围大小, 展开就是 范围下限-范围上限, 围起来则是一个环.</p>
<p>实现原理是, 对每个服务器取 hash, 记录下 hash 位置, 再对每个请求的特定信息(如ip, Redis Key)也取 hash, 在根据这两个 hash 大小关系, 顺时针(找比其更大的)寻找离得最近的服务器;</p>
<p>因为大量的请求会均匀的散落在 hash 环上, 这个是 hash 算法决定的性质, 同理大量的服务器节点也会均衡的散落在 hash 值范围内, 因此总体来看, 请求总是均匀的打落到每台服务器.</p>
<p>但这也引出一个问题, 就是 hash 值范围过大, 而服务器数量过少, 无法保证服务器均衡的散落在整个 hash 上, 因此引入虚拟节点, 使得每个虚拟节点的 hash 与原节点不一致, 然后每个节点创建大量的(比如1000)虚拟节点, 计算的 hash 则会均匀的散落在 hash 环上了.</p>
</blockquote>
<blockquote>
<p>再总结: 充分利用 hash 算法的特性, 以及加入取 hash 找距离近的服务器这个理念, 使得即使对服务器进行伸缩, 也可以降低被影响的key.</p>
</blockquote>
<h3 id="对比-HashSlot"><a href="#对比-HashSlot" class="headerlink" title="对比 HashSlot"></a>对比 HashSlot</h3><p>了解了一致性Hash算法的特点后，我们也不难发现一些不尽人意的地方：</p>
<ul>
<li>整个分布式缓存需要一个路由服务来做负载均衡，存在单点问题（如果路由服务挂了，整个缓存也就凉了）</li>
<li>Hash环上的节点非常多或者更新频繁时，查找性能会比较低下</li>
</ul>
<p>针对这些问题，Redis在实现自己的分布式集群方案时，设计了全新的思路：基于P2P结构的HashSlot算法，下面简单介绍一下：</p>
<ol>
<li><p>使用HashSlot</p>
<p>类似于Hash环，Redis Cluster采用HashSlot来实现Key值的均匀分布和实例的增删管理。</p>
<p>首先默认分配了16384个Slot（这个大小正好可以使用2kb的空间保存），每个Slot相当于一致性Hash环上的一个节点。接入集群的所有实例将均匀地占有这些Slot，而最终当我们Set一个Key时，使用<code>CRC16(Key) % 16384</code>来计算出这个Key属于哪个Slot，并最终映射到对应的实例上去。</p>
<p>那么当增删实例时，Slot和实例间的对应要如何进行对应的改动呢？</p>
<p>举个例子，原本有3个节点A,B,C，那么一开始创建集群时Slot的覆盖情况是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">节点A	0－5460</span><br><span class="line">节点B	5461－10922</span><br><span class="line">节点C	10923－16383</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在假设要增加一个节点D，RedisCluster的做法是将之前每台机器上的一部分Slot移动到D上（注意这个过程也意味着要对节点D写入的KV储存），成功接入后Slot的覆盖情况将变为如下情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">节点A	1365-5460</span><br><span class="line">节点B	6827-10922</span><br><span class="line">节点C	12288-16383</span><br><span class="line">节点D	0-1364,5461-6826,10923-12287</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>同理删除一个节点，就是将其原来占有的Slot以及对应的KV储存均匀地归还给其他节点。</p>
</li>
<li><p>P2P节点寻找</p>
<p>现在我们考虑如何实现去中心化的访问，也就是说无论访问集群中的哪个节点，你都能够拿到想要的数据。其实这有点类似于路由器的路由表，具体说来就是：</p>
<ul>
<li>每个节点都保存有完整的<code>HashSlot - 节点</code>映射表，也就是说，每个节点都知道自己拥有哪些Slot，以及某个确定的Slot究竟对应着哪个节点。</li>
<li>无论向哪个节点发出寻找Key的请求，该节点都会通过<code>CRC(Key) % 16384</code>计算该Key究竟存在于哪个Slot，并将请求转发至该Slot所在的节点。</li>
</ul>
<p>总结一下就是两个要点：<strong>映射表</strong>和<strong>内部转发</strong>，这是通过著名的<strong><a href="https://blog.csdn.net/chen77716/article/details/6275762" target="_blank" rel="noopener">Gossip协议</a></strong>来实现的。</p>
</li>
</ol>
<blockquote>
<p>总结: 映射表记录了我这个 key 计算 hash 位于的槽属于哪个节点, 若是节点自身, 则处理请求, 若不是则转发到那个节点. </p>
</blockquote>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><blockquote>
<p>摘记一下: copy from <a href="https://mp.weixin.qq.com/s/zfkhQFEBkKSRsfKF63R94A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zfkhQFEBkKSRsfKF63R94A</a></p>
</blockquote>
<ul>
<li><strong>C(Consistency 强一致性)</strong></li>
<li><strong>A(Availability可用性)</strong></li>
<li><strong>P(Partition tolerance分区容错性)</strong></li>
</ul>
<p>CAP 的理论核心是: 一个分布式的系统,不可能很好的满足一致性,可用性,分区容错性这三个需求,最多同时只能满足两个.因此CAP原理将nosql分成了三大原则:</p>
<ul>
<li>CA- 单点集群,满足强一致性和可用性,比如说oracle,扩展性收到了限制。</li>
<li>CP- 满足一致性,和分区容错性<strong>Redis和MongoDB都属于这种类型。</strong></li>
<li>AP- 选择了可用性和分区容错性,他也是大多数网站的选择,容忍数据可以暂时不一致,但是不容忍系统挂掉。</li>
</ul>
<h2 id="Redis-配置文件"><a href="#Redis-配置文件" class="headerlink" title="Redis 配置文件"></a>Redis 配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动redis的方式</span></span><br><span class="line"> 2./redis-server /path/to/redis.conf</span><br><span class="line"> 3</span><br><span class="line"> 4<span class="comment"># 可以像下面这样让在当前配置文件包含引用其他配置文件</span></span><br><span class="line"> 5include /path/to/local.conf</span><br><span class="line"> 6include /path/to/other.conf</span><br><span class="line"> 7</span><br><span class="line"> 8<span class="comment"># 指定哪些客户端可以连接使用redis</span></span><br><span class="line"> 9Examples:</span><br><span class="line">10bind 192.168.1.100 10.0.0.1  <span class="comment"># 指定ip</span></span><br><span class="line">11bind 127.0.0.1 ::1 <span class="comment"># 仅限于本机可访问</span></span><br><span class="line">12</span><br><span class="line">13<span class="comment"># 是否处于受保护的模式，默认开启</span></span><br><span class="line">14protected-mode yes</span><br><span class="line">15</span><br><span class="line">16<span class="comment"># 对外暴露的端口</span></span><br><span class="line">17port 16379</span><br><span class="line">18</span><br><span class="line">19<span class="comment"># TCP的通用配置</span></span><br><span class="line">20tcp-backlog 511</span><br><span class="line">21timeout 0</span><br><span class="line">22tcp-keepalive 300</span><br><span class="line">23</span><br><span class="line">24<span class="comment"># 是否以守护进程的方式运行，默认为no</span></span><br><span class="line">25daemonize yes</span><br><span class="line">26</span><br><span class="line">27<span class="comment"># 如果进程在后台运行，需要指定这个pid文件</span></span><br><span class="line">28pidfile /var/run/redis_6379.pid</span><br><span class="line">29</span><br><span class="line">30<span class="comment"># 日志级别</span></span><br><span class="line">31<span class="comment"># debug 测试开发节点</span></span><br><span class="line">32<span class="comment"># verbose (和dubug很像，会产生大量日志)</span></span><br><span class="line">33<span class="comment"># notice (生产环境使用)</span></span><br><span class="line">34<span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">35loglevel notice</span><br><span class="line">36</span><br><span class="line">37<span class="comment"># 日志文件名</span></span><br><span class="line">38logfile <span class="string">""</span></span><br><span class="line">39</span><br><span class="line">40<span class="comment"># 数据库的数量，默认16个</span></span><br><span class="line">41databases 16</span><br><span class="line">42</span><br><span class="line">43<span class="comment"># 是否总是显示logo</span></span><br><span class="line">44always-show-logo yes</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47<span class="comment"># 设置redis的登陆密码（默认没有密码）</span></span><br><span class="line">48<span class="comment"># 设置完密码后，使用redis-cli登陆时，使用auth password 认证登陆</span></span><br><span class="line">49requirepass foobared</span><br><span class="line">50</span><br><span class="line">51<span class="comment"># 设置能连接上redis的客户端的最大数量</span></span><br><span class="line">52maxclients 10000</span><br><span class="line">53</span><br><span class="line">54<span class="comment"># 给redis设置最大的内存容量</span></span><br><span class="line">55maxmemory &lt;bytes&gt;</span><br><span class="line">56</span><br><span class="line">57<span class="comment"># 内存达到上限后的处理策略</span></span><br><span class="line">58<span class="comment"># volatile-lru -&gt; 只针对设置了过期时间的key进行LRU移除</span></span><br><span class="line">59<span class="comment"># allkeys-lru -&gt; 删除LRU算法的Key</span></span><br><span class="line">60<span class="comment"># volatile-lfu -&gt; 使用具有过期集的密钥在近似的LFU中进行驱逐。</span></span><br><span class="line">61<span class="comment"># allkeys-lfu -&gt; 使用近似的LFU退出任何密钥。</span></span><br><span class="line">62<span class="comment"># volatile-random -&gt; 随机删除即将过期的key</span></span><br><span class="line">63<span class="comment"># allkeys-random -&gt; 随机删除</span></span><br><span class="line">64<span class="comment"># volatile-ttl -&gt; 删除即将过期的</span></span><br><span class="line">65<span class="comment"># noeviction -&gt; 永不过期，返回错误</span></span><br><span class="line">66maxmemory-policy noeviction</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210203194805.png" alt="image-20210203194803411"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/02/01/principle-mysql-memo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/01/principle-mysql-memo/" class="post-title-link" itemprop="url">MySQL 探秘笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-01 15:21:08" itemprop="dateCreated datePublished" datetime="2021-02-01T15:21:08+08:00">2021-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:53:35" itemprop="dateModified" datetime="2021-03-28T19:53:35+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/02/01/principle-mysql-memo/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/02/01/principle-mysql-memo/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL-探秘笔记"><a href="#MySQL-探秘笔记" class="headerlink" title="MySQL 探秘笔记"></a>MySQL 探秘笔记</h1><h2 id="由SQL语句的执行过程引出-MySQL-核心组件"><a href="#由SQL语句的执行过程引出-MySQL-核心组件" class="headerlink" title="由SQL语句的执行过程引出 MySQL 核心组件"></a>由SQL语句的执行过程引出 MySQL 核心组件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.客户端发送 SQL 语句给 MySQL.</span><br><span class="line">2.MySQL 的 Server 层与客户端通信, 得到 SQL 语句.</span><br><span class="line">3.Server 层先检查缓存, 后调用分析器.</span><br><span class="line">4.分析器解析 SQL 语句得到解析树, 然后调用优化器.</span><br><span class="line">5.优化器基于成本控制来寻找较优解, 如逻辑转换/选取索引/计算成本/改进计划, 最终得到查询计划; 然后调用执行器</span><br><span class="line">5.执行器根据查询计划执行存储引擎并获取返回结果再返回给客户端.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储引擎 InnoDB</span></span><br><span class="line">0.先根据语句的 <span class="built_in">where</span> 查询需要操作的列, 若单条, 单个执行, 多条(未知, 遍历执行不太可能...)</span><br><span class="line">1.由于事务是自动开启的(默认设置), 因此单条语句也会自动被事务包围.</span><br><span class="line">2.所以先写 undo <span class="built_in">log</span>(默认置于共享表空间), 写这个是用于事务回滚的.</span><br><span class="line">3.接着将修改写入到 Buffer Pool(即修改内存中的值).</span><br><span class="line">4.二阶段提交第一阶段, 写 redo <span class="built_in">log</span>, 此作用为防止写 binlog 时宕机造成数据不一致(前提是开了 binlog); 这里标记 redo <span class="built_in">log</span> 为 prepare 状态.</span><br><span class="line">5.接着写 binlog, 若有从库集群, 应该还要等待从库同步.</span><br><span class="line">6.二阶段提交第二阶段, 写完 binlog 后, 将 redo <span class="built_in">log</span> 标记成 commit, 代表这次提交和 binlog 保持了一致.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># PS 二阶段提交会标记 redo log 为 prepare 状态, 这样如果数据库宕机(在写 binlog 时)再重启, 读取到这个标志, 就知道提交不是完整的, 于是就要通过判断 binlog 的LSN 做一些处理了.(啥处理我也不知道, 可能是照常提交, 也可能是回滚)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS: 选取索引只能用一个索引, 除了 union 好像会触发合并索引, 但合并后也算一个索引.</p>
<p>即使是 update 语句也会使用优化器寻找查询计划, 因为当带条件时, 需要先锁定记录, 再进行修改.</p>
</blockquote>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210203163808.png" alt="image-20210203163806936"></p>
<h3 id="几个核心组件的作用"><a href="#几个核心组件的作用" class="headerlink" title="几个核心组件的作用"></a>几个核心组件的作用</h3><ul>
<li>连接器: 网络编程建立端口监听, 接收客户端发送的SQL语句</li>
<li>分析器: 对SQL进行语法、词法上的分析。</li>
<li>优化器: 生成执行计划、选择索引。<ul>
<li>*<em>逻辑转换: *</em>包括否定消除、等值传递和常量传递、常量表达式求值、外连接转换为内连接、子查询转换、视图合并等；</li>
<li>*<em>优化准备: *</em>例如索引 ref 和 range 访问方法分析、查询条件扇出值（fan out，过滤后的记录数）分析、常量表检测；</li>
<li>*<em>基于成本优化: *</em>包括访问方法和连接顺序的选择等；</li>
<li>*<em>执行计划改进: *</em>例如表条件下推、访问方法调整、排序避免以及索引条件下推。</li>
</ul>
</li>
<li>执行器: 操作执行引擎，获取SQL的执行结果</li>
<li>存储引擎(执行引擎): 负责具体的语句执行, 查询等.</li>
</ul>
<blockquote>
<p>PS: 基数(值某列数据去重后剩余个数, 估算得到) 会被用于分析索引的过滤效果.</p>
</blockquote>
<blockquote>
<p>然后是存储引擎里面的一些概念</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储引擎中</span></span><br><span class="line">Buffer Pool: 用于缓存表数据的改动, 有自己的落盘时机.</span><br><span class="line"></span><br><span class="line">Redo <span class="built_in">log</span> Buffer: 用于缓存 redo <span class="built_in">log</span>, 有自己的落盘时机.</span><br><span class="line">	commit 事务时落盘</span><br><span class="line">	可配置 everysec 每秒触发落盘</span><br><span class="line"></span><br><span class="line">Binlog Buffer: 用于缓存 binlog, 即记录每个改动, 有自己的落盘时机.</span><br><span class="line">	commit 事务时</span><br><span class="line">		</span><br><span class="line">undo <span class="built_in">log</span> 文件: 默认存于共享表空间中, 也可单独存放于一个表空间. 保存 undo <span class="built_in">log</span>, 有瘦身机制.</span><br><span class="line"></span><br><span class="line">redo <span class="built_in">log</span>: 用于保存 Buffer Pool 发送的变动. 防止 Buffer Pool 的脏页未刷新到磁盘就宕机导致数据丢失.</span><br><span class="line">binlog: 记录逻辑表的改动, 可用于集群同步数据, 审计SQL渗透, 备份/恢复数据库.</span><br><span class="line">undo <span class="built_in">log</span>: 用于保存事务中的改动, 便于事务失败触发回滚时回滚数据.</span><br><span class="line"></span><br><span class="line">redo <span class="built_in">log</span> vs binlog</span><br><span class="line">一个(redo <span class="built_in">log</span>)保存数据页变动, 而数据页是实际的物理空间加载到内存中的缓存, 所以记录的是物理上的改动.</span><br><span class="line">一个(binlog)保存逻辑上的改动, 比如 xx 表的 id=xxx 的行的 xx 列数据修改为了 xx. 或者哪张表新增了一行, 数据是 xxx...  所以记录的是逻辑上的改动.</span><br><span class="line">两者最大的区别就是 redo <span class="built_in">log</span> 是大小是有限的, 到了一定的大小, 会将无用的数据删掉, 而 binlog 更是一种备份, 只会越来越大... 而且没法通过瘦身保持某个大小...</span><br></pre></td></tr></table></figure>



<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务回滚</span></span><br><span class="line">1.undo <span class="built_in">log</span>: 分 insert/update, update 又分 update/delete; 但无论啥类型, 目的都是辅助事务回滚, </span><br><span class="line">	其中 insert 比较简单, 当回滚时根据记录下的主键(联合主键)通过索引找到对应行, 删除即可.</span><br><span class="line">	当回滚时 update 是根据记录的主键找到记录后, 再根据记录下的修改过的列数据, 反向修改回去.</span><br><span class="line">	当回滚时 delete 是根据记录的整行数据, 然后 insert 回去.</span><br><span class="line">2.但一个事务往往不止一条 SQL, 因此也不止一个 undo <span class="built_in">log</span>, 每增加一条 SQL, undo <span class="built_in">log</span> 也随之增加, 这些 undo <span class="built_in">log</span> 会组成一个链条.</span><br><span class="line">2.若为单个事务, 当回滚时, 情况比较简单, 即只需从链条尾部, 反向遍历, 往前回滚每个 undo <span class="built_in">log</span> 就行了.</span><br><span class="line">3.若为多个事务, 与单个事务类似, 只是还需要注意链条的维护(即维持链条的连通性)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隔离级别</span></span><br><span class="line">1.原理是开启事务会创建一个 ReadView, 其作用是判断 undo <span class="built_in">log</span> 链条中哪些数据是可读的.</span><br><span class="line">2.先说 ReadView, 其存有当前事务 id, 事务启动时那会未提交的事务 id 列表, 所有未提交事务中最小的事务, 下一个事务id; 这里面未提交的事务是重点.</span><br><span class="line">3.RR: 可重复读, 事务一开启则创建一个 ReadView, 直到事务结束; 接着倒着遍历链条, 直到 undo <span class="built_in">log</span> 是比自己小且不在未提交事务中的事务记录时停下, 仅获取此时的数据, 由于事务开启过程中, ReadView 不改变, 因此整个事务过程中的读取总是一致的.</span><br><span class="line">4.RC: 读已提交, 和 RR 略有不同, 不同之处在于其每次 select 都会重新获取 ReadView, 这使得若有事务提交后, 再 select 数据, 则生成的 ReadView 数据会发生变化(即未提交事务 id 列表中少了刚刚提交的事务). 因此同样的逻辑进行判断, RC 能读取到已提交的事务的改动.</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS: 居然问我 读未提交??  那不是不需要 ReadView 就能实现吗...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>图为回滚对应的 undo 链; 以及隔离级别原理的 ReadView.</p>
</blockquote>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210203155235.png" alt="image-20210203155232258"></p>
<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210203155257.png" alt="image-20210203155256012"></p>
<h2 id="MySQL-速记"><a href="#MySQL-速记" class="headerlink" title="MySQL 速记"></a>MySQL 速记</h2><h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><blockquote>
<p>MySQL 索引一般选择 B+树做为数据结构存储. B+ 树的优点是, 对文件IO的访问次数控制在 3 次, 保证速度的同时, 能存储千万行数据.</p>
</blockquote>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对常用列添加索引, 视具体情况选择单一索引或复合索引(一般为复合)</span><br><span class="line">2.通过 Explain 语句分析执行计划, 将 type 提升到至少 index 级别.</span><br><span class="line">3.通过 Explain 语句分析执行计划, 将 extra 中 Using filesort消除(排序列加索引), Using join buffer消除 (通过给关联表的关联列加索引), Using temporary (一般通过分组列加索引), Using where(根据最左原则对条件列加复合索引)</span><br></pre></td></tr></table></figure>



<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ACID:</span><br><span class="line">A: 原子性, 多个操作要么都做, 要么都不做</span><br><span class="line">C: 一致性, 数据库文件的状态必须从一个一致性状态到另一个一致性状态.</span><br><span class="line">I: 隔离性, 事物之间相互隔离, 互不影响.</span><br><span class="line">D: 持续性, 一个事务一但提交, 则对数据库的改变是永久的.</span><br></pre></td></tr></table></figure>



<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.读未提交: 可读取其他未提交事务的执行结果(如更新了某个字段), 可能会造成读取错误的数据(未提交的事务回滚了), 造成脏读.</span><br><span class="line">2.读已提交: 可读取其他已提交事务的执行结果, 2次读取数据还是可能不一致(其他事务又提交了), 造成不可重复读.</span><br><span class="line">3.可重复读: 确保同一事务内多次读取数据时, 会看到相同的数据. 但可能造成幻读, 如批量修改登录密码后, 另一个事务新增了一条记录, 导致新纪录未修改.</span><br><span class="line">4.串行化: 事务串行化执行, 效率低.</span><br></pre></td></tr></table></figure>

<h4 id="MySQL-默认隔离级别"><a href="#MySQL-默认隔离级别" class="headerlink" title="MySQL 默认隔离级别"></a>MySQL 默认隔离级别</h4><p><code>可重读读</code></p>
<h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁: 分为排它锁(X) 和共享锁(S). 即写锁和读锁.</span><br><span class="line">表锁: 分为元数据锁(MDL)和表锁.</span><br></pre></td></tr></table></figure>

<h4 id="锁触发方式"><a href="#锁触发方式" class="headerlink" title="锁触发方式"></a>锁触发方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行锁: 隐式(条件带有索引则锁对应列, 不带索引则锁全部行, RR 总会带有 GAP 锁, RC 不会), 显式(使用 for update, lock in share mode)</span><br><span class="line">表锁: 隐式(对整个表不带条件进行增删改, 或任何 DDL 操作) 显示(使用 for update, lock in share mode)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/30/source-code-spring-cloud-gateway/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/source-code-spring-cloud-gateway/" class="post-title-link" itemprop="url">Spring Gateway 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-30 17:07:38" itemprop="dateCreated datePublished" datetime="2021-01-30T17:07:38+08:00">2021-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:51:22" itemprop="dateModified" datetime="2021-03-28T19:51:22+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud/" itemprop="url" rel="index"><span itemprop="name">spring-cloud</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/30/source-code-spring-cloud-gateway/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/30/source-code-spring-cloud-gateway/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Gateway-源码笔记"><a href="#Spring-Gateway-源码笔记" class="headerlink" title="Spring Gateway 源码笔记"></a>Spring Gateway 源码笔记</h1><h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">1.DispatcherHandler</span><br><span class="line">	Spring Webflux 的核心类, 负责协调 HandlerMapping 和 HandlerAdapter</span><br><span class="line"></span><br><span class="line">2.HandlerMapping</span><br><span class="line">	Spring Webflux 的核心类, 负责根据请求信息查找 handler</span><br><span class="line"></span><br><span class="line">3.HandlerAdapter</span><br><span class="line">	Spring Webflux 的核心类, 负责执行 handler</span><br><span class="line">	</span><br><span class="line">4.RoutePredicateHandlerMapping</span><br><span class="line">	Spring Gateway 实现的 HandlerMapping, 负责根据谓词查找 Route 对象并返回 handler(FilteringWebHandler)</span><br><span class="line"></span><br><span class="line">5.FilteringWebHandler</span><br><span class="line">	是一个 handler</span><br><span class="line">	用于获取 route 对象的信息(主要是 GatewayFilter), 然后封装所有拦截器(包括 GlobalFilter)到 DefaultGatewayFilterChain, 挨个执行, 倒叙回归.</span><br><span class="line">	</span><br><span class="line">6.RoutePredicateFactory</span><br><span class="line">	谓词实现类的工厂类</span><br><span class="line">	负责创建具体的谓词工厂(如 Path, Method, Before 等)</span><br><span class="line">	apply() 返回一个 Predicate</span><br><span class="line">	</span><br><span class="line">7.Predicate</span><br><span class="line">	定义了 <span class="built_in">test</span> 方法, 返回 Boolean 值, <span class="literal">true</span> 代表匹配, <span class="literal">false</span> 代表不匹配(指匹配 Route)</span><br><span class="line">	</span><br><span class="line">8.GlobalFilter/GatewayFilter</span><br><span class="line">	定义了一个拦截方法, 可拦截请求进行相应处理</span><br><span class="line">	</span><br><span class="line">9.AsyncPredicate/AndAsyncPredicate</span><br><span class="line">	AsyncPredicate 本质上是一个方法(单方法接口), 方法被调用时会调用保存的 Predicate 类型字段的 <span class="built_in">test</span>() 方法.</span><br><span class="line">  AndAsyncPredicate 是一个左右结构的 AsyncPredicate, 进行判断时先判断左边, 再判断右边</span><br><span class="line">  若不断的 and, 会形成树结构. 所以执行时类似遍历二叉树.</span><br><span class="line"></span><br><span class="line">10.RouteDefinitionRouteLocator</span><br><span class="line">	负责从不同的 Locator(如配置文件) 获取 RouteDefinition, 并负责将 RouteDefinition 转成 Route 对象</span><br><span class="line">	</span><br><span class="line">11.RouteDefinition</span><br><span class="line">	包含有路由的所有配置信息, 含谓词, 拦截器, id, url 等等, 但都是字符串.</span><br><span class="line">	</span><br><span class="line">12.Route</span><br><span class="line">	含有的配置信是转化好了的, 如 Predicate 和 GatewayFilter.</span><br><span class="line">	</span><br><span class="line">13.NettyRoutingFilter</span><br><span class="line">	使用 netty 发送 http/wss 等请求.</span><br><span class="line"></span><br><span class="line">14.GatewayFilterFactory</span><br><span class="line">	拦截器实现类的工厂类</span><br><span class="line">	负责创建具体的 GatewayFilter 对象.</span><br><span class="line"></span><br><span class="line">15.AbstractConfigurable</span><br><span class="line">	负责处理谓词的配置和拦截器的配置转化成不同的 Class 配置.</span><br><span class="line">	实际上由 shortcutFieldOrder 属性配合 Binder 实现.</span><br><span class="line">	即按 shortcutFieldOrder 配置的字段列表, 按顺序从 PropertySource 中读取数据进行绑定; 而 PropertySource 则是从 RouteDefinition 的配置信息加入到 Map 后再用 MapConfigurationPropertySource 包装 Map 而得到的.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 除了谓词工厂和拦截器工厂这块的实现复杂, 其他都算比较简单, 哪怕响应式编程的代码到处都是, 也还是可以大致的理解代码的意思.</p>
<p>这两个工厂其实基本是同一套逻辑, 同一套代码, 就是有一个接口名不同, 然后其作用也不同, 但很相似.</p>
</blockquote>
<h2 id="谓语的实现原理-如何判断哪些请求该走哪个道"><a href="#谓语的实现原理-如何判断哪些请求该走哪个道" class="headerlink" title="谓语的实现原理(如何判断哪些请求该走哪个道)?"></a>谓语的实现原理(如何判断哪些请求该走哪个道)?</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Spring gateway 基于 Spring webflux, 因此会执行 DispatcherHandler, 这是一个 WebHandler, 所以会调用 DispatcherHandler.handle(), 这个类通过 HandlerMapping 查找对应的 handler 来执行.</span><br><span class="line">2.在初始化时会从容器中查找 HandlerMapping 类型的 bean, 用于查找 handler; 而 gateway 实现了一个 RoutePredicateHandlerMapping(GatewayAutoConfiguration 中注册进去的); 因此这里是入口!!!</span><br><span class="line">3.再看 RoutePredicateHandlerMapping 的逻辑, 其通过继承抽象类, 因此会在 getHandlerInternal() 中获取 handler. 接着回顾下 Route 对象的获取.</span><br><span class="line">4.其使用 RouteDefinitionRouteLocator 对象来调用 PropertiesRouteDefinitionLocator.getRouteDefinitions() 获取 RouteDefinition 集合对象(这里还有好几个不同的 Locator), 然后在 RouteDefinitionRouteLocator.convertToRoute() 中将 RouteDefinition 转成 Route 对象, 此时会调用 RouteDefinitionRouteLocator.combinePredicates() 将 RouteDefinition 中的 PredicateDefinition 集合信息转成了 AsyncPredicate 对象集合. 这个 AsyncPredicate 是通过解析谓词字符串, 根据谓词名称获取工厂类(PredicateFactory)再调用相应工厂类的方法(apply 方法)生成含相应逻辑判断的 GatewayPredicate 类(判断逻辑在 <span class="built_in">test</span> 方法中); 顺带一提谓词配置信息是 从 apply 的参数中传递过来的.</span><br><span class="line">5.Spring Gateway 默认注入了很多工厂(见 GatewayAutoConfiguration), 如 Host,Path,Method,Query,Cookie 等等.</span><br><span class="line">6.这样 在 RoutePredicateHandlerMapping.lookupRoute() 中的 r.getPredicate().apply(exchange) 就会执行 Route 中的谓词判断, 仅保留匹配的 Route, 然后再剩下的 Route 中取第一个返回. 最后将 Route 对象存到 exchange 中, 然后返回 FilteringWebHandler. </span><br><span class="line">7.这是一个 WebHandler, 会由自带的适配器 SimpleHandlerAdapter 执行, 即调用其 handle 方法.</span><br><span class="line">8.FilteringWebHandler 从 exchange 中取出 Route 对象, 在将 globalFilter 和 gatewayFilter 放到集合中(相当于链)再递归调用所有 Filter; 其中有几个 Filter 会执行请求, 即将请求分发到指定地址. 如 NettyRoutingFilter(见 GatewayAutoConfiguration).</span><br><span class="line">9.到此以将 Spring gateway 接收到的请求根据谓语匹配对应的 Route(路由) 再执行所有的 Filter 后请求 route 配置的地址.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 从 Spring webflux 的入口, 先 getHandler(), 得到的是返回值 FilteringWebHandler, 这个返回值会被 SimpleHandlerAdapter 执行, 但与谓词的逻辑无关; 但 getHandler() 还将配置文件(以及其他地方)获取到的 RouteDefinition 转成 Route 对象, 同时也将 RouteDefinition 中的 PredicateDefinition 转换成了 Predicate, 再将多个 Predicate 组成树结构变成一个 AsyncPredicate; 然后调用 AsyncPredicate 遍历执行每个谓词判断. 有一个返回 false, 则整个结果返回 false (指 and 相连). 如此便完成了根据谓词判断是否匹配 Route!!</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A1(DispatcherHandler)</span><br><span class="line">A2(HandlerMapping#getHandler)</span><br><span class="line">A3(RoutePredicateHandlerMapping#getHandlerInternal)</span><br><span class="line">A4(RouteDefinitionRouteLocator#getRouteDefinitions)</span><br><span class="line">A5(RouteDefinition)</span><br><span class="line">A6(RouteDefinitionRouteLocator#convertToRoute)</span><br><span class="line">A7(Route)</span><br><span class="line">A8(RouteDefinitionRouteLocator#combinePredicates)</span><br><span class="line">A9(PredicateDefinition#谓词配置信息)</span><br><span class="line">A0(AsyncPredicate#可执行的谓词)</span><br><span class="line"></span><br><span class="line">B0(PredicateFactory#apply)</span><br><span class="line">B1(GatewayPredicate#test 谓词判断)</span><br><span class="line">B2(GlobalFilter 含 NettyRoutingFilter)</span><br><span class="line">B3(FilteringWebHandler)</span><br><span class="line">B4(SimpleHandlerAdapter#适配器)</span><br><span class="line">B5(DefaultGatewayFilterChain#拦截器链)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A1--调用--&gt;A2</span><br><span class="line">A2--调用子类--&gt;A3</span><br><span class="line"></span><br><span class="line">A3--后触发所有--&gt;A0</span><br><span class="line">A0--通过--&gt;B1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A4--从配置文件等地方获得--&gt;A5</span><br><span class="line">A5--通过--&gt;A6</span><br><span class="line"></span><br><span class="line">A6--还调用--&gt;A8</span><br><span class="line">A8--将--&gt;A9</span><br><span class="line">A9--通过调用--&gt;B0</span><br><span class="line">B0--得到 Predicate 对象, 再由多个对象组合得到--&gt;A0</span><br><span class="line"></span><br><span class="line">B1--返回匹配的--&gt;A7</span><br><span class="line">A7--将其存到 exchange 对象中, 然后返回--&gt;B3</span><br><span class="line"></span><br><span class="line">B4--负责执行--&gt;B3</span><br><span class="line">B3--从 exchange 对象获取 Route 后再将--&gt;B2</span><br><span class="line">B2--打包封装成一个--&gt;B5</span><br><span class="line"></span><br><span class="line">B5--最终会执行--&gt;G1(NettyRoutingFilter#发起HTTP请求)</span><br><span class="line"></span><br><span class="line">A1--调用--&gt;B4</span><br></pre></td></tr></table></figure>





<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210131004943.png" alt="iShot2021-01-31 00.48.56"></p>
<h2 id="与-LoadBalancer-对接步骤"><a href="#与-LoadBalancer-对接步骤" class="headerlink" title="与 LoadBalancer 对接步骤"></a>与 LoadBalancer 对接步骤</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.上面讲到执行所有的 Filter, 那么除了用户配置的 GatewayFilter, Gateway 配置的全局 Filter 也会执行(见 GatewayAutoConfiguration); 而负责处理 lb:// 的 Filter 是 ReactiveLoadBalancerClientFilter (见 GatewayReactiveLoadBalancerClientAutoConfiguration) </span><br><span class="line">2.具体方法为 ReactiveLoadBalancerClientFilter.filter(), 其逻辑是取出 host, 调用 LoadBalancer 的 choose() 获取 ServiceInstance, 然后将 url put 回 exchange 的上下文中存起来即可.</span><br></pre></td></tr></table></figure>



<h2 id="拦截器的执行方式"><a href="#拦截器的执行方式" class="headerlink" title="拦截器的执行方式?"></a>拦截器的执行方式?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截链是肯定的, 所有的 Filter 都可以先执行自己逻辑, 再使用 chain 触发下一个 Filter 直到无拦截器</span></span><br><span class="line"><span class="comment">// 然后开始返回, 因为是顺序进入, 所以是倒叙返回</span></span><br><span class="line"><span class="comment">// 返回后正常是一路不断往回返回, 但你的 Filter 也可以在 调用 chain 的时候不直接返回, 而是先暂存返回值, 再通过 exchange 对象(此时执行了其他 Filter 包括实际请求也执行了, 因此会有响应数据)取出响应数据(或返回值), 进行修改, 再 return 暂存的变量.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultGatewayFilterChain</span> <span class="keyword">implements</span> <span class="title">GatewayFilterChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;GatewayFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">  DefaultGatewayFilterChain(List&lt;GatewayFilter&gt; filters) &#123;</span><br><span class="line">    <span class="keyword">this</span>.filters = filters;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DefaultGatewayFilterChain</span><span class="params">(DefaultGatewayFilterChain parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filters = parent.getFilters();</span><br><span class="line">    <span class="keyword">this</span>.index = index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;GatewayFilter&gt; <span class="title">getFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> filters;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.defer(() -&gt; &#123;</span><br><span class="line">      <span class="comment">// 这里挨个取出, 虽然没有对 filters 进行 pop 操作啥的, 但是下一个执行完后, 会调用 chain.filter</span></span><br><span class="line">      <span class="comment">// 等于在递归进入这个方法, 虽然是不同对象的.. 但因为维护了 parent 和 index 的值</span></span><br><span class="line">      <span class="comment">// 使得 this.index &lt; filters.size() 这个递归终止条件得以正确执行. 因此和递归是类似的.</span></span><br><span class="line">      <span class="comment">// 也就是说, 最后所有 filter 执行完后, 也会不断的回归.</span></span><br><span class="line">      <span class="comment">// 那么, 最后的 Filter 完成请求(比如 http 请求), 得到的 response 会存在 exchange 中</span></span><br><span class="line">      <span class="comment">// 这样回归过程(也就是 chain.filter 方法之后得代码就可以取得数据进行干预)</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.index &lt; filters.size()) &#123;</span><br><span class="line">        GatewayFilter filter = filters.get(<span class="keyword">this</span>.index);</span><br><span class="line">        DefaultGatewayFilterChain chain = <span class="keyword">new</span> DefaultGatewayFilterChain(<span class="keyword">this</span>, <span class="keyword">this</span>.index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> filter.filter(exchange, chain);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.empty(); <span class="comment">// complete</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/30/source-code-spring-cloud-alibaba-sentinel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/30/source-code-spring-cloud-alibaba-sentinel/" class="post-title-link" itemprop="url">Spring Cloud Alibaba Sentinel 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-30 15:19:26" itemprop="dateCreated datePublished" datetime="2021-01-30T15:19:26+08:00">2021-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:51:39" itemprop="dateModified" datetime="2021-03-28T19:51:39+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud-alibaba/" itemprop="url" rel="index"><span itemprop="name">spring-cloud-alibaba</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/30/source-code-spring-cloud-alibaba-sentinel/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/30/source-code-spring-cloud-alibaba-sentinel/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Sentinel-与-Openfeign-整合"><a href="#Sentinel-与-Openfeign-整合" class="headerlink" title="Sentinel 与 Openfeign 整合"></a>Sentinel 与 Openfeign 整合</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.SentinelFeignAutoConfiguration</span><br><span class="line">	注入了 Feign.Builder(即 SentinelFeign.Builder) 到容器中</span><br><span class="line"></span><br><span class="line">2.SentinelFeign.Builder</span><br><span class="line">	重写 build 方法注入 sentinel 的 InvocationHandler(SentinelInvocationHandler)</span><br><span class="line"></span><br><span class="line">3.SentinelInvocationHandler</span><br><span class="line">	拦截方法, 包装方法为一个资源, 进行流控降级等处理</span><br><span class="line">	</span><br><span class="line">4.SentinelAutoConfiguration</span><br><span class="line">	注入了 SentinelResourceAspect 来支持 @SentinelResource 注解</span><br><span class="line">	注入了 SentinelBeanPostProcessor 来处理 @SentinelRestTemplate</span><br><span class="line">	注入了 SentinelDataSourceHandler 来加载各种数据源为规则配置</span><br><span class="line"></span><br><span class="line">5.SentinelResourceAspect</span><br><span class="line">	对加了 @SentinelResource 的方法添加 @Around 通知, 包围原方法已实现流控降级等处理.</span><br><span class="line">	</span><br><span class="line">6.SentinelBeanPostProcessor</span><br><span class="line">	对加了 @SentinelRestTemplate 注解的 RestTemplate bean, 添加一个 SentinelProtectInterceptor</span><br><span class="line"></span><br><span class="line">7.SentinelDataSourceHandler</span><br><span class="line">	解析 spring.cloud.sentinel.datasource 的配置, 加载配置的规则到 Sentinel 中.</span><br><span class="line">	</span><br><span class="line">8.SentinelProtectInterceptor</span><br><span class="line">	包装 RestTemplate 的请求, 使其可被流控降级等操作.</span><br></pre></td></tr></table></figure>





<h3 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Feign 那边的步骤是, 先从容器中获取 Feign.Builder 对象, 并且 FeignContext 也会注入一个默认的 Builder 对象, 但是毕竟是子容器, 优先级没有父容器高(加载配置更后, 所以 @ConditionalOnMissingBean 触发, 子容器就不注册了). 因此我们在父容器中中配置一个 Builder 就能进行对接.</span><br><span class="line">2.Feign 的实现是通过 JDK 生成一个代理对象拦截方法来构造并执行 HTTP 请求, 因此其需要一个 InvocationHandler 来拦截配置; 在 Feign 中, 通过字段 invocationHandlerFactory 来创建这个 InvocationHandler, 所以我们注入自己实现的 Builder 需要设置这个字段.</span><br><span class="line">3.即 SentinelFeign.Builder.build() 中调用 super.invocationHandlerFactory(xxx) 来设置.</span><br><span class="line">4.xxx 是匿名内部类, 直接看 create 方法, 这里根据 @FeignClient 注解的配置(fallback/fallbackFactory) 创建了一个 SentinelInvocationHandler</span><br><span class="line">5.SentinelInvocationHandler.invoke() 的逻辑是使用 SphU.entry() 包围 feign 生成的 method(这个 method 是干正事的: 执行负载均衡和发送 Http 请求), 这就对这个 method 进行流量控制了; 然后还在 catch 中处理 fallback.</span><br><span class="line">6.至此, 与 feign 的对接就完成了</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 新建一个 Builder 令生成的 Feign 对象持有我们指定的 invocationHandlerFactory, 使其创建代理对象时使用我们创建的 SentinelInvocationHandler 拦截对象方法; 这样就把方法的执行包围起来, 进行流量控制和熔断降级(catch 异常调用 fallback)了.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A1(FeignClientsRegistrar)</span><br><span class="line">A2(FeignClientFactoryBean)</span><br><span class="line">A3(真实 XxxService 接口)</span><br><span class="line">A4(SentinelInvocationHandler)</span><br><span class="line">A5(SentinelFeignAutoConfiguration)</span><br><span class="line">A6(Feign.Builder 即 SentinelFeign.Builder)</span><br><span class="line">A7(Feign 对象)</span><br><span class="line">A8(代理对象)</span><br><span class="line">A9( sentinel 将方法当做资源进行拦截)</span><br><span class="line">B1(在 catch 中处理 fallback 熔断逻辑)</span><br><span class="line"></span><br><span class="line">A1--扫描 FeignClient 注解, 注入--&gt;A2</span><br><span class="line"></span><br><span class="line">A3--被 controller 调用, 触发--&gt;A4</span><br><span class="line"></span><br><span class="line">A5--注入了一个--&gt;A6</span><br><span class="line">A2--调用--&gt;A6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A6--的 build 方法创建一个--&gt;A7</span><br><span class="line">A7--调用 newInstance 方法创建了含--&gt;A4</span><br><span class="line">A8--用来代替--&gt;A3</span><br><span class="line">A4--的--&gt;A8</span><br><span class="line"></span><br><span class="line">A4--调用--&gt;A9</span><br><span class="line">A9--然后--&gt;B1</span><br></pre></td></tr></table></figure>





<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210130163421.png" alt="image-20210130163418057"></p>
<h3 id="整合-FeignCircuitBreaker-Builder-步骤"><a href="#整合-FeignCircuitBreaker-Builder-步骤" class="headerlink" title="整合 FeignCircuitBreaker.Builder 步骤"></a>整合 FeignCircuitBreaker.Builder 步骤</h3><blockquote>
<p>即不注入自己的 Builder, 使用 openfeign 提供的 Builder, 通过扩展 CircuitBreakerFactory(即扩展 CircuitBreaker) 来实现流控降级(倒是 fallback 的处理便轻松了不少)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在 SentinelCircuitBreakerAutoConfiguration 注入一个 CircuitBreakerFactory.</span><br><span class="line">2.在 Openfeign 中, 会调用其 create() 创建得到一个 CircuitBreaker (即 SentinelCircuitBreaker)</span><br><span class="line">3.接着会在 FeignCircuitBreakerInvocationHandler.invoke() 中获取这个 CircuitBreaker, 调用其 run() 将要执行的 method 交给 SentinelCircuitBreaker 来处理.</span><br><span class="line">4.SentinelCircuitBreaker 中 run() 的实现就是简单的 SphU.entry() 来包装方法为资源进行流控降级, 至于 fallback 则直接调用 apply 交由 Openfeign 处理.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 不写自己的 Builder, 简单多了! 主要是去掉了 fallback 相关配置的获取与处理.</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/29/source-code-spring-cloud-server-discover-and-register/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/source-code-spring-cloud-server-discover-and-register/" class="post-title-link" itemprop="url">Spring Cloud 服务注册与发现源码笔记 (Nacos/Consul/Eureka)</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 13:21:23" itemprop="dateCreated datePublished" datetime="2021-01-29T13:21:23+08:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:49:43" itemprop="dateModified" datetime="2021-03-28T19:49:43+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud/" itemprop="url" rel="index"><span itemprop="name">spring-cloud</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/29/source-code-spring-cloud-server-discover-and-register/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/29/source-code-spring-cloud-server-discover-and-register/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Cloud-服务注册与发现源码笔记-Nacos-Consul-Eureka"><a href="#Spring-Cloud-服务注册与发现源码笔记-Nacos-Consul-Eureka" class="headerlink" title="Spring Cloud 服务注册与发现源码笔记 (Nacos/Consul/Eureka)"></a>Spring Cloud 服务注册与发现源码笔记 (Nacos/Consul/Eureka)</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">1.EurekaClientAutoConfiguration</span><br><span class="line">	注册了众多的 bean</span><br><span class="line">	一部分用于和 Eureka Server 交互</span><br><span class="line">	一部分和 Commons 项目对接</span><br><span class="line">	注册了(EurekaClient/EurekaAutoServiceRegistration/ApplicationInfoManager/EurekaRegistration)</span><br><span class="line">	   </span><br><span class="line">2.EurekaClient</span><br><span class="line">	与 Eureka Server 端交互</span><br><span class="line">	负责向 Eureka Server 端注册/注销服务实例</span><br><span class="line">	在构造方法和 shutdown 方法中根据配置处理自动注册和自动注销.</span><br><span class="line"></span><br><span class="line">3.InstanceInfoReplicator</span><br><span class="line">	负责定义一个注册或更新服务实例的任务</span><br><span class="line">	负责管理任务执行器</span><br><span class="line"></span><br><span class="line">4.RestTemplateEurekaHttpClient</span><br><span class="line">	负责根据服务实例信息构造注册/注销的 Http 请求</span><br><span class="line">	使用 RestTemplate 发送请求</span><br><span class="line">	</span><br><span class="line">5.EurekaAutoServiceRegistration</span><br><span class="line">	负责管理服务实例的自动注册/注销, 与容器生命周期挂钩</span><br><span class="line"></span><br><span class="line">6.ApplicationInfoManager</span><br><span class="line">	负责管理服务实例状态变更事件(即管理监听者并在适当时机触发他们)</span><br><span class="line"></span><br><span class="line">7.ApplicationInfoManager.StatusChangeListener</span><br><span class="line">	状态改变事件监听者类</span><br><span class="line">	</span><br><span class="line">8.EurekaHealthCheckHandler</span><br><span class="line">	服务实例状态健康检查类, 注册/注销服务实例前会调用此类进行检查其状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务发现</span></span><br><span class="line">1.BlockingLoadBalancer (Commons 项目上)</span><br><span class="line">	负责调用实际的负载均衡器去选择一个服务实例</span><br><span class="line">	负责调度负载均衡整个过程, 触发相应的生命周期.</span><br><span class="line">	</span><br><span class="line">2.RoundRobinLoadBalancer (Commons 项目上)</span><br><span class="line">	实际的负载均衡策略算法类</span><br><span class="line">	负责连接 ServiceInstanceListSupplier 从其中获取服务实例列表</span><br><span class="line"></span><br><span class="line">3.ServiceInstanceListSupplier</span><br><span class="line">	定义了获取服务实例实例列表的接口(任意方式)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClient</span><br><span class="line">	定义了从服务端获取服务实例列表的接口(更明确了)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClientServiceInstanceListSupplier</span><br><span class="line">	ServiceInstanceListSupplier 的实现类</span><br><span class="line">	连接 ReactiveDiscoveryClient 类, 将服务端获取道德服务实例列表返回出去</span><br><span class="line">	</span><br><span class="line">5.EurekaDiscoveryClient</span><br><span class="line">	实现了 DiscoveryClient 接口</span><br><span class="line">	负责调用 EurekaClient 从 Eureka Server 端获取服务实例列表.</span><br><span class="line"></span><br><span class="line">6.EurekaClient</span><br><span class="line">	与 Eureka Server 端交互</span><br><span class="line">	负责向 Eureka Server 端获取服务实例列表</span><br><span class="line">	在构造方法和 shutdown 方法中根据配置处理自动注册和自动注销.</span><br><span class="line"></span><br><span class="line">7.EurekaServiceInstance</span><br><span class="line">	服务实例信息对象</span><br><span class="line">	实现 ServiceInstance, 与 Commons 对接</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">实现了 Commons 的 DiscoveryClient 接口(即 EurekaDiscoveryClient), 于是服务发现实现了;</span><br><span class="line">实现了 Commons 的 ServiceRegisty 接口(即 EurekaServiceRegistry), 于是服务注册也实现了.</span><br><span class="line">再总结: Commons 大发好.</span><br></pre></td></tr></table></figure>





<h3 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># EurekaClient 构造方法触发(前提 shouldRegisterWithEureka 为 true)</span></span><br><span class="line">1.EurekaClientAutoConfiguration 让容器里注册了一个 EurekaClient</span><br><span class="line">2.EurekaClient 这个类在构造方法中的 initScheduledTasks() 生成了一个 InstanceInfoReplicator 对象</span><br><span class="line">3.然后调用其 instanceInfoReplicator.start(), 逻辑是添加一个定时任务(仅执行一次), 定时任务执行 run()</span><br><span class="line">4.run() 里面会执行 discoveryClient.register() 也就是注册实例信息到 Eureka 上去.</span><br><span class="line">5.register() 里面会调用 RestTemplateEurekaHttpClient<span class="comment">#register() </span></span><br><span class="line">6.这个方法是构造一个 HTTP 请求, 地址为 serviceUrl + <span class="string">"apps/"</span> + info.getAppName(), Method 为 POST, 即 Eureka server 的ip/apps/服务实例名称(如spring.application.name), 当然请求 body 还会带上实例信息 info 对象.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据容器生命周期触发</span></span><br><span class="line">1.EurekaClientAutoConfiguration 让容器里注册了一个 EurekaAutoServiceRegistration.</span><br><span class="line">2.这个类即是 SmartLifecycle(与容器生命周期绑定), 也是 SmartApplicationListener(监听容器加载/关闭事件)</span><br><span class="line">3.因此其对应的 start()/stop() 和 onApplicationEvent() 都实现了对应的逻辑.</span><br><span class="line">4.如 start() 的逻辑为调用 EurekaServiceRegistry<span class="comment">#register()</span></span><br><span class="line">5.register() 先修改本地服务实例的装填, 再通过 com.netflix.discovery.DiscoveryClient<span class="comment">#registerHealthCheck() 来往任务管理器中提交一个任务, 后台执行, 任务 InstanceInfoReplicator#onDemandUpdate()</span></span><br><span class="line">6.此任务就是最终也会调用前面提到的 (4) 中的 run(). 然后就注册上去了.</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS</span></span><br><span class="line">(6) 中的任务, 与状态监听是一致的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 容器注册 EurekaClient, 调用构造方法完成大量初始化工作后, 另起一个线程调用 restTemplate 发送 HTTP 请求将当前服务实例信息发送给 Eureka server. 完成服务注册工作.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A(EurekaClientAutoConfiguration)</span><br><span class="line">A1(EurekaClient)</span><br><span class="line">A2(InstanceInfoReplicator)</span><br><span class="line">A3(EurekaClient#register)</span><br><span class="line">A4(RestTemplateEurekaHttpClient)</span><br><span class="line">A5(RestTemplate)</span><br><span class="line">A6(Eureka Server)</span><br><span class="line">A7(EurekaHttpResponse)</span><br><span class="line"></span><br><span class="line">A--让容器里注册一个--&gt;A1</span><br><span class="line">A1--在构造方法中生成一个--&gt;A2</span><br><span class="line">A2--在 run 方法中调用--&gt;A3</span><br><span class="line">A3--又把服务实例信息交给--&gt;A4</span><br><span class="line">A4--根据服务实例信息构造HTTP请求--&gt;A5</span><br><span class="line">A5--将服务实例信息发送给--&gt;A6</span><br><span class="line">A6--返回一个--&gt;A7</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210129172741.png" alt="image-20210129171345329"></p>
<h3 id="服务注销流程"><a href="#服务注销流程" class="headerlink" title="服务注销流程"></a>服务注销流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器关闭(配置了容器 shouldUnregisterOnShutdown=true)</span></span><br><span class="line">1.在 DiscoveryClient<span class="comment">#shutdown() 中根据 shouldUnregisterOnShutdown 判断是否需要注销</span></span><br><span class="line">2.然后在 unregister() 中调用 RestTemplateEurekaHttpClient<span class="comment">#cancel() </span></span><br><span class="line">3.cancel() 中使用 restTemplate 构造 Method 为 DELETE, URL 为 serviceUrl + <span class="string">"apps/"</span> + appName + <span class="string">'/'</span> + id 的请求并发送给 Eureka server 告知其注销 appName 下对应的服务实例(根据 id).</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收到容器关闭事件</span></span><br><span class="line">1.EurekaClientAutoConfiguration 让容器里注册了一个 EurekaAutoServiceRegistration.</span><br><span class="line">2.这个类即是 SmartLifecycle(与容器生命周期绑定), 也是 SmartApplicationListener(监听容器加载/关闭事件)</span><br><span class="line">3.因此其对应的 start()/stop() 和 onApplicationEvent() 都实现了对应的逻辑.</span><br><span class="line">4.如 stop() 的逻辑为调用 EurekaServiceRegistry<span class="comment">#deregister()</span></span><br><span class="line">5.deregister() 的作用是执行 ApplicationInfoManager<span class="comment">#setInstanceStatus() 将状态改为 DOWN</span></span><br><span class="line">6.因为 ApplicationInfoManager 这个类专门管理状态变化事件, 因此还会将事件发布出去. </span><br><span class="line">7.而在 initScheduledTasks 中就添加了这样的一个监听者, 起作用为调用 InstanceInfoReplicator<span class="comment">#onDemandUpdate()</span></span><br><span class="line">8.接着会调用 InstanceInfoReplicator<span class="comment">#run(), 第一行代码 refreshInstanceInfo() 会确保状态为最新的(那也还是 DOWN)</span></span><br><span class="line">9.但是其最终并不是调用 cancel 注销, 而 register 注册, 不过其中的状态是 DOWN, 因此会有 server 那边判断; 所以容器关闭事件并不会触发 cancel, 但效果应是一样的.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 要么是 shutdown() 中 unregister 调用了 cancel(), 发出了 Method 为 DELETE 的请求来注销; 要么就是 EurekaClientAutoConfiguration 中与容器生命周期做关联, 全程使用 register 接口来更新状态.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A(容器关闭#close)</span><br><span class="line">A1(DiscoveryClient#shutdown)</span><br><span class="line">A2(DiscoveryClient#unregister)</span><br><span class="line">A3(RestTemplateEurekaHttpClient#cancel)</span><br><span class="line">A4(RestTemplate)</span><br><span class="line">A5(Eureka Server) </span><br><span class="line"></span><br><span class="line">A--触发--&gt;A1</span><br><span class="line">A1--调用--&gt;A2</span><br><span class="line">A2--调用--&gt;A3</span><br><span class="line">A3--构造HTTP请求交给--&gt;A4</span><br><span class="line">A4--发送注销申请给--&gt;A5</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210129171241.png" alt="image-20210129171237603"></p>
<h3 id="服务发现流程"><a href="#服务发现流程" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Spring Cloud Commons 中注册了一个 ServiceInstanceListSupplier, 具体为(DiscoveryClientServiceInstanceListSupplier)</span><br><span class="line">2.这个类的作用是借助 ReactiveDiscoveryClient 的 getInstances(String serviceId) 方法向 LoadBalancer 提供从具体的 server(如Eureka) 获取服务实例对象列表, 这样只要实现 ReactiveDiscoveryClient 并放入容器就可以和 Spring cloud LoadBalancer 对接了.</span><br><span class="line">3.在 EurekaDiscoveryClientConfiguration 中让容器注册了一个 DiscoveryClient(具体为 EurekaDiscoveryClient).</span><br><span class="line">4.因为 Spring Cloud Commons 做了大量的预备对接工作, 所以对接其实就结束了.</span><br><span class="line">5.那再简单说下 EurekaDiscoveryClient 的实现, 即注入一个 EurekaClient eurekaClient, 然后调用 DiscoveryClient<span class="comment">#getInstancesByVipAddress() 就获取到了 ServiceInstance 列表.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: Commons 中准备好了对接的方式: 实现 DiscoveryClient 接口, 接着我们的确实现了 DiscoveryClient 接口, 即 EurekaDiscoveryClient, 而这这个类则会调用 EurekaClient 的 getInstancesByVipAddress 从 Eureka Server 端获取注册了的服务实例信息.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A1(BlockingLoadBalancerClient#位于Commons项目)</span><br><span class="line">A2(RoundRobinLoadBalancer#位于Commons项目)</span><br><span class="line">A4(LoadBalancerClientConfiguration#位于Commons项目)</span><br><span class="line">A5(DiscoveryClientServiceInstanceListSupplier)</span><br><span class="line">A6(EurekaDiscoveryClient#getInstances)</span><br><span class="line">A7(EurekaClient#getInstancesByVipAddress)</span><br><span class="line">A9(Eureka Server)</span><br><span class="line">A8(ServiceInstance 集合)</span><br><span class="line"></span><br><span class="line">A1--choose 方法调用--&gt;A2</span><br><span class="line">A2--choose 方法调用--&gt;A5</span><br><span class="line">A4--注入一个--&gt;A5</span><br><span class="line">A5--调用--&gt;A6</span><br><span class="line">A6--调用--&gt;A7</span><br><span class="line">A7--从--&gt;A9</span><br><span class="line">A9--获取--&gt;A8</span><br><span class="line">A10(EurekaDiscoveryClientConfiguration)--注入一个--&gt;A6</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210129233856.png" alt="image-20210129233854498"></p>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><h3 id="关键类-1"><a href="#关键类-1" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">1.ConsulAutoServiceRegistrationAutoConfiguration</span><br><span class="line">	负责添加自动注册/注销相关的 bean</span><br><span class="line">	注册了 ConsulAutoServiceRegistration/ConsulAutoServiceRegistrationListener/ConsulAutoRegistration</span><br><span class="line">	</span><br><span class="line">2.ConsulServiceRegistryAutoConfiguration</span><br><span class="line">	负责注册服务注册相关的 bean</span><br><span class="line">	注册了 ConsulServiceRegistry</span><br><span class="line">	</span><br><span class="line">3.ConsulDiscoveryClientConfiguration</span><br><span class="line">	负责注册服务发现相关的 bean</span><br><span class="line">	注册了 ConsulDiscoveryClient</span><br><span class="line">	</span><br><span class="line">4.ConsulServiceRegistry</span><br><span class="line">	负责与 ConsulClient 对接, 再提供注册/注销功能</span><br><span class="line"></span><br><span class="line">5.ConsulClient</span><br><span class="line">	与 Consul Server 端交互</span><br><span class="line">	负责向 Consul Server 端注册/注销服务实例</span><br><span class="line"></span><br><span class="line">6.AgentConsulClient</span><br><span class="line">	负责根据服务实例信息构造注册/注销的 Http 请求</span><br><span class="line">	</span><br><span class="line">7.ConsulAutoServiceRegistration/ConsulAutoServiceRegistrationListener</span><br><span class="line">	负责管理服务实例的自动注册/注销, 与容器生命周期挂钩</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务发现</span></span><br><span class="line">1.BlockingLoadBalancer (Commons 项目上)</span><br><span class="line">	负责调用实际的负载均衡器去选择一个服务实例</span><br><span class="line">	负责调度负载均衡整个过程, 触发相应的生命周期.</span><br><span class="line">	</span><br><span class="line">2.RoundRobinLoadBalancer (Commons 项目上)</span><br><span class="line">	实际的负载均衡策略算法类</span><br><span class="line">	负责连接 ServiceInstanceListSupplier 从其中获取服务实例列表</span><br><span class="line"></span><br><span class="line">3.ServiceInstanceListSupplier</span><br><span class="line">	定义了获取服务实例实例列表的接口(任意方式)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClient</span><br><span class="line">	定义了从服务端获取服务实例列表的接口(更明确了)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClientServiceInstanceListSupplier</span><br><span class="line">	ServiceInstanceListSupplier 的实现类</span><br><span class="line">	连接 ReactiveDiscoveryClient 类, 将服务端获取道德服务实例列表返回出去</span><br><span class="line">	</span><br><span class="line">5.ConsulDiscoveryClient</span><br><span class="line">	实现了 DiscoveryClient 接口</span><br><span class="line">	负责调用 ConsulClient 从 Consul Server 端获取服务实例列表.</span><br><span class="line"></span><br><span class="line">6.ConsulClient</span><br><span class="line">	与 Consul Server 端交互</span><br><span class="line">	负责向 Consul Server 端获取服务实例列表</span><br><span class="line"></span><br><span class="line">7.ConsulServiceInstance</span><br><span class="line">	服务实例信息对象</span><br><span class="line">	实现 ServiceInstance, 与 Commons 对接</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">实现了 Commons 的 DiscoveryClient 接口(即 ConsulDiscoveryClient), 于是服务发现实现了;</span><br><span class="line">实现了 Commons 的 ServiceRegisty 接口(即 ConsulServiceRegistry), 于是服务注册也实现了.</span><br><span class="line">再总结: Commons 大发好.</span><br></pre></td></tr></table></figure>

<h3 id="服务注册流程-1"><a href="#服务注册流程-1" class="headerlink" title="服务注册流程"></a>服务注册流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.ConsulAutoServiceRegistration 调用 org.springframework.cloud.consul.serviceregistry.ConsulServiceRegistry<span class="comment">#register() 完成注册</span></span><br><span class="line">2.接着 register() 调用 ConsulClient<span class="comment">#agentServiceRegister()</span></span><br><span class="line">3.然后会调用 AgentConsulClient<span class="comment">#agentServiceRegister()</span></span><br><span class="line">4.生成并发送请求, 请求地址为 /v1/agent/service/register</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 其实和 Eureka 差不多, 只是我跳过了一点点细节. 基本是就是 与 ServiceRegistry 交互了, 非常的配合 Commons 项目, 就像一个人写的一样…</p>
</blockquote>
<h3 id="服务发现流程-1"><a href="#服务发现流程-1" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先是 DiscoveryClientServiceInstanceListSupplier 会调用 ConsulDiscoveryClient<span class="comment">#getInstances()</span></span><br><span class="line">2.接着 getInstances() 会调用 ConsulClient<span class="comment">#getHealthServices()</span></span><br><span class="line">3.然后就是发送 HTTP 请求了, 请求地址为 /v1/health/service/, 返回的对象封装处理下得到 ServiceInstance 的实现类 ConsulServiceInstance.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 这次真的是和 Eureka 类似, 从 Commons 到 ConsulDiscoveryClient, 流程是一样的. 而其实 ConsulDiscoveryClient 的逻辑也和 EurekaDiscoverClient 类似… 只能说其实服务注册发现这个框架, 我们关注的功能其实并不是难点. 难点是 server 端的管理.</p>
</blockquote>
<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><h3 id="关键类-2"><a href="#关键类-2" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">1.NacosServiceRegistryAutoConfiguration</span><br><span class="line">	负责添加自动注册/注销相关的 bean</span><br><span class="line">	注册了 NacosAutoServiceRegistration/NacosServiceRegistry/NacosRegistration</span><br><span class="line">	</span><br><span class="line">2.NacosDiscoveryClientConfiguration</span><br><span class="line">	负责注册服务发现相关的 bean</span><br><span class="line">	注册了 NacosDiscoveryClient</span><br><span class="line">	</span><br><span class="line">3.NacosServiceRegistry</span><br><span class="line">	负责与 NamingService 对接, 再提供注册/注销功能</span><br><span class="line"></span><br><span class="line">4.NamingService</span><br><span class="line">	与 Nacos Server 端交互</span><br><span class="line">	负责向 Nacos Server 端注册/注销服务实例</span><br><span class="line">	调用 NamingProxy</span><br><span class="line"></span><br><span class="line">5.NamingProxy</span><br><span class="line">	负责根据服务实例信息构造注册/注销的 Http 请求</span><br><span class="line">	</span><br><span class="line">6.NacosAutoServiceRegistration</span><br><span class="line">	负责管理服务实例的自动注册/注销, 与容器生命周期挂钩</span><br><span class="line"></span><br><span class="line">7.NacosRegistration</span><br><span class="line">	本地实例对象, 相比服务实例数据更多</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务发现</span></span><br><span class="line">1.BlockingLoadBalancer (Commons 项目上)</span><br><span class="line">	负责调用实际的负载均衡器去选择一个服务实例</span><br><span class="line">	负责调度负载均衡整个过程, 触发相应的生命周期.</span><br><span class="line">	</span><br><span class="line">2.RoundRobinLoadBalancer (Commons 项目上)</span><br><span class="line">	实际的负载均衡策略算法类</span><br><span class="line">	负责连接 ServiceInstanceListSupplier 从其中获取服务实例列表</span><br><span class="line"></span><br><span class="line">3.ServiceInstanceListSupplier</span><br><span class="line">	定义了获取服务实例实例列表的接口(任意方式)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClient</span><br><span class="line">	定义了从服务端获取服务实例列表的接口(更明确了)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClientServiceInstanceListSupplier</span><br><span class="line">	ServiceInstanceListSupplier 的实现类</span><br><span class="line">	连接 ReactiveDiscoveryClient 类, 将服务端获取道德服务实例列表返回出去</span><br><span class="line">	</span><br><span class="line">5.NacosDiscoveryClient</span><br><span class="line">	实现了 DiscoveryClient 接口</span><br><span class="line">	负责调用 NamingService 从 Nacos Server 端获取服务实例列表.</span><br><span class="line"></span><br><span class="line">6.NamingService</span><br><span class="line">	与 Nacos Server 端交互</span><br><span class="line">	负责向 Nacos Server 端获取服务实例列表</span><br><span class="line"></span><br><span class="line">7.NacosServiceInstance</span><br><span class="line">	服务实例信息对象</span><br><span class="line">	实现 ServiceInstance, 与 Commons 对接</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">实现了 Commons 的 DiscoveryClient 接口(即 NacosDiscoveryClient), 于是服务发现实现了;</span><br><span class="line">实现了 Commons 的 ServiceRegisty 接口(即 ConsulServiceRegistry), 于是服务注册也实现了.</span><br><span class="line">再总结: Commons 大发好.</span><br></pre></td></tr></table></figure>



<h3 id="服务注册流程-2"><a href="#服务注册流程-2" class="headerlink" title="服务注册流程"></a>服务注册流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.NacosAutoServiceRegistration 调用 NacosServiceRegistry<span class="comment">#register 完成注册</span></span><br><span class="line">2.接着 register() 调用 NacosNamingService<span class="comment">#registerInstance()</span></span><br><span class="line">3.然后会调用 NamingProxy<span class="comment">#registerService()</span></span><br><span class="line">4.生成并发送请求, 请求地址为 /nacos/v1/ns/instance</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 这和 Consul 差不多; 还是继承 AbstractAutoServiceRegistration 来与 ServiceRegistry 交互了, 也是非常的配合 Commons 项目啊!!</p>
</blockquote>
<h3 id="服务发现流程-2"><a href="#服务发现流程-2" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先是 DiscoveryClientServiceInstanceListSupplier 会调用 NacosDiscoveryClient<span class="comment">#getInstances()</span></span><br><span class="line">2.接着 getInstances() 会调用 NacosServiceDiscovery<span class="comment">#getInstances()</span></span><br><span class="line">3.然后就是发送 HTTP 请求了, 请求地址为 /nacos/v1/ns/instance/list, 返回的对象封装处理下得到 ServiceInstance 的实现类 NacosServiceInstance.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 依然是和 Eureka/Consul 类似, 从 Commons 到 NacosDiscoveryClient, 流程是一样的. 而其实 NacosDiscoveryClient 的逻辑也和 ConsulDiscoveryClient/EurekaDiscoverClient 类似, 最终总是发起 HTTP 查询 server 端, 所以 server 端的代码才比较有趣啊.</p>
</blockquote>
<h2 id="Nacos-Config"><a href="#Nacos-Config" class="headerlink" title="Nacos Config"></a>Nacos Config</h2><h3 id="Nacos-Config-Client-加载-nacos-server-配置原理"><a href="#Nacos-Config-Client-加载-nacos-server-配置原理" class="headerlink" title="Nacos Config Client 加载 nacos server 配置原理"></a>Nacos Config Client 加载 nacos server 配置原理</h3><h4 id="关键类-3"><a href="#关键类-3" class="headerlink" title="关键类"></a>关键类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.NacosConfigBootstrapConfiguration</span><br><span class="line">	注册了一个 NacosPropertySourceLocator</span><br><span class="line"></span><br><span class="line">2.NacosPropertySourceLocator</span><br><span class="line">	用于从 nacos server 上加载 dataId 对应的配置文件到 environment 的 PropertySource 集合中.</span><br><span class="line">	</span><br><span class="line">3.ConfigService</span><br><span class="line">	用于与 nacos server 通信, 获取配置文件, 乃至订阅更新</span><br><span class="line">	</span><br><span class="line">4.NacosPropertySourceBuilder</span><br><span class="line">	借助 ConfigService 与 NacosDataParserHandler 从 nacos 获取 NacosPropertySource</span><br><span class="line">	</span><br><span class="line">5.NacosDataParserHandler</span><br><span class="line">	用于序列化(转码)服务端的配置文件数据为一个 PropertySource(即 NacosPropertySource)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动刷新</span></span><br><span class="line">1.NacosConfigAutoConfiguration</span><br><span class="line">2.NacosContextRefresher</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: ConfigService 与 NacosDataParserHandler 是两个干事的, 其他都是渣渣!!!</p>
</blockquote>
<h4 id="从-server-获取配置流程"><a href="#从-server-获取配置流程" class="headerlink" title="从 server 获取配置流程"></a>从 server 获取配置流程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.在 NacosConfigBootstrapConfiguration 中注册了一个 PropertySourceLocator(即 NacosPropertySourceLocator), 可用于为 environment 添加 PropertySource</span><br><span class="line">2.然后实现 locate 方法, 即 NacosPropertySourceLocator<span class="comment">#locate()</span></span><br><span class="line">3.在 locate() 的最后面, 调用了 loadApplicationConfiguration()</span><br><span class="line">4.这个方法通过多次调用 loadNacosDataIfPresent() 加载 dataId 和不同文件后缀以及profile 组和得到不同的 dataId.</span><br><span class="line">5.loadNacosDataIfPresent() 调用了 loadNacosPropertySource()</span><br><span class="line">6.其最终调用了 NacosPropertySourceBuilder<span class="comment">#loadNacosData()</span></span><br><span class="line">7.loadNacosData() 调用 ConfigService<span class="comment">#getConfig() </span></span><br><span class="line">8.getConfig() 会使用 ClientWorker<span class="comment">#getServerConfig() 发起 HTTP 请求从 nacos server 获取配置文件. 其请求地址是 /v1/cs/configs</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 还是挺简单的, 发个 HTTP 获取配置文件, 然后转化成一个 PropertySource, 再在 NacosPropertySourceLocator 的 locate 中扔进 environment 中去. Bingo!!!</p>
</blockquote>
<h4 id="从-server-实时更新原理"><a href="#从-server-实时更新原理" class="headerlink" title="从 server 实时更新原理"></a>从 server 实时更新原理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.在 NacosConfigAutoConfiguration 注册了一个 NacosContextRefresher</span><br><span class="line">2.其实现了 ApplicationListener&lt;ApplicationReadyEvent&gt;, 也就是会在容器准备事件触发后调用 NacosContextRefresher<span class="comment">#registerNacosListenersForApplications()</span></span><br><span class="line">3.在进行两个配置判断后(即 isRefreshEnabled() 和 PropertySource 的 isRefreshable), 调用 NacosContextRefresher<span class="comment">#registerNacosListener() </span></span><br><span class="line">4.这个方法通过 NacosConfigService<span class="comment">#addListener() 注册一个 AbstractSharedListener 监听者到 cacheData.</span></span><br><span class="line">5.而 ClientWorker<span class="comment">#checkConfigInfo() 中添加的 LongPollingRunnable 任务, 会在 run() 中执行 getServerConfig() 获取服务配置文件, 然后与当前缓存对比 md5, 若更新则通过 cacheData 取出刚刚添加的 listener, 触发事件(即 receiveConfigInfo() )</span></span><br><span class="line">6.触发后又会再发布一个 RefreshEvent 事件</span><br><span class="line">7.接着流转到 RefreshEventListener.onApplicationEvent()</span><br><span class="line">8.然后又会调用 ContextRefresher.refresh(), 这个方法中的 refreshEnvironment() 会调用 addConfigFilesToEnvironment(), 这方法先复制一个 StandardEnvironment, 将其放入到 SpringApplication 中, 再调用 SpringApplication 的 run() 走一遍, 会触发 NacosPropertySourceLocator.locate(), 于是复制的 environment 里面有新数据了, 再将其拷贝替换到当前的 environment. 完成 environment 的刷新. </span><br><span class="line">9.接着发布一个 EnvironmentChangeEvent 事件, 用来刷新 @ConfigurationProperties 注解的 Bean. (这么喜欢事件?不愧是写出 RocketMQ 的阿里啊!!!)</span><br><span class="line">10.接着在 ConfigurationPropertiesRebinder 中接收到这个事件, 触发 onApplicationEvent()</span><br><span class="line">11.然后会执行 ConfigurationPropertiesRebinder<span class="comment">#rebind()</span></span><br><span class="line">12.其逻辑是将 postProcessBeforeInitialization 中存起来的 ConfigurationPropertiesBean 类型的 map 遍历, 进行重新绑定(即 destroyBean 后再 initializeBean, 则会从新配置重新赋值).</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 有的地方(NacosContextRefresher)监听容器初始化添加配置更新的监听者, 自己不干活只发布配置刷新事件;</p>
<p>有的地方(ClientWorker)添加轮询任务获取服务端配置文件与本地 cacheData 对比 md5 来判断是否触发配置更新的监听者;</p>
<p>然后有的地方(RefreshEventListener)监听配置刷新事件然后用 SpringApplication.run() 通过触发 NacosPropertySourceLocator#locate() 为一个复制出来的 environment 对象添加从服务端获取最新配置, 再拷贝到当前的 environment 对象, 完成 environment 配置的刷新, 之后发布 environment 刷新事件;</p>
<p>有的地方(ConfigurationPropertiesRebinder)监听 environment 刷新事件, 然后为 @ConfigurationProperties 注解生成的 bean 重新绑定配置.</p>
<p>再总结: 挺好的, 奥运火炬手啊这是, 不停传递!!!!!</p>
</blockquote>
<h4 id="关键类-4"><a href="#关键类-4" class="headerlink" title="关键类"></a>关键类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.NacosConfigAutoConfiguration</span><br><span class="line">	注册一个监听容器初始化事件的 bean (NacosContextRefresher)</span><br><span class="line"></span><br><span class="line">2.NacosContextRefresher</span><br><span class="line">	再初始化事件触发后添加一个 AbstractSharedListener 监听者到 cacheData</span><br><span class="line"></span><br><span class="line">3.AbstractSharedListener</span><br><span class="line">	当服务端配置与本地不同后触发</span><br><span class="line">	触发后发布 RefreshEvent 事件</span><br><span class="line"></span><br><span class="line">4.CacheData</span><br><span class="line">	管理配置更新事件监听者</span><br><span class="line">	对比服务端配置与本地配置的 md5</span><br><span class="line">	md5 不同则触发 AbstractSharedListener</span><br><span class="line">	</span><br><span class="line">5.RefreshEvent</span><br><span class="line">	通过容器发布</span><br><span class="line">	当服务端配置发送更新触发</span><br><span class="line">	触发后调用 ContextRefresher<span class="comment">#refresh()</span></span><br><span class="line">	</span><br><span class="line">6.LongPollingRunnable</span><br><span class="line">	轮询任务, 获取服务端最新配置, 与 cacheData 对比</span><br><span class="line"></span><br><span class="line">7.ClientWorker</span><br><span class="line">	管理轮询任务(LongPollingRunnable)</span><br><span class="line">	负责与 nacos 服务端通信</span><br><span class="line">	</span><br><span class="line">8.ContextRefresher</span><br><span class="line">	监听 RefreshEvent 事件</span><br><span class="line">	负责获取服务端最新配置到 environment 对象中</span><br><span class="line">	发布 EnvironmentChangeEvent 事件</span><br><span class="line">	</span><br><span class="line">9.EnvironmentChangeEvent</span><br><span class="line">	通过容器发布</span><br><span class="line">	当 environment 对象更新后触发</span><br><span class="line">	触发后调用 ConfigurationPropertiesRebinder<span class="comment">#rebind()</span></span><br><span class="line">	</span><br><span class="line">10.ConfigurationPropertiesRebinder</span><br><span class="line">	监听 EnvironmentChangeEvent 事件</span><br><span class="line">	负责重新绑定用了 @ConfigurationProperties 注解的 Bean 的值</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A1(NacosConfigAutoConfiguration)</span><br><span class="line">A2(NacosContextRefresher)</span><br><span class="line">A3(ApplicationReadyEvent)</span><br><span class="line">A4(NacosContextRefresher#registerNacosListener)</span><br><span class="line">A5(NacosConfigService#addListener)</span><br><span class="line"> </span><br><span class="line">A7(ClientWorker)</span><br><span class="line">A8(LongPollingRunnable#轮询任务)</span><br><span class="line">A9(NacosConfigService#getServerConfig)</span><br><span class="line">B1(AbstractSharedListener#配置更新事件的监听者)</span><br><span class="line">B2(cacheData)</span><br><span class="line">B3(RefreshEvent)</span><br><span class="line">B4(RefreshEventListener)</span><br><span class="line">B5(ContextRefresher#refresh)</span><br><span class="line">B6(ContextRefresher#refreshEnvironment)</span><br><span class="line">B7(ContextRefresher#addConfigFilesToEnvironment)</span><br><span class="line">B8(SpringApplication#run)</span><br><span class="line">B9(StandardEnvironment)</span><br><span class="line">C1(NacosPropertySourceLocator#locate)</span><br><span class="line">C2(当前容器的 environment 对象)</span><br><span class="line">C3(EnvironmentChangeEvent)</span><br><span class="line">C4(ConfigurationPropertiesRebinder#onApplicationEvent)</span><br><span class="line">C5(ConfigurationPropertiesRebinder#rebind)</span><br><span class="line">C6(用了 ConfigurationProperties 注解 Bean)</span><br><span class="line"></span><br><span class="line">A1--注册了一个--&gt;A2</span><br><span class="line">A2--监听了--&gt;A3</span><br><span class="line">A3--事件触发后调用--&gt;A4</span><br><span class="line">A4--通过--&gt;A5</span><br><span class="line">A5--注册了一个--&gt;B1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">A7--构造方法中创建了一个--&gt;A8</span><br><span class="line">A8--run 方法中调用--&gt;A9</span><br><span class="line">A9--获取最新配置与--&gt;B2</span><br><span class="line"></span><br><span class="line">B2--比较 md5, 不同则触发--&gt;B1</span><br><span class="line">B1--事件触发后发布--&gt;B3</span><br><span class="line">B4--监听了--&gt;B3</span><br><span class="line">B3--事件触发后调用--&gt;B5</span><br><span class="line">B5--调用--&gt;B6</span><br><span class="line">B6--调用--&gt;B7</span><br><span class="line">B7--利用--&gt;B8</span><br><span class="line">B7--复制当前容器 environment 对象到--&gt;B9</span><br><span class="line">B8--触发--&gt;C1</span><br><span class="line">C1--获取了最新配置到--&gt;B9</span><br><span class="line">B9--复制最新配置回到--&gt;C2</span><br><span class="line"></span><br><span class="line">C2--更新完配置后发布--&gt;C3</span><br><span class="line">G1(ConfigurationPropertiesRebinder)--监听了--&gt;C3</span><br><span class="line">C3--事件触发后调用--&gt;C4</span><br><span class="line">C4--调用--&gt;C5</span><br><span class="line">C5--获取新配置绑定到--&gt;C6</span><br></pre></td></tr></table></figure>





<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210130001118.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gudqs7"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">gudqs7</p>
  <div class="site-description" itemprop="description">心累没钱躺尸中</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gudqs7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gudqs7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gudqs7@gmail.com" title="E-Mail → mailto:gudqs7@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gudqs7</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gudqs7s-note.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
