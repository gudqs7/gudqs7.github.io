<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gudqs7.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Spring Boot 源码分析run 流程123456789101112131415161.StopWatch 提供的计算耗时的功能, 创建一个后立即开始计时.2.创建一个引导容器, 并在此时(容器未使用前)把 spring.factories 找到 Bootstrapper 接口的类对应的方法触发, 来给引导容器里注册一些东西(如果有需要)3.从 spring.factories 找 Spri">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Boot 源码笔记">
<meta property="og:url" content="https://gudqs7.github.io/2021/01/24/source-code-spring-boot/index.html">
<meta property="og:site_name" content="gudqs7&#39;s note">
<meta property="og:description" content="Spring Boot 源码分析run 流程123456789101112131415161.StopWatch 提供的计算耗时的功能, 创建一个后立即开始计时.2.创建一个引导容器, 并在此时(容器未使用前)把 spring.factories 找到 Bootstrapper 接口的类对应的方法触发, 来给引导容器里注册一些东西(如果有需要)3.从 spring.factories 找 Spri">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-23T18:04:22.000Z">
<meta property="article:modified_time" content="2021-01-25T15:17:48.069Z">
<meta property="article:author" content="gudqs7">
<meta property="article:tag" content="source-code">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="memo">
<meta property="article:tag" content="spring-boot">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gudqs7.github.io/2021/01/24/source-code-spring-boot/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring Boot 源码笔记 | gudqs7's note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gudqs7's note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">心累没钱躺尸中</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/24/source-code-spring-boot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring Boot 源码笔记
        </h1>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 02:04:22" itemprop="dateCreated datePublished" datetime="2021-01-24T02:04:22+08:00">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-25 23:17:48" itemprop="dateModified" datetime="2021-01-25T23:17:48+08:00">2021-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/24/source-code-spring-boot/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/24/source-code-spring-boot/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Spring-Boot-源码分析"><a href="#Spring-Boot-源码分析" class="headerlink" title="Spring Boot 源码分析"></a>Spring Boot 源码分析</h1><h2 id="run-流程"><a href="#run-流程" class="headerlink" title="run 流程"></a>run 流程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.StopWatch 提供的计算耗时的功能, 创建一个后立即开始计时.</span><br><span class="line">2.创建一个引导容器, 并在此时(容器未使用前)把 spring.factories 找到 Bootstrapper 接口的类对应的方法触发, 来给引导容器里注册一些东西(如果有需要)</span><br><span class="line">3.从 spring.factories 找 SpringApplicationRunListener 的类, 实例化后存到 SpringApplicationRunListeners 中.</span><br><span class="line">4.触发所有存入的 SpringApplicationRunListener 的 starting 事件.</span><br><span class="line">5.将 args 内容中的参数们(类似 --spring.port=9999)解析成键值对存到 applicationArguments 对象中.</span><br><span class="line">6.创建了一个 environment 对象, 添加了好几个功能各异的 PropertySource, 触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件</span><br><span class="line">7.根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里, 根据 this.banner 判断打印什么样的 Banner (佛祖保佑.png)</span><br><span class="line">8.根据 web 类型创建不同的 ApplicationContext, 这里的创建, 仅实例化而已, 没有从构造方法调用 loadBeanDefinitions 和 refresh 的逻辑</span><br><span class="line">9.将 applicationStartup (步骤记录器)赋值给 context.</span><br><span class="line">10.对容器做些配置, 然后发布 contextPrepared 事件, 接着关闭引导容器; 然后使用 BeanDefinitionLoader 扫描解析 getAllSources (如Class) 并将得到的 BeanDefinition 注册到容器, 最后发布 contextLoaded 事件</span><br><span class="line">11.注册一个钩子, 当 JVM 关闭时, 相应的关闭 context, 然后调用容器的 refresh 方法(然后进入到 Spring 源码分析那段, 自行脑补)</span><br><span class="line">12.StopWatch 计时器停止计时, 接着打印计时数据</span><br><span class="line">13.发布 started 事件</span><br><span class="line">14.从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span><br><span class="line">15.catch 到异常则发布 failed 事件</span><br><span class="line">16.发布 running 事件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从整体结构下来, 我们发现, 其主要是创建了一个引导容器(似乎也就是事件监听用到了, 其他地方完全无瓜), 然后扫描得到一些 SpringApplicationRunListener 存起来, 之后在合适的地方发布事件, 然后创建以及配置 environment 对象, 创建以及配置 ApplicationContext 对象, 解析 primarySources 来加载 BeanDefinition 到容器, 然后调用容器的 refresh 方法进入 Spring 的加载流程, 最后处理事件和调用 ApplicationRunner/CommandLineRunner 的 bean. 其中 加载 BeanDefinition 和执行  refresh 方法其实就是与 Spring 一样的逻辑.</p>
</blockquote>
<h3 id="SpringApplication-与-ApplicationContext-的关系与联系"><a href="#SpringApplication-与-ApplicationContext-的关系与联系" class="headerlink" title="SpringApplication 与 ApplicationContext 的关系与联系"></a>SpringApplication 与 ApplicationContext 的关系与联系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.SpringApplication 有独特的 environment 对象, 这是因为 application.xml 配置以及 Spring Cloud Config 这些都需要在容器创建前加载配置文件.</span><br><span class="line">2.ApplicationContext 是 new 的时候就会立刻触发 加载 BeanDefinition 和 refresh(), 而 SpringApplication 则是先 new 一个, 配置好后, 才分别调用方法去 加载 BeanDefinition 和 refresh().</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总得来讲, SpringApplication 相比 ApplicationContext 多出的就是 SpringApplicationRunListener 的事件管理, environment 对象加载与配置, 以及 run 方法的生命周期.</span><br></pre></td></tr></table></figure>



<h3 id="这些-SpringApplicationRunListener-事件都被谁监听了-有什么作用"><a href="#这些-SpringApplicationRunListener-事件都被谁监听了-有什么作用" class="headerlink" title="这些 SpringApplicationRunListener 事件都被谁监听了, 有什么作用?"></a>这些 SpringApplicationRunListener 事件都被谁监听了, 有什么作用?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 spring-boot-project/spring-boot/src/main/resources/META-INF/spring.factories</span></span><br><span class="line"><span class="comment">#   有一个 SpringApplicationRunListener, 其作用是:</span></span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br><span class="line">1.构造方法: 初始化一个事件广播器, 并将 SpringApplication 的 listeners 注册进去. (listeners 是在构造方法中从 spring.factories 加载 ApplicationListener 得到的数据)</span><br><span class="line">2.转发 starting,environmentPrepared,contextPrepared,contextLoaded 事件给 ApplicationListener</span><br><span class="line">3.在 contextLoaded 事件时, 遍历所有的 ApplicationListener 对象, 若其实现了 ApplicationContextAware 接口, 则将 context 注入.</span><br><span class="line">4.started,running,failed 事件均直接用 context.publishEvent 发布事件, 与 listeners 无关 (而且 listeners 这些东西如果仅配置在 spring.factories 而没有被扫描到容器内, 那么就是真的无关了)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结: 配置在 spring.factories 的 ApplicationListener 并不会触发所有 run 生命周期的事件. 因此有时实现 SpringApplicationRunListener 还是很有必要的) 当然, 若你写的 ApplicationListener 即配置在 spring.factories 中也会被扫描到容器内, 则无此忧虑.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着看 ApplicationListener 的作用</span></span><br><span class="line">1.ClearCachesApplicationListener: 在 ContextRefreshedEvent(容器加载完后) 清空缓存</span><br><span class="line">2.ParentContextCloserApplicationListener: 给子容器加一个监听, 使得父容器关闭后, 子容器也跟着关闭(还会递归子容器的容器吧.png)</span><br><span class="line">3.FileEncodingApplicationListener: 对比配置的编码格式, 不符合则报异常(若配置了)</span><br><span class="line">4.DelegatingApplicationListener: 新建一个事件广播器, 将配置文件中 context.listener.classes 的 class 实例化并作为监听者注册到广播器, 然后转发所有事件.</span><br><span class="line">5.EnvironmentPostProcessorApplicationListener</span><br><span class="line">    接受 ApplicationEnvironmentPreparedEvent 事件, 然后把从 spring.factories 获得的 EnvironmentPostProcessor 的 classNames 实例化, 然后遍历执行 postProcessEnvironment(), 其中 ConfigFileApplicationListener 用于加载 application.xxx(yml,xml,properties) 文件的配置到 environment 中的 PropertySource 里. (另外一提, Spring Cloud Config 应该也是这里实现的)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结: 原来配置文件是这么被加载进去的, 没有在主流程中写, 而是监听事件, 再调用 EnvironmentPostProcessor, 层层封装, 扩展性好强(读起来也好蓝).</span></span><br></pre></td></tr></table></figure>



<h3 id="超长源码注释"><a href="#超长源码注释" class="headerlink" title="超长源码注释"></a>超长源码注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们从源码的 spring-boot/spring-boot-tests/spring-boot-smoke-tests/spring-boot-smoke-test-tomcat 下, 找到 SampleTomcatApplication.java 类, 直接看它的 main 方法.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SpringApplication.run(SampleTomcatApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着, 我们点进 run 方法, 瞧瞧里面干了啥</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看起来不多嘛......(看前如是写道, 看完已是凌晨四点)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.StopWatch 提供的计算耗时的功能, 创建一个后立即开始计时.</span></span><br><span class="line">  <span class="comment">// 2.创建一个引导容器, 并在此时(容器未使用前)把 spring.factories 找到 Bootstrapper 接口的类对应的方法触发, 来给引导容器里注册一些东西(如果有需要)</span></span><br><span class="line">  <span class="comment">// 3.从 spring.factories 找 SpringApplicationRunListener 的类, 实例化后存到 SpringApplicationRunListeners 中.</span></span><br><span class="line">  <span class="comment">// 4.触发所有存入的 SpringApplicationRunListener 的 starting 事件.</span></span><br><span class="line">  <span class="comment">// 5.将 args 内容中的参数们(类似 --spring.port=9999)解析成键值对存到 applicationArguments 对象中.</span></span><br><span class="line">  <span class="comment">// 6.创建了一个 environment 对象, 添加了好几个功能各异的 PropertySource, 触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件</span></span><br><span class="line">  <span class="comment">// 7.根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里, 根据 this.banner 判断打印什么样的 Banner (佛祖保佑.png)</span></span><br><span class="line">  <span class="comment">// 8.根据 web 类型创建不同的 ApplicationContext, 这里的创建, 仅实例化而已, 没有从构造方法调用 loadBeanDefinitions 和 refresh 的逻辑</span></span><br><span class="line">  <span class="comment">// 9.将 applicationStartup (步骤记录器)赋值给 context.</span></span><br><span class="line">  <span class="comment">//10.对容器做些配置, 然后发布 contextPrepared 事件, 接着关闭引导容器; 然后根据 primarySource 使用 BeanDefinitionLoader 加载 BeanDefinition 到容器, 最后发布 contextLoaded 事件</span></span><br><span class="line">  <span class="comment">//11.注册一个钩子, 当 JVM 关闭时, 相应的关闭 context, 然后调用容器的 refresh 方法(然后进入到 Spring 源码分析那段, 自行脑补)</span></span><br><span class="line">  <span class="comment">//12.计时器停止计时, 接着打印计时数据</span></span><br><span class="line">  <span class="comment">//13.发布 started 事件</span></span><br><span class="line">  <span class="comment">//14.从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span></span><br><span class="line">  <span class="comment">//15.catch 到异常则发布 failed 事件</span></span><br><span class="line">  <span class="comment">//16.发布 running 事件</span></span><br><span class="line"></span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  stopWatch.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个引导容器, 并在此时(容器未使用前)从 spring.factories 扫描一些实现了 Bootstrapper 接口的类, 来给引导容器里注册一些东西(如果有需要)</span></span><br><span class="line">  DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往系统变量里设置一个变量 headless, 看上去和 AWT 有关, 暂且忽略之</span></span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扫描 spring.factories 中配置的实现了 SpringApplicationRunListener 的类们</span></span><br><span class="line">  <span class="comment">//   实例化后放到 SpringApplicationRunListeners (其就是个容器管理类) 存起来.</span></span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发所有存入的 SpringApplicationRunListener 的 starting 事件.</span></span><br><span class="line">  listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将 args 内容中的参数(类似 --spring.port=9999)解析成键值对存到 applicationArguments 对象中.</span></span><br><span class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个 environment 对象, 添加了好几个功能各异的 PropertySource,</span></span><br><span class="line">    <span class="comment">//   触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件</span></span><br><span class="line">    <span class="comment">//   将 environment 中 spring.main 开头的配置数据, 一一对应绑定到 SpringApplication(即this)的字段上去</span></span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 environment 的 spring.beaninfo.ignore 配置复制到 System.Property 去(若不存在)</span></span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里, 根据 this.banner 判断打印什么样的 Banner (佛祖保佑.png)</span></span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 web 类型创建不同的 ApplicationContext, 但其实差别不大, 就时多了 web 容器的特征(如启动 tomcat)</span></span><br><span class="line">    <span class="comment">// 另外与 Spring 源码分析时不同, 这里的创建, 仅实例化而已, 没有从构造方法调用 loadBeanDefinitions 和 refresh 的逻辑</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 applicationStartup (步骤记录器)赋值给 context.</span></span><br><span class="line">    context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 context 做一些配置, 执行 initializers 的 initialize()</span></span><br><span class="line">    <span class="comment">// 发布 contextPrepared 事件</span></span><br><span class="line">    <span class="comment">// 关闭引导容器, 即发布 BootstrapContextClosedEvent 事件给之前加的 closeListener (监听者)</span></span><br><span class="line">    <span class="comment">// 使用 BeanDefinitionLoader 根据 sources 和 run 方法参数 primarySource 加载 BeanDefinition 到容器中.</span></span><br><span class="line">    <span class="comment">// 发布 contextLoaded 事件</span></span><br><span class="line">    prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个钩子, 当 JVM 关闭时, 相应的关闭 context, 然后调用容器的 refresh 方法(然后进入到 Spring 源码分析那段, 自行脑补)</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类扩展吧</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计时器停止计时, 接着打印计时数据</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 started 事件</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span></span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 发布 failed 事件</span></span><br><span class="line">    handleRunFailure(context, ex, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 发布 running 事件</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 发布 failed 事件</span></span><br><span class="line">    handleRunFailure(context, ex, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>温馨提示: 先在想看的地方打断点, 在打开调试模式, 可以清楚的看到对应的变量变化情况, 以此理解代码!</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来看看所有过程涉及方法的注释(大多数)</span></span><br><span class="line">org.springframework.boot.SpringApplication#createBootstrapContext</span><br><span class="line">    <span class="comment">// 1.创建一个引导容器(这个容器作用和 BeanFactory 类似, 但更简单得多, 仅有获取/注册 bean 对象等的功能)</span></span><br><span class="line">		<span class="comment">//   触发存于 this.bootstrappers 的对象的 intitialize 方法来对引导容器进行初始化(即可以在引导容器未使用前往里面注册 bean 对象)</span></span><br><span class="line">		<span class="comment">//   然后 this.bootstrappers 的数据有一部分是从 spring.factories 找 Bootstrapper 的类实例化后得到的, 然后也可以代码手动添加</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#getRunListeners</span><br><span class="line">    <span class="comment">// 扫描 spring.factories 中配置的实现了 SpringApplicationRunListener 的类, 并调用形如 types 的参数的构造函数来实例化得到对象集合</span></span><br><span class="line">		<span class="comment">//   再将这些对象集合放到 SpringApplicationRunListeners(其就是个容器管理类)中.</span></span><br><span class="line">		<span class="comment">// 并绑定 applicationStartup (步骤记录器)</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplicationRunListeners#doWithListeners(java.lang.String, java.util.function.Consumer&lt;org.springframework.boot.SpringApplicationRunListener&gt;, java.util.function.Consumer&lt;org.springframework.core.metrics.StartupStep&gt;)</span><br><span class="line">    <span class="comment">// 遍历持有的所有 SpringApplicationRunListener, 触发对应事件</span></span><br><span class="line">		<span class="comment">// 在触发监听事件前后加入 StartupStep 监听所耗时间</span></span><br><span class="line">		<span class="comment">// 步骤监听器的 accept 处理</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#prepareEnvironment</span><br><span class="line">    <span class="comment">// 1.根据 web 类型创建一个 environment 对象</span></span><br><span class="line">		<span class="comment">// 2.配置 environment</span></span><br><span class="line">		<span class="comment">//     通过 ConversionService 类添加一些类型转换支持(如文件大小1024k=1M等)</span></span><br><span class="line">		<span class="comment">//     将用户设置的 defaultProperties 添加到 environment 的 sources 中, 将 args 解析成一个 PropertySource 后加入到 environment 中</span></span><br><span class="line">		<span class="comment">// 3.为 environment 添加一个名为 configurationProperties 的源, 其作用是将每一个 PropertySource 适配成 ConfigurationPropertySource.</span></span><br><span class="line">		<span class="comment">// 4.触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件.</span></span><br><span class="line">		<span class="comment">// 5.将名为 defaultProperties 的 Property 源移最后(降低优先级), 另此 defaultProperties 不是 this.defaultProperties</span></span><br><span class="line">		<span class="comment">// 6.将用户通过代码设置的要附加的 profile 设置到 activeProfiles 中去 (若存在且 environment 中不存在)</span></span><br><span class="line">		<span class="comment">// 7.将 environment 中 spring.main 开头的配置数据, 一一对应绑定到 SpringApplication(即this)的字段上去</span></span><br><span class="line">		<span class="comment">// 8.若不开启自定义 environment, 则将 environment 转换成 StandardEnvironment(默认行为)</span></span><br><span class="line">		<span class="comment">// 9.由于上一步可能做了转换, 所以需要重新 attach 一次.</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#getOrCreateEnvironment</span><br><span class="line">    <span class="comment">// 1.若存在一个 environment, 则直接返回</span></span><br><span class="line">		<span class="comment">// 2.若不存在, 则根据之前推断得出的 webApplicationType 来创建对应的 Environment 对象.</span></span><br><span class="line">		<span class="comment">// 3.这几个不同的类型区别也不大, 就 StandardServletEnvironment 多了3个 propertySources(其中一个是 JDNI, 比较重要)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#configureEnvironment</span><br><span class="line">    <span class="comment">// 1.通过 ConversionService 类添加一些类型转换支持(如文件大小1024k=1M等)</span></span><br><span class="line">		<span class="comment">// 2.将用户设置的 defaultProperties 添加到 environment 的 sources 中, 将 args 解析成一个 PropertySource 后加入到 environment 中.</span></span><br><span class="line">		<span class="comment">// 3. configureProfiles 是一个空方法, 看来是留给我们实现子类时扩展的.</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.context.properties.source.ConfigurationPropertySources#attach</span><br><span class="line">    <span class="comment">// 为 environment 添加一个名为 configurationProperties 的源, 其作用是将每一个 PropertySource 适配成 ConfigurationPropertySource.</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#configureAdditionalProfiles</span><br><span class="line">    <span class="comment">// 将用户通过代码设置的要附加的 profile 设置到 activeProfiles 中去 (若存在且 environment 中不存在)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#bindToSpringApplication</span><br><span class="line">    <span class="comment">// 将 environment 中的配置数据, 绑定到 SpringApplication(即this)的一些字段上去</span></span><br><span class="line">		<span class="comment">// 绑定规则是 spring.main 开头的配置数据与 SpringApplication 一一对应, 如若存在 spring.main.banner-mode=OFF, 则 this.bannerMode=OFF</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#printBanner</span><br><span class="line">    <span class="comment">// 根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里</span></span><br><span class="line">		<span class="comment">//   this.banner 为文件路径, 若为空, 则打印 Spring Boot 默认准备的文本(这不换个佛祖保佑?)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#createApplicationContext</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 根据 web 类型创建不同的 ApplicationContext, 但其实差别不大, 就几个细节不同罢了</span></span><br><span class="line">		<span class="comment">// 以 AnnotationConfigServletWebServerApplicationContext 为例, 与 AnnotationConfigApplicationContext 的区别大致为</span></span><br><span class="line">		<span class="comment">//   多加了一个 BeanPostProcessor 用于给 ServletContextAware/ServletConfigAware 接口注入 servletContext/servletConfig 对象</span></span><br><span class="line">		<span class="comment">//   onRefresh() 时, 调用 createWebServer() 启动 tomcat/jetty/undertow</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#prepareContext</span><br><span class="line">    <span class="comment">// 1.设置 environment 对象</span></span><br><span class="line">		<span class="comment">// 2.将 beanNameGenerator 注册到容器中 (若存在), 配置容器的 resourceLoader 和 conversionService (从 SpringApplication 获取)</span></span><br><span class="line">		<span class="comment">// 3.将 initializers 根据 @Order 配置排序后, 遍历执行其 initialize 方法.</span></span><br><span class="line">		<span class="comment">// 4.发布 contextPrepared 事件</span></span><br><span class="line">		<span class="comment">// 5.关闭销毁引导容器(毕竟真正的容器已经准备好了, 这玩意就没用了)</span></span><br><span class="line">		<span class="comment">// 6.为容器添加一些特殊的 bean, 对 beanFactory 做点小设置; 然后添加一个懒加载功能的 BeanFactoryPostProcessor, 作用是将所有的 BeanDefinition 的 lazyInit 设置为 true</span></span><br><span class="line">		<span class="comment">// 7.创建一个 BeanDefinitionLoader, 解析 sources 得到 BeanDefinition 再注册到容器中. 和 Spring 的 new 容器时的 load 过程类似.</span></span><br><span class="line">		<span class="comment">// 8.发布 contextLoaded 事件</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#postProcessApplicationContext</span><br><span class="line">    <span class="comment">// 1.将 beanNameGenerator 注册到容器中 (若存在)</span></span><br><span class="line">		<span class="comment">// 2.将 SpringApplication 的 resourceLoader 赋值给容器 (若存在)</span></span><br><span class="line">		<span class="comment">// 3.为容器设置 ConversionService(类型转换工具)对象 (若配置了允许)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#load</span><br><span class="line">    <span class="comment">// 创建一个 BeanDefinitionLoader, 解析 sources 得到 BeanDefinition 再注册到容器中. 和 Spring 的 new 容器时的 load 过程类似.</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplication#refreshContext</span><br><span class="line">    <span class="comment">// 1.注册一个钩子, 当 JVM 关闭时, 相应的关闭 context</span></span><br><span class="line">		<span class="comment">// 2.调用容器的 refresh 方法</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#callRunners</span><br><span class="line">    <span class="comment">// 从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span></span><br><span class="line">		<span class="comment">// 这里有两个不同点</span></span><br><span class="line">		<span class="comment">//    1. XxxRunner 和 ApplicationListener 有何不同?</span></span><br><span class="line">		<span class="comment">//       答案是 XxxRunner 的 run 方法可以直接取到程序启动的 args 参数, 而监听器要取则还需借助 environment</span></span><br><span class="line">		<span class="comment">//    2.ApplicationRunner 和 CommandLineRunner 有何不同?</span></span><br><span class="line">		<span class="comment">//       答案是 run 方法接受的参数形式不同, 一个是 字符串数组(原始的), 一个是解析好的 key:value 方便直接取用.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>规矩我懂得, GitHub在这 <a href="https://github.com/gudqs7/spring-boot/tree/wq-comment" target="_blank" rel="noopener">注意分支哦</a> </p>
</blockquote>
<h2 id="各种实现的原理"><a href="#各种实现的原理" class="headerlink" title="各种实现的原理"></a>各种实现的原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.application.properties 是如何被加载到 Environment 中的?</span><br><span class="line">2.@ConfigurationProperties 如何实现自动注入`application.properties/application.yml`中配置的值?</span><br><span class="line">3.一些只需要改改依赖jar就可以切换(如tomcat-&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)</span><br><span class="line">4.JdbcTemplateAutoConfiguration如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)</span><br><span class="line">5.为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)</span><br></pre></td></tr></table></figure>



<h3 id="application-properties-是如何被加载到-Environment-中的"><a href="#application-properties-是如何被加载到-Environment-中的" class="headerlink" title="application.properties 是如何被加载到 Environment 中的?"></a>application.properties 是如何被加载到 Environment 中的?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1) run方法中创建了 Environment 对象, 当初始化好一些东西后会触发 environmentPrepared 事件</span><br><span class="line">2) 通过 SpringApplicationRunListener 的 EventPublishingRunListener 转发事件给 ApplicationListener 这类监听者, 即 EnvironmentPostProcessorApplicationListener.</span><br><span class="line">3) 这个类接收事件后, 遍历从 spring.factories 获得的 EnvironmentPostProcessor 对象, 执行其 postProcessEnvironment()</span><br><span class="line">4) 其中 ConfigFileApplicationListener<span class="comment">#postProcessEnvironment() 实现了配置文件的加载</span></span><br><span class="line">5) 具体为 postProcessEnvironment 下的 addPropertySources()</span><br><span class="line">6) 此方法将会扫描指定的路径下指定的某些文件</span><br><span class="line">7) 然后使用 spring.factories 下的 PropertySourceLoader 一一尝试解析</span><br><span class="line">8) 文件存在且解析正确则加入到 environment 的 sources 集合中.</span><br><span class="line">	某些路径: getSearchLocations() ,默认: classpath:/,classpath:/config/ ...</span><br><span class="line">	某些文件: getSearchNames() ,默认: application</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS: </span></span><br><span class="line">PropertySourceLoader 有 PropertiesPropertySourceLoader/YamlPropertySourceLoader</span><br><span class="line">一个尝试后缀有 xml/properties, 另一个是 yml/yaml, 因为是遍历后 load, 所以所有可能性有:</span><br><span class="line">    classpath:/application.xml; classpath:/application.properties</span><br><span class="line">	classpath:/application.yml; classpath:/application.yaml</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>



<h3 id="ConfigurationProperties-如何实现自动注入application-properties-application-yml中配置的值"><a href="#ConfigurationProperties-如何实现自动注入application-properties-application-yml中配置的值" class="headerlink" title="@ConfigurationProperties 如何实现自动注入application.properties/application.yml中配置的值?"></a>@ConfigurationProperties 如何实现自动注入<code>application.properties/application.yml</code>中配置的值?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) 首先加了 @EnableConfigurationProperties 也会解析里面的 @Import </span><br><span class="line">2) @Import 则引入了 EnableConfigurationPropertiesRegistrar.class</span><br><span class="line">3) 这是一个 ImportBeanDefinitionRegistrar 的实现类, 因此调用指定方法 registerBeanDefinitions</span><br><span class="line">4) 指定方法 registerBeanDefinitions() 会将 @EnableConfigurationProperties 注解的值对应的类注册到容器中, 如 @EnableConfigurationProperties(RabbitProperties.class) 则会加载 RabbitProperties.class</span><br><span class="line">5) 指定方法还注册了一些工具 bean 和一个重要的 BeanPostProcessor 在 registerInfrastructureBeans()中</span><br><span class="line">6) 即 ConfigurationPropertiesBindingPostProcessor, 当我们要使用配置文件 bean(如 RabbitProperties)时,会实例化 bean 并触发 postProcessorBeforeInitialization()</span><br><span class="line">7) 在 postProcessorBeforeInitialization() 中, 通过 org.springframework.boot.context.properties.ConfigurationPropertiesBinder<span class="comment">#bind() 来完成实际的绑定</span></span><br><span class="line">8) 其本质就是 Binder 的 <span class="built_in">bind</span> 方法, 设定配置文件前缀即可将配置文件中的配置对应的绑定到 bean(如 rabbitProperties 对象) 中.</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS</span></span><br><span class="line">这里的 Binder 和 SpringApplication 里绑定 spring.main 开头配置文件那个类是同一个.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">就是先将 XxxProperties 类注册到容器中, 这样就可以通过 BeanPostProcessor 再实例化后将配置文件与属性绑定.</span><br></pre></td></tr></table></figure>



<h3 id="一些只需要改改依赖jar就可以切换-如tomcat–-gt-undertow-是怎么做到的-ConditionalXxx-的实现原理"><a href="#一些只需要改改依赖jar就可以切换-如tomcat–-gt-undertow-是怎么做到的-ConditionalXxx-的实现原理" class="headerlink" title="一些只需要改改依赖jar就可以切换(如tomcat–&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)"></a>一些只需要改改依赖jar就可以切换(如tomcat–&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1) 在类上加上注解 @Conditional 或带有 @Conditional 的其他注解(即注解的子类亦会扫描)</span><br><span class="line">2) 在所有的扫描类和注解的地方,如解析@Configuration, AnotatedBeanDefinitionReader 等 reader</span><br><span class="line">    会使用 ConditionEvaluator 的 shouldSkip() 判断是否可以加载, 时机点如下</span><br><span class="line">    AnnotatedBeanDefinitionReader<span class="comment">#doRegisterBean() 的第二行代码</span></span><br><span class="line">    ConfigurationClassBeanDefinitionReader<span class="comment">#loadBeanDefinitionsForBeanMethod() 第四行</span></span><br><span class="line">    ConfigurationClassBeanDefinitionReader<span class="comment">#loadBeanDefinitionsForConfigurationClass()</span></span><br><span class="line">    ConfigurationClassParser<span class="comment">#doProcessConfigurationClass() 处理 ComponentScan 那段</span></span><br><span class="line">3) 然后再 shouldSkip 中判断， 判断逻辑大致如下：</span><br><span class="line">    先遍历所有注解取得所有的 @Conditional 的 value, 这个 value 是具体的 Condition 实现, 如 OnClassCondition(实现了 Condition 的 matches 接口, 很多抽象类用以增强代码扩展性), 然后其加入到 conditions 中, 排序后遍历调用 matches(), 一个不匹配则返回 <span class="literal">true</span>, 代表应该跳过.</span><br><span class="line"></span><br><span class="line"><span class="comment"># TIPS:</span></span><br><span class="line">ConditionOutcome 封装了是否匹配和匹配日志信息[为啥成功/为啥失败]</span><br><span class="line">SpringBootCondition 提供了通用的根据 ConditionOutcome 判断是否匹配并记录日志信息的抽象类.</span><br><span class="line">    子类只需实现 getMatchOutcome(): 根据 metadata[注解信息] 返回 ConditionOutcome 对象.</span><br><span class="line">    因此, 如果我们要实现自己的 Condition, 可以继承它.</span><br></pre></td></tr></table></figure>



<h3 id="JdbcTemplateAutoConfiguration-如何确保能够获取到-DataSource-AutoConfigureAfter-的实现原理"><a href="#JdbcTemplateAutoConfiguration-如何确保能够获取到-DataSource-AutoConfigureAfter-的实现原理" class="headerlink" title="JdbcTemplateAutoConfiguration 如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)"></a>JdbcTemplateAutoConfiguration 如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1) 首先所有的 XxxAutoConfiguration 都是借助 AutoConfigurationImportSelector 加载的, 其继承了 DeferredImportSelector.  </span><br><span class="line">2) 这种 DeferredImportSelector 会延迟加载, 原理是 parse 后再加载, 而非 parse 执行过程中就加载.</span><br><span class="line">3) 延迟加载机制 会先调用 process 方法, 将要加载的 class 保存起来, 然后再调用 selectImports 返回.</span><br><span class="line">4) 此时 AutoConfigurationImportSelector.AutoConfigurationGroup 的 selectImports() 会调用 sortAutoConfigurations(), 也就是调用了 AutoConfigurationSorter.getInPriorityOrder()</span><br><span class="line">5) getInPriorityOrder() 调用了 sortByAnnotation() 这个方法根据2个注解 @AutoConfigureBefore/@AutoConfigureAfter 排序.</span><br><span class="line">6) 最后返回的就是有序的了. 另外, 这两个注解只能作用在 spring.factories 中 EnableAutoConfiguration 的类上才有效.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结:</span></span><br><span class="line">利用 DeferredImportSelector 的延迟加载, 将所有的 AutoConfiguration 所引入的 class 先存起来不加载, 然后又加入排序的逻辑, 使得真正加载时会根据排序结果依次加载.</span><br></pre></td></tr></table></figure>



<h3 id="为什么-Spring-Boot-启动-main-方法就能访问-Tomcat-SpringApplication-run-启动-tomcat-实现原理"><a href="#为什么-Spring-Boot-启动-main-方法就能访问-Tomcat-SpringApplication-run-启动-tomcat-实现原理" class="headerlink" title="为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)"></a>为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) main 方法会调用 SpringApplication 的 run 方法, 里面会创建 applicationContext, 如是 webApplicationType = SERVLET, 则实现类为 AnnotationConfigServletWebServerApplicationContext</span><br><span class="line">    另外一提, webApplicationType 是根据 classpath 下是否有哪些类来推断的.</span><br><span class="line">2) 这个类继承了 ServletWebServerApplicationContext</span><br><span class="line">3) ServletWebServerApplicationContext 实现了 onRefresh()</span><br><span class="line">4) onRefresh() 调用了 createWebServer()</span><br><span class="line">5) createWebServer() 使用 ServletWebServerFactory.getWebServer() 获取 webServer 对象</span><br><span class="line">6) ServletWebServerFactory 的具体实现类由 ServletWebServerFactoryAutoConfiguration 引入</span><br><span class="line">    详细见 ServletWebServerFactoryConfiguration.EmbeddedTomcat.class</span><br><span class="line">7) 引入后调用 getWebServer(), 大概为 new Tomcat(), 绑定配置文件到 Tomcat 的一些属性上, 然后启动它.</span><br><span class="line">8) 至此, run() 启动了 tomcat/jetty/undertow.</span><br><span class="line"> </span><br><span class="line"><span class="comment"># TIPS:</span></span><br><span class="line">Spring 使用工厂模式获取不同的 webServer, 而不同的 webServer 实现类其实是用 XxxAutoConfiguration 来自动注入的(还可以配合 @Conditional 决定何时加载).</span><br><span class="line">这样如果新增一种 webServer, 只需要在写一个 XxxAutoConfiguration 注册一个 webServer 实现类的 bean 即可, 非常灵活(非常 nice).</span><br></pre></td></tr></table></figure>





<h2 id="常见的-XxxAutoConfiguration"><a href="#常见的-XxxAutoConfiguration" class="headerlink" title="常见的 XxxAutoConfiguration"></a>常见的 XxxAutoConfiguration</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.连接池</span><br><span class="line">   DataSourceAutoConfiguration 会 Import DataSourceConfiguration.Hikari.class</span><br><span class="line">2.Mybatis</span><br><span class="line">   MybatisAutoConfiguration: 注册并配置了 SqlSessionFactory/SqlSessionTemplate</span><br><span class="line">3.Spring MVC</span><br><span class="line">   DispatcherServletAutoConfiguration: 配置前端控制器和文件上传处理器</span><br><span class="line">   ServletWebServerFactoryAutoConfiguration: 注册 WebServerFactory 的实现类 bean</span><br><span class="line">4.RocketMQ</span><br><span class="line">   RabbitAutoConfiguration: 注册并配置 RabbitTemplate</span><br><span class="line">5.Redis</span><br><span class="line">   RedisAutoConfiguration: 注册并配置 RedisTemplate/StringRedisTemplate</span><br><span class="line">6.邮件发送</span><br><span class="line">   MailSenderAutoConfiguration: 注册并配置 JavaMailSenderImpl</span><br><span class="line">7.MyBatis-Plus</span><br><span class="line">   MybatisPlusAutoConfiguration: 注册 SqlSessionFactory, 并配置了其 plugins, 使 Mybatis-Plus 生效</span><br><span class="line">8.定时任务</span><br><span class="line">   TaskSchedulingAutoConfiguration: 注册 ThreadPoolTaskScheduler</span><br><span class="line">9.AOP</span><br><span class="line">   AopAutoConfiguration: 通过静态内部类加载了 @EnableAspectJAutoProxy</span><br></pre></td></tr></table></figure>



<h2 id="我所见到的设计模式"><a href="#我所见到的设计模式" class="headerlink" title="我所见到的设计模式"></a>我所见到的设计模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.适配器模式: SpringConfigurationPropertySources</span><br><span class="line">    要将 Iterable&lt;PropertySource&lt;?&gt;&gt;</span><br><span class="line">    适配成 Iterable&lt;ConfigurationPropertySource&gt;</span><br><span class="line">    也即是 PropertySource --&gt; ConfigurationPropertySource</span><br><span class="line">  <span class="comment">#其实主要工作是: ConfigurationPropertySource#getConfigurationProperty() 里面调用了 PropertySource#getProperty(), 以此完成适配... 很适配器模式, 存一个未适配的对象, 在适配的方法中调用存储的对象的要适配的方法. </span></span><br><span class="line">  </span><br><span class="line">2.简单工厂模式: org.springframework.boot.ApplicationContextFactory<span class="comment">#create</span></span><br><span class="line">    根据 webApplicationType 创建不同的 ConfigurableApplicationContext</span><br><span class="line">  </span><br><span class="line">3.观察者模式: </span><br><span class="line">	监听者: SpringApplicationRunListener</span><br><span class="line">  观察对象: SpringApplication 的生命周期(starting/environmentPrepared/contextPrepared/contextLoaded/started/running/failed)</span><br><span class="line">  管理者: SpringApplicationRunListeners, 负责遍历监听者广播对应事件</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        <div class="reward-container">
  <div>下次一定</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="gudqs7 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/bitcoin.png" alt="gudqs7 比特币">
        <p>比特币</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/source-code/" rel="tag"># source-code</a>
              <a href="/tags/spring/" rel="tag"># spring</a>
              <a href="/tags/memo/" rel="tag"># memo</a>
              <a href="/tags/spring-boot/" rel="tag"># spring-boot</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/23/source-code-spring/" rel="prev" title="Spring 源码笔记">
      <i class="fa fa-chevron-left"></i> Spring 源码笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/25/source-code-spring-mvc/" rel="next" title="Spring MVC 源码笔记">
      Spring MVC 源码笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot-源码分析"><span class="nav-number">1.</span> <span class="nav-text">Spring Boot 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#run-流程"><span class="nav-number">1.1.</span> <span class="nav-text">run 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringApplication-与-ApplicationContext-的关系与联系"><span class="nav-number">1.1.1.</span> <span class="nav-text">SpringApplication 与 ApplicationContext 的关系与联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#这些-SpringApplicationRunListener-事件都被谁监听了-有什么作用"><span class="nav-number">1.1.2.</span> <span class="nav-text">这些 SpringApplicationRunListener 事件都被谁监听了, 有什么作用?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超长源码注释"><span class="nav-number">1.1.3.</span> <span class="nav-text">超长源码注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各种实现的原理"><span class="nav-number">1.2.</span> <span class="nav-text">各种实现的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#application-properties-是如何被加载到-Environment-中的"><span class="nav-number">1.2.1.</span> <span class="nav-text">application.properties 是如何被加载到 Environment 中的?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigurationProperties-如何实现自动注入application-properties-application-yml中配置的值"><span class="nav-number">1.2.2.</span> <span class="nav-text">@ConfigurationProperties 如何实现自动注入application.properties&#x2F;application.yml中配置的值?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些只需要改改依赖jar就可以切换-如tomcat–-gt-undertow-是怎么做到的-ConditionalXxx-的实现原理"><span class="nav-number">1.2.3.</span> <span class="nav-text">一些只需要改改依赖jar就可以切换(如tomcat–&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JdbcTemplateAutoConfiguration-如何确保能够获取到-DataSource-AutoConfigureAfter-的实现原理"><span class="nav-number">1.2.4.</span> <span class="nav-text">JdbcTemplateAutoConfiguration 如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么-Spring-Boot-启动-main-方法就能访问-Tomcat-SpringApplication-run-启动-tomcat-实现原理"><span class="nav-number">1.2.5.</span> <span class="nav-text">为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的-XxxAutoConfiguration"><span class="nav-number">1.3.</span> <span class="nav-text">常见的 XxxAutoConfiguration</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#我所见到的设计模式"><span class="nav-number">1.4.</span> <span class="nav-text">我所见到的设计模式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gudqs7"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">gudqs7</p>
  <div class="site-description" itemprop="description">心累没钱躺尸中</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gudqs7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gudqs7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gudqs7@gmail.com" title="E-Mail → mailto:gudqs7@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gudqs7</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gudqs7s-note.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://gudqs7.github.io/2021/01/24/source-code-spring-boot/";
    this.page.identifier = "2021/01/24/source-code-spring-boot/";
    this.page.title = "Spring Boot 源码笔记";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://gudqs7s-note.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
