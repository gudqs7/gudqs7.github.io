<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gudqs7.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Spring源码分析关键类介绍ApplicationContext123456789101112131415161718192021222324万能的 applicationContext, 但实际上各种能力都是依赖于其他的类, 比如 getBean 是 beanFactory 的, publishEvent 是事件广播器的, 等等. 其本身是一个综合体, 整合这些能力, 便于开发者调用和理解.#">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码笔记">
<meta property="og:url" content="https://gudqs7.github.io/2021/01/23/source-code-spring/index.html">
<meta property="og:site_name" content="gudqs7&#39;s note">
<meta property="og:description" content="Spring源码分析关键类介绍ApplicationContext123456789101112131415161718192021222324万能的 applicationContext, 但实际上各种能力都是依赖于其他的类, 比如 getBean 是 beanFactory 的, publishEvent 是事件广播器的, 等等. 其本身是一个综合体, 整合这些能力, 便于开发者调用和理解.#">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-23T10:28:28.000Z">
<meta property="article:modified_time" content="2021-01-23T17:51:01.543Z">
<meta property="article:author" content="gudqs7">
<meta property="article:tag" content="source-code">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="memo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gudqs7.github.io/2021/01/23/source-code-spring/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring源码笔记 | gudqs7's note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gudqs7's note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">心累没钱躺尸中</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/23/source-code-spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring源码笔记
        </h1>

        <div class="post-meta">
			
				<i class="fa fa-thumb-tack"></i>
				<font color="RED">置顶</font>
				<span class="post-meta-divider">|</span>
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-23 18:28:28" itemprop="dateCreated datePublished" datetime="2021-01-23T18:28:28+08:00">2021-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-24 01:51:01" itemprop="dateModified" datetime="2021-01-24T01:51:01+08:00">2021-01-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCode/" itemprop="url" rel="index"><span itemprop="name">SourceCode</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/23/source-code-spring/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/23/source-code-spring/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Spring源码分析"><a href="#Spring源码分析" class="headerlink" title="Spring源码分析"></a>Spring源码分析</h1><h2 id="关键类介绍"><a href="#关键类介绍" class="headerlink" title="关键类介绍"></a>关键类介绍</h2><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">万能的 applicationContext, 但实际上各种能力都是依赖于其他的类, 比如 getBean 是 beanFactory 的, publishEvent 是事件广播器的, 等等. 其本身是一个综合体, 整合这些能力, 便于开发者调用和理解.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面列一下相关的接口, 抽象类, 和具体类</span></span><br><span class="line">ApplicationContext</span><br><span class="line">	是一个只读的 bean 容器</span><br><span class="line">	可以加载解析配置文件(如xml)</span><br><span class="line">	可以发布事件和注册监听</span><br><span class="line">	具有国际化消息处理能力</span><br><span class="line">ConfigurableApplicationContext</span><br><span class="line">	是一个具有可配置能力的 容器(可设置各个参数, 如id, 父容器)</span><br><span class="line">	具有容器生命周期概念, 如启动,停止,关闭.</span><br><span class="line">AbstractApplicationContext</span><br><span class="line">	模板方法模式的抽象类, 定义了容器的模板(refresh方法), 但由具体的子类实现部分方法</span><br><span class="line">	管理Bean和BeanFactory的PostProcessor</span><br><span class="line">	管理事件的监听和处理</span><br><span class="line">AbstractRefreshableApplicationContext</span><br><span class="line">	为可重复刷新的容器提供基类</span><br><span class="line">	加入了BeanFactory的管理(创建/关闭等)</span><br><span class="line">AbstractRefreshableConfigApplicationContext</span><br><span class="line">	加入了configLocation字段, 用于某些容器初始化BeanFactory和Bean</span><br><span class="line">AbstractXmlApplicationContext</span><br><span class="line">	定义了读取xml配置文件来加载BeanFactory的代码, 使得子类只需提供配置文件地址或Resource</span><br><span class="line">ClassPathXmlApplicationContext</span><br><span class="line">	继承基类, 提供配置文件地址的构造方法, 调用refresh加载BeanFactory</span><br></pre></td></tr></table></figure>

<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">1.核心中的核心, 加载和管理 beanDefinitions(Bean配置信息), 创建和管理 bean 对象实例, 注册和管理 BeanPostProcessor(Bean扩展)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面列一下相关的接口, 抽象类, 和具体类</span></span><br><span class="line">BeanFactory</span><br><span class="line">  定义了 Bean 的基础操作接口, 如 getBean, getType, isSingleton 等</span><br><span class="line"></span><br><span class="line">SingletonBeanRegistry</span><br><span class="line">  定义了单例对象的操作接口 (注册/获取/是否已存在) </span><br><span class="line"></span><br><span class="line">HierarchicalBeanFactory</span><br><span class="line">  定义了父 BeanFactory 的相关操作接口(获取)</span><br><span class="line"></span><br><span class="line">ConfigurableBeanFactory</span><br><span class="line">  定义了对 BeanFactory 做各种配置的操作接口, 包括 BeanPostProcessor, setParentBeanFactory, destroyBean, registerAlias, resolveAliases 等</span><br><span class="line"></span><br><span class="line">DefaultSingletonBeanRegistry</span><br><span class="line">  实现了 SingletonBeanRegistry 接口, 即实现了单例对象的缓存管理, 包括一级/二级/三级(二级三级只依赖循环用上的两个缓存)</span><br><span class="line">  </span><br><span class="line">FactoryBeanRegistrySupport</span><br><span class="line">  继承了 DefaultSingletonBeanRegistry</span><br><span class="line">	实现对使用 FactoryBean 存储和获取 bean 对象实例方式的支持</span><br><span class="line">	</span><br><span class="line">AbstractBeanFactory</span><br><span class="line">  继承了 FactoryBeanRegistrySupport</span><br><span class="line">  实现了 BeanFactory/HierarchicalBeanFactory/ConfigurableBeanFactory 定义的接口</span><br><span class="line">  实现了具体 getBean, 包括缓存管理等</span><br><span class="line">  </span><br><span class="line">AutowireCapableBeanFactory</span><br><span class="line">  定义了根据 class 类型获取 BeanDefinition 信息以及 Bean 对象的接口</span><br><span class="line"></span><br><span class="line">AbstractAutowireCapableBeanFactory</span><br><span class="line">  继承自 AbstractBeanFactory </span><br><span class="line">  实现了 AutowireCapableBeanFactory 中定义的方法(就是实现了根据 class 获取 bean 或 BeanDefinition)</span><br><span class="line">  实现了 createBean, 也就是真正的实例化一个对象的过程, 包括实例化, 为需要赋值的字段注入相应的值</span><br><span class="line">  同时触发了 BeanPostProcessor 的方法调用</span><br><span class="line">  </span><br><span class="line">BeanDefinitionRegistry</span><br><span class="line">  定义了 BeanDefinition 的注册/获取/移除</span><br><span class="line">  </span><br><span class="line">ListableBeanFactory</span><br><span class="line">	定义了 BeanDefinition 的可遍历性</span><br><span class="line">  </span><br><span class="line">ConfigurableListableBeanFactory</span><br><span class="line">  结合 ListableBeanFactory 和 ConfigurableBeanFactory 并补充完善了几个相关接口 (如 getBeanNamesIterator 接口 )</span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory</span><br><span class="line">  继承了 AbstractAutowireCapableBeanFactory</span><br><span class="line">  实现了 BeanDefinitionRegistry/ConfigurableListableBeanFactory 的接口</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 总结:</span></span><br><span class="line">定义处:</span><br><span class="line">BeanFactory(getBean)</span><br><span class="line">SingletonBeanRegistry(addSingleton)</span><br><span class="line">HierarchicalBeanFactory(getParentBeanFactory)</span><br><span class="line">ConfigurableBeanFactory(addBeanPostProcessor)</span><br><span class="line">AutowireCapableBeanFactory(autowireBean)</span><br><span class="line">BeanDefinitionRegistry(registerBeanDefinition)</span><br><span class="line">ListableBeanFactory(getBeanDefinitionNames)</span><br><span class="line">ConfigurableListableBeanFactory(getBeanNamesIterator)</span><br><span class="line"></span><br><span class="line">实现处:</span><br><span class="line">DefaultSingletonBeanRegistry(registerSingleton)</span><br><span class="line">FactoryBeanRegistrySupport(getObjectFromFactoryBean)</span><br><span class="line">AbstractBeanFactory(doGetBean)</span><br><span class="line">AbstractAutowireCapableBeanFactory(createBean)</span><br><span class="line">DefaultListableBeanFactory(registerBeanDefinition)</span><br></pre></td></tr></table></figure>





<h2 id="容器初始化过程"><a href="#容器初始化过程" class="headerlink" title="容器初始化过程"></a>容器初始化过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.setParent(): 处理父容器 </span><br><span class="line">2.setConfigLocations(): 解析并设置xml配置文件路径</span><br><span class="line">3.refresh(): 创建 beanFactory 对象并初始化, 读取 xml 配置文件得到 beanDefinitions, 接着处理两种 PostProcessor, 然后添加国际化处理器和事件广播器以及相应的初始化和一些处理, 最后实例化单例的 bean 等等.</span><br><span class="line"></span><br><span class="line"><span class="comment">#外圈结束, 再看 refresh() 里面的每个方法</span></span><br><span class="line">1.prepareRefresh(): 准备工作, 一些字段值的设置和处理.</span><br><span class="line">2.obtainFreshBeanFactory(): 创建一个 beanFactory 对象并注册到 applicationContext (即赋值到字段上), 然后解析 xml 配置文件(或注解配置)的信息, 解析得到 beanDefinitions 并注册到容器中.</span><br><span class="line">3.然后是一些对 beanFactory 对象的完善配置的代码</span><br><span class="line">4.扫描并执行 BeanFactoryPostProcessor(其作用是为beanFactory对象添加东西提供扩展性), 其中我认识的就只有 ConfigurationClassPostProcessor(这个类作用就是解析 @Configuration/@Component/@Import/@ImportSource/@ComponentScan等基础注解).</span><br><span class="line">5.扫描实现了 BeanPostProcessor 接口的 bean 并注册到 beanFactory 中存起来, 等 createBean 创建对象时会在对应的时机执行一些对应的方法(钩子). 常见的各种 XxxAware 就是靠这个实现的咯.</span><br><span class="line">6.接着, 初始化国际化资源处理器, 事件广播器, 并注册一些需要注册的事件(也注册容器内实现对应接口的 bean)</span><br><span class="line">7.处理一些 beanFactory 的配置, 接着为所有单例且非懒加载的(不就是默认策略嘛) bean 创建实例, 缓存起来.</span><br><span class="line">8.广播容器加载完成了的事件. 以及处理生命周期.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后总结下, 先创建容器, 再将根据配置文件解析得到 BeanDefinition 注册到容器中, 然后处理两大扩展(BeanFactoryPostProcessor/BeanPostProcessor), 接着是Spring的国际化, 以及相当有用的事件广播器, 最后实例化 bean. 整体感觉其实很简单, 但其实有大量的工作交给了 BeanPostProcessor.</p>
</blockquote>
<h3 id="超长源码分析过程"><a href="#超长源码分析过程" class="headerlink" title="超长源码分析过程"></a>超长源码分析过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先随便写个 main 方法, 如我写的, 可测试依赖循环问题和事件监听:</span></span><br><span class="line"><span class="comment">// 包名: cn.gudqs7.spring.tests, 改动则需同步修改xml哦</span></span><br><span class="line"><span class="comment">// 进入对应类代码: 快捷键 Cmd+Option+鼠标点击 (或 Ctrl+Alt+鼠标左键 ); 如果是接口松开 Option(或Alt)键</span></span><br><span class="line"></span><br><span class="line">Test.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ApplicationContext xmlContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application-wq.xml"</span>);</span><br><span class="line">		UserServiceImpl userService = xmlContext.getBean(UserServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		userService.sayHi();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">application-wq.xml</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> <span class="keyword">default</span>-autowire=<span class="string">"byName"</span>&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean name=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.gudqs7.spring.tests.UserServiceImpl"</span>&gt;</span><br><span class="line">		&lt;property name="starter"&gt;&lt;ref bean="serverStarter"/&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;bean name=<span class="string">"serverStarter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.gudqs7.spring.tests.ServerStarter"</span>&gt;</span><br><span class="line">		&lt;property name="userService"&gt;&lt;ref bean="userService"/&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">UserServiceImpl.java</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> ServerStarter starter;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(starter);</span><br><span class="line">		System.out.println(<span class="string">"Hello Spring!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStarter</span><span class="params">(ServerStarter starter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.starter = starter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ServerStarter.java</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStarter</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Inject</span></span><br><span class="line">	<span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">		String applicationName = event.getApplicationContext().getApplicationName();</span><br><span class="line">		System.out.println(applicationName);</span><br><span class="line">		System.out.println(userService);</span><br><span class="line">		System.out.println(<span class="string">"========== started by gudqs7 =============="</span>);</span><br><span class="line">		System.out.println(<span class="string">"========== started by gudqs7 =============="</span>);</span><br><span class="line">		System.out.println(<span class="string">"========== started by gudqs7 =============="</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserServiceImpl userService)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userService = userService;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接下来, 进入ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String) 方法中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其跳转到了</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为容器的 parent 字段赋值, 若 parent 不为空, 且有 ConfigurableEnvironment, 则合并数据(将父容器有的加到子容器中)</span></span><br><span class="line">		<span class="comment">// 即执行了 org.springframework.context.support.AbstractApplicationContext.setParent()</span></span><br><span class="line">		<span class="keyword">super</span>(parent);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为 configLocations 字段赋值(告知配置文件位置), 赋值前会根据环境变量解析(此时环境变量中只有系统环境变量: 如JAVA_HOME).</span></span><br><span class="line">		setConfigLocations(configLocations);</span><br><span class="line">		<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">			<span class="comment">// 注释在下面</span></span><br><span class="line">      refresh();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 然后具体的看 refresh 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="comment">// 1.设置容器初始的一些属性(时间,状态)，初始化占位符数据源并校验所有 bean 所使用的占位符是否存在, 清空事件和监听</span></span><br><span class="line">		<span class="comment">// 2.清空重置旧的 beanFactory, 再创建新的 beanFactory 并通过解析 xml或注解 加载 beanDefinitions</span></span><br><span class="line">		<span class="comment">// 3.设置了一些 beanFactory 的属性, 添加了几个有用的 BeanPostProcessor, 还添加了几个 bean 到容器中(都是环境相关的 bean)</span></span><br><span class="line">		<span class="comment">// 4.子类对beanFactory 添加自己的特殊的 BeanPostProcessor (如servletContxt/servletConfig注入)</span></span><br><span class="line">		<span class="comment">// 5.扫描容器中实现了 BeanFactoryPostProcessor 接口的 bean 将其注册到 beanFactory 中并执行</span></span><br><span class="line">		<span class="comment">// 6.扫描容器中实现了 BeanPostProcessor 接口的 bean 将其注册到 beanFactory 但不执行(实例化 bean 对象那会有几个执行时机)</span></span><br><span class="line">		<span class="comment">// 7.创建一个国际化资源解析器并注册到 beanFactory; 创建一个事件广播器并注册到 beanFactory.</span></span><br><span class="line">		<span class="comment">// 8.调用子类的其他刷新时需要做的事情(模板方法)</span></span><br><span class="line">		<span class="comment">// 9.扫描容器中实现了 ApplicationListener 接口的 bean, 将其预存到广播器中但不执行</span></span><br><span class="line">		<span class="comment">//10.完成 beanFactory 的一些配置(包括终结一些东西, 如 setTempClassLoader(null) ); 将单例的 bean 创建出来放入容器中(未设置lazy-init=true)的 bean</span></span><br><span class="line">		<span class="comment">//11.广播 ContextRefreshedEvent 事件， 初始化LifeCycleProcessor及调用其 onRefresh 方法.</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">			<span class="comment">// 设置容器初始的一些属性(时间,状态)，初始化占位符数据源并校验所有 bean 所使用的占位符是否存在, 清空事件和监听</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">			<span class="comment">// 清空重置旧的 beanFactory, 再创建新的 beanFactory 并解析 xml或注解 加载 beanDefinitions</span></span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">			<span class="comment">// 设置了一些 beanFactory 的属性, 添加了几个有用的 BeanPostProcessor, 还添加了几个 bean 到容器中(都是环境相关的 bean)</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">				<span class="comment">// 子类对beanFactory 添加自己的特殊的 BeanPostProcessor (如servletContxt/servletConfig注入)</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">				<span class="comment">// 扫描容器中实现了 BeanFactoryPostProcessor 接口的 bean 将其注册到 beanFactory 中并执行</span></span><br><span class="line">				<span class="comment">//   扫描6次, 2(BeanDefinitionRegistry/BeanFactory) x 3(优先级:高/中/其他)</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">				<span class="comment">// 扫描容器中实现了 BeanPostProcessor 接口的 bean 将其注册到 beanFactory 但不执行; 扫描6次: 2(MergedBeanDefinitionPostProcessor/其他) x 3(优先级: 高/中/其他)</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">				<span class="comment">// 创建一个国际化资源解析器并注册到 beanFactory.</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">				<span class="comment">// 创建一个事件广播器并注册到 beanFactory.</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">				<span class="comment">// 调用子类的其他刷新时需要做的事情(模板方法)</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">				<span class="comment">// 将可能存在的 applicationListeners 注册到事件广播器中(新建时是不存在的),</span></span><br><span class="line">				<span class="comment">// 然后扫描容器中实现了 ApplicationListener 接口的 bean, 将其预存到广播器中但不执行</span></span><br><span class="line">				<span class="comment">// 将之前 publishEvent() 想广播的事件广播出去, 然后字段 earlyApplicationEvents 赋值为空(代表之后可立即广播)</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">				<span class="comment">// 完成 beanFactory 的一些配置(包括终结一些东西, 如 setTempClassLoader(null) )</span></span><br><span class="line">				<span class="comment">// 注册默认的表达式解析器(若无相应的bean存在)</span></span><br><span class="line">				<span class="comment">// 扫描容器中实现了 LoadTimeWeaverAware 接口的 bean, 并触发(getBean)之前注册过的 BeanPostProcessor</span></span><br><span class="line">				<span class="comment">// 将单例的 bean 创建出来放入容器中(未设置lazy-init=true)的 bean</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">				<span class="comment">// 广播 ContextRefreshedEvent 事件， 初始化LifeCycleProcessor及调用其 onRefresh 方法.</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">							<span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">				<span class="comment">// 销毁缓存的单例对象</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Reset 'active' flag.</span></span><br><span class="line">				<span class="comment">// 变更状态</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">				<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">				<span class="comment">// 清空公共工具产生的缓存(内存松一口气).</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我错了, 代码都放上去不如给个GitHub地址, 接下来省略代码吧, 只放注释😄😄😄😄😄😄😄😄😄😄😄😄😄😄😄</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挨个看里面的方法</span></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#prepareRefresh</span><br><span class="line">    <span class="comment">// 1.设置容器初始的一些属性, 如启动时间, 当前状态</span></span><br><span class="line">		<span class="comment">// 2.打印开始日志</span></span><br><span class="line">		<span class="comment">// 3.初始化占位符数据源</span></span><br><span class="line">		<span class="comment">// 4.校验所有 bean 所使用的占位符是否存在</span></span><br><span class="line">		<span class="comment">// 5.清空事件和监听</span></span><br><span class="line">		<span class="comment">// Switch to active.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory</span><br><span class="line">    <span class="comment">// 1.存在旧的则先摧毁 bean 对象实例及缓存数据, 再将旧的置为 null</span></span><br><span class="line">		<span class="comment">// 2.创建一个新的 beanFactory 对象, 再设置 id及一些配置</span></span><br><span class="line">		<span class="comment">// 3.扫描并加载 beanDefinations</span></span><br><span class="line">		<span class="comment">// 4.设置这个新的 beanFactory 对象为 applicationContext 的 beanFactory 字段值.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</span><br><span class="line">    <span class="comment">// 1.设置 beanFactory 的类加载器</span></span><br><span class="line">		<span class="comment">// 2.设置 beanFactory 的表达式解析器</span></span><br><span class="line">		<span class="comment">// 3.1:注册一个 BeanPostProcessor 用于将实现了ApplicationContext能力相关的Aware接口的 bean, 触发赋值setter 注入 applicationContext 对象</span></span><br><span class="line">		<span class="comment">// 3.2:设置 beanFactory 处理 bean 时要忽略的接口(主要是setter注入时忽视一些也是setter的方法, 因为这些方法会由 PostProcessor 来触发)</span></span><br><span class="line">		<span class="comment">// 4.注册一些特殊的 bean(注入这些bean时会注入 this 对象: 多功能工具人 ApplicationContext, 可见其和普通 bean 的注册方式不一样)</span></span><br><span class="line">		<span class="comment">// 5.注册一个 BeanPostProcessor 用于检测加载的 bean 是否实现了 ApplicationListener 接口, 若是, 则注册到事件广播器中(不是,是暂存在applicationListeners字段中, 等事件广播器创建后才注册)</span></span><br><span class="line">		<span class="comment">// 6.注册一个 BeanPostProcessor 用于触发实现了 LoadTimeWeaverAware 接口的 bean 的 setLoadTimeWeaver() 社会 LTW 实例.</span></span><br><span class="line">		<span class="comment">// 7.注册几个环境相关 bean 到容器中(Spring的环境对象, 以及系统环境变量和系统配置文件)</span></span><br><span class="line"></span><br><span class="line">org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, java.util.List&lt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&gt;)</span><br><span class="line">    <span class="comment">// 1.若 beanFactory 实现了 BeanDefinitionRegistry 接口(new AnnotationConfigApplicationContext 就实现了)</span></span><br><span class="line">		<span class="comment">//    则扫描所有实现了 BeanDefinitionRegistryPostProcessor 接口的 bean, 根据优先级分三类(高/中/其他)依次执行</span></span><br><span class="line">		<span class="comment">// 2.然后扫描所有实现了 BeanFactoryPostProcessor 接口的 bean, 依旧是根据优先级分三类依次执行.</span></span><br><span class="line">		<span class="comment">// 3.每次执行前都会根据 Order 信息排序, 再遍历执行</span></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(org.springframework.beans.factory.config.ConfigurableListableBeanFactory, org.springframework.context.support.AbstractApplicationContext)</span><br><span class="line">    <span class="comment">// 1.扫描6次: 2(MergedBeanDefinitionPostProcessor/其他) x 3(优先级: 高/中/其他)</span></span><br><span class="line">		<span class="comment">//    将其加入到 beanFactory 的 beanPostProcessors 集合中</span></span><br><span class="line">		<span class="comment">// 2.再次加入 ApplicationListenerDetector (用于处理实现 ApplicationListener 的 bean 注册到事件广播器), 主要是使其在链末尾, 可以最后执行.</span></span><br><span class="line"></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#registerListeners</span><br><span class="line">    <span class="comment">// 1.将可能存在的 applicationListeners 注册到事件广播器中(新建时是不存在的)</span></span><br><span class="line">		<span class="comment">// 2.扫描容器中实现了 ApplicationListener 接口的 bean, 将其预存到广播器中但不执行</span></span><br><span class="line">		<span class="comment">// 3.将之前 publishEvent() 想广播的事件广播出去, 然后字段 earlyApplicationEvents 赋值为空</span></span><br><span class="line">		<span class="comment">//    (因为 publishEvent() 中根据是否为空判断立刻执行或先存着) (另这也解释了 prepareRefresh() 中为何要赋值一个空集合)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</span><br><span class="line">    <span class="comment">// 1.完成 beanFactory 的一些配置</span></span><br><span class="line">		<span class="comment">// 2.注册默认的表达式解析器(若无相应的bean存在)</span></span><br><span class="line">		<span class="comment">// 3.扫描容器中实现了 LoadTimeWeaverAware 接口的 bean, 并触发(getBean)之前注册过的 BeanPostProcessor</span></span><br><span class="line">		<span class="comment">// 4.将单例的 bean 创建出来放入容器中(未设置lazy-init=true)的 bean</span></span><br><span class="line"></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext#finishRefresh</span><br><span class="line">    <span class="comment">// 1.清空资源缓存</span></span><br><span class="line">		<span class="comment">// 2.创建一个生命周期管理器(start, refresh, stop等)并注册到 beanFactory</span></span><br><span class="line">		<span class="comment">// 3.触发生命周期管理器的 onRefresh()</span></span><br><span class="line">		<span class="comment">// 4.广播容器刷新完成的事件</span></span><br><span class="line">		<span class="comment">// 5.为 Spring Tool Suite 提供某些便捷(没用过, 不知道...)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可算复制完了, 如果你有幸直接跳读到这里, 那么送上地址 : <a href="https://github.com/gudqs7/spring-framework/tree/wq-comment" target="_blank" rel="noopener">注意分支吧</a> </p>
<p>另外上面方法前带个 <strong>#</strong> 的, 复制到 IDEA 双击 Shift 然后粘贴, 选择 Symbols 搜索更准确呢!</p>
</blockquote>
<h2 id="获取容器对象过程"><a href="#获取容器对象过程" class="headerlink" title="获取容器对象过程"></a>获取容器对象过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从getBean(Class type) 中进入</span></span><br><span class="line">1.检查 applicationContext 和 beanFactory 的状态, 若有异常则给出准确的错误.</span><br><span class="line">2.扫描容器中所有此 <span class="built_in">type</span> 的 beanName, 遍历判断每个 beanName 是否可用</span><br><span class="line">   可用则判断可用的个数是否刚好是一个, 是则直接调用 getBean() 返回对象实例</span><br><span class="line">   若可用的个数超过一个, 则根据 beanDefinition 的 isPrimary 和对比配置的优先级是否为有最高的再返回最高的</span><br><span class="line">   若都不行, 则报错.</span><br><span class="line">3.接着看 getBean, 先试着从单例的缓存中获取, 若存在则返回.</span><br><span class="line">4.若缓存中不存在, 则判断父容器是否存, 若存在则从父容器获取</span><br><span class="line">   若父容器不存在, 则自己新建, 先标记 beanName 到 alreadyCreated 中(表示已经创建了防止重复创建) 再开始创建一个 bean.</span><br><span class="line">5.创建一个新的 bean 实例, 先处理 beanDefinition 的 dependsOn 属性(即若存在则先调用 getBean 获取依赖的 bean)</span><br><span class="line">6.若 beanDefinition 的设置是单例, 则通过闭包对创建对象前后进行一些异常处理和缓存处理(主要是彻底创建完后加入到单例一级缓存, 移除二级和三级缓存[循环依赖相关的两个缓存]).</span><br><span class="line">7.通过反射根据 beanClass 创建一个对象实例, 然后将其添加到 singletonFactories 中(解决依赖循环问题)</span><br><span class="line">8.调用 populateBean() 为对象的字段(属性)注入它所需要的值(可能是@Resource, @Value等); (此时可能会遇到依赖循环问题, 但解决这个问题的缓存在此之前就添加了, 所以不怕)</span><br><span class="line">9.最后调用 initializeBean() 完成 bean 的初始化(调用 bean 的一些方法, 如 afterPropertiesSet), 返回对象实例.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 先根据 type 找到 beanName, 找到后根据 beanName 创建对象; 创建对象前先检查缓存(单例), 再考虑父容器, 最后才是自己创建, 自己创建会先创建 dependsOn 的 bean 对象, 然后才通过反射实例化出一个对象实例(这里反射用到的class和构造方法, 通过实现 SmartInstantiationAwareBeanPostProcessor接口都可进行干预), 实例化后存到二级缓存, 再为字段赋值(注入); 最后调用 bean 的 init 相关的接口(如afterPropertiesSet), 就可以返回这个对象实例了.</p>
</blockquote>
<h3 id="超长源码分析过程-1"><a href="#超长源码分析过程-1" class="headerlink" title="超长源码分析过程"></a>超长源码分析过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从这个方法进入</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 判断容器的状态, 确保 beanFactory 可用.(主要是若不可用, 提示的错误信息会比getBeanFacgtory()中更准确)</span></span><br><span class="line">  <span class="comment">// 使用 beanFactory 的 getBean 方法获取对象并返回.</span></span><br><span class="line">  assertBeanFactoryActive();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory().getBean(requiredType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后其他所有涉及的核心方法的注释</span></span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveBean</span><br><span class="line">    <span class="comment">// 调用 resolveNamedBean, 如存在 bean 则直接返回. (核心)</span></span><br><span class="line">		<span class="comment">// 若不存在则从父容器中寻找, 父容器实现了 DefaultListableBeanFactory 则调与同子容器相同的方法</span></span><br><span class="line">		<span class="comment">// 若没实现则 通过 getBeanProvider 获取.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveNamedBean(org.springframework.core.ResolvableType, java.lang.Object[], boolean)</span><br><span class="line">    <span class="comment">// 1.调用 getBeanNamesForType 获取所有与 type 相匹配的 beanName 集合.</span></span><br><span class="line">		<span class="comment">// 2.遍历判断每个 beanName 是否可用</span></span><br><span class="line">		<span class="comment">// 3.若可用的 beanName 只有一个, 则调用 getBean(beanName) 获取对象实例并返回</span></span><br><span class="line">		<span class="comment">//   若可用数超过一个, 则试着根据是否主要以及高优先级来确定一个 beanName 实例, 若能确定则返回, 不能则报错.</span></span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</span><br><span class="line">    <span class="comment">// 1.获取完整的 beanName</span></span><br><span class="line">		<span class="comment">// 2.调用 getSingleton1() 检查是否存在缓存, 这层检查可防止依赖循环.</span></span><br><span class="line">		<span class="comment">//     若存在, 则通过 getObjectForBeanInstance() 判断缓存的是 bean 还是 FactoryBean 并返回相应的对象实例.</span></span><br><span class="line">		<span class="comment">// 3.若不存在, 先试着从父容器获取(子容器不存在这个 beanDefinition 且父容器不为空)</span></span><br><span class="line">		<span class="comment">//     没有父容器则 调用 markBeanAsCreated() 标记这个 bean已经创建了 (先标记, 再创建)</span></span><br><span class="line">		<span class="comment">//     获取 beanDefinition, 判断其 dependsOn 属性是否存在, 存在则 先获取依赖的 bean</span></span><br><span class="line">		<span class="comment">//     调用 getSingleton2() 处理单例缓存</span></span><br><span class="line">		<span class="comment">// 4.而 getSingleton2() 中的闭包中 执行的 createBean() 方法中则才是创建实例并调用 BeanPostProcessor</span></span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)</span><br><span class="line">    <span class="comment">// 1.判断是否存在于 singletonObjects 中</span></span><br><span class="line">		<span class="comment">// 2.若不存在则判断 bean 是否处于创建中(未创建完成, 如循环依赖时)</span></span><br><span class="line">		<span class="comment">// 3.若处于创建中, 则同步后判断是否存在于 earlySingletonObjects (也就是 singletonFactories 移除后存入的地方)</span></span><br><span class="line">		<span class="comment">//      (因为FactoryBean占用空间大, 获取对象麻烦且速度更慢, 这是为了防止如果循环依赖链条很长 多次获取浪费CPU的问题)</span></span><br><span class="line">		<span class="comment">// 4.不存于 earlySingletonObjects 则代表第一次(也只会有一次)取 singletonFactories</span></span><br><span class="line">		<span class="comment">//    取出后调用 getObject() 并将其存入到 earlySingletonObjects, 然后从 singletonFactories 中移除. 以后就少走几行代码了.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</span><br><span class="line">    <span class="comment">// 1.先确保是第一次创建单例对象, 防止重复创建</span></span><br><span class="line">		<span class="comment">// 2.进行一些异常处理</span></span><br><span class="line">		<span class="comment">// 3.调用 singletonFactory.getObject() 创建对象</span></span><br><span class="line">		<span class="comment">// 4.创建对象结束添加单例缓存和清空 singletonFactories / earlySingletonObjects 缓存.</span></span><br><span class="line">  </span><br><span class="line">org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</span><br><span class="line">    <span class="comment">// 1.调用 resolveBeanClass 解析得到真正的 bean class, 若解析不为空且处于某些情况下, 则复制一份 beanDefinition 并设置 beanClass 为解析所得</span></span><br><span class="line">		<span class="comment">// 2.执行 BeanPostProcessor 的 postProcessorsBeforeInstantiation() 方法</span></span><br><span class="line">		<span class="comment">// 3.调用 doCreateBean() 创建对象 并返回</span></span><br><span class="line"></span><br><span class="line">org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</span><br><span class="line">    <span class="comment">// 1.调用 createBeanInstance() 获得一个 对象实例的 包装类</span></span><br><span class="line">		<span class="comment">// 2.同步锁下执行 BeanFactoryPostProcessor 的 postProcessMergedBeanDefinition().</span></span><br><span class="line">		<span class="comment">// 3.添加 singletonFactories 缓存, 移除 earlySingletonObjects; 解决循环依赖问题.</span></span><br><span class="line">		<span class="comment">// 4.调用 populateBean() 检查字段是否需要注入对象实例, 是则获取对应的 bean 注入. (可能引起循环依赖)</span></span><br><span class="line">		<span class="comment">// 5.调用 initializeBean() 执行对象的一些 Aware 和 init 方法和 BeanPostProcessor 的 postProcessBeforeInitialization.</span></span><br><span class="line">		<span class="comment">// 6.最后返回对象实例.</span></span><br></pre></td></tr></table></figure>





<h2 id="各种实现的原理"><a href="#各种实现的原理" class="headerlink" title="各种实现的原理"></a>各种实现的原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?</span><br><span class="line">2.为何我写的 class 实现 ApplicationListener&lt;XxxEvent&gt; 后并放入容器中, 就能监听我想知道的事件?</span><br><span class="line">3.为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?</span><br><span class="line">4.Spring是如何解决循环依赖的(指用字段注入而非构造方法)?</span><br><span class="line">5.Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?</span><br><span class="line">6.Spring AOP是如何实现的(指@Aspect)?</span><br><span class="line">7.Spring 事务是如何实现的(指@Transaction)?</span><br></pre></td></tr></table></figure>

<h3 id="为何我写的-class-实现一些接口-如ApplicationContextAware-后并放入容器中-就可以获取到一些对象-如applicationContext"><a href="#为何我写的-class-实现一些接口-如ApplicationContextAware-后并放入容器中-就可以获取到一些对象-如applicationContext" class="headerlink" title="为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?"></a>为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) 首先 AbstractApplicationContext#prepareBeanFactory 会添加一个ApplicationContextAwareProcessor</span><br><span class="line">2) 这个 beanPostProcessor 负责在bean初始化之前注入context对象.</span><br><span class="line">3) 这个 beanPostProcessor 的执行时机是在 doCreateBean 中的 postProcessBeforeInitialization()</span><br></pre></td></tr></table></figure>



<h3 id="为何我写的-class-实现-ApplicationListener-后并放入容器中-就能监听我想知道的事件"><a href="#为何我写的-class-实现-ApplicationListener-后并放入容器中-就能监听我想知道的事件" class="headerlink" title="为何我写的 class 实现 ApplicationListener 后并放入容器中, 就能监听我想知道的事件?"></a>为何我写的 class 实现 ApplicationListener<XxxEvent> 后并放入容器中, 就能监听我想知道的事件?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) 在 AbstractApplicationContext#registerListeners() 中扫描容器内所有相关实现类加入到事件监听者集合中</span><br><span class="line">2) 然后在publishEvent时，遍历事件监听者集合调用bean的方法即可。观察者模式！</span><br><span class="line">3) 另外也用了BeanPostProcessor去实现, 叫 ApplicationListenerDetector, 加入时机同1, 执行时机同1.</span><br><span class="line">4) 至于为何使用2种机制, 应该是因为 registerListeners() 时, 扫描只是当前的, 后续可能容器内的 bean 还会增加(我也猜不到啥形式增加, 反正简单写个类肯定不会), 所以还是需要 ApplicationListenerDetector 在这个 Bean 初始化时加入到监听者中去.</span><br></pre></td></tr></table></figure>



<h3 id="为何Spring中遇到各种顺序问题-只需要实现-Ordered-接口-或加上-Order注解-就能使其有序"><a href="#为何Spring中遇到各种顺序问题-只需要实现-Ordered-接口-或加上-Order注解-就能使其有序" class="headerlink" title="为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?"></a>为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?</h3><blockquote>
<p>因为 Spring 预先在执行这些东西之前, 进行一个排序动作, 然后才遍历执行. 包括AOP, BeanFactoryPostProcessor, BeanPostProcessor .</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) 比如说 BeanPostProcesser, 容器扫描后, 会像对bean集合排序, 再遍历执行.</span><br><span class="line">2) 详细过程见 PostProcessorRegistrationDelegate#sortPostProcessors()</span><br></pre></td></tr></table></figure>



<h3 id="Spring是如何解决循环依赖的-指用字段注入而非构造方法"><a href="#Spring是如何解决循环依赖的-指用字段注入而非构造方法" class="headerlink" title="Spring是如何解决循环依赖的(指用字段注入而非构造方法)?"></a>Spring是如何解决循环依赖的(指用字段注入而非构造方法)?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 首先， 假定有两个单例 bean A 和 B, A 持有 B, B 持有A， 构成循环</span><br><span class="line"><span class="number">2</span>) 此时程序调用getBean获取A，则在 doCreateBean 中 创建后将 bean 缓存到 singletonFactories 中</span><br><span class="line"><span class="number">3</span>) 然后设置属性B, 解析属性, 需要获取B对象</span><br><span class="line"><span class="number">4</span>) 获取B, 则执行doCreateBean 后执行解析属性, 需要获取 A对象 (又一次)</span><br><span class="line"><span class="number">5</span>) 获取A, 进入 doGetBean 中的 getSingleton, 此时判断 singletonFactories 中有A, 则可以直接取出A</span><br><span class="line"><span class="number">6</span>) 获得A后, 即可完成B的属性赋值, 然后会完成B的创建.</span><br><span class="line"><span class="number">7</span>) B创建完后, A就能获得B, 则A也完成了属性赋值, 最后完成创建A.</span><br><span class="line"><span class="number">8</span>) 到此, 返回即可.</span><br><span class="line"></span><br><span class="line">&gt; 总结: 首次获取A, 创建A对象后缓存一个存储A对象的 ObjectFactory 实例, 再解析属性时触发 getBean(B), 同理也会做缓存, 然后也解析属性, 触发getBean(A), 第二次获取A, 进入另一个逻辑, 返回 ObjectFactory 实例中存储的对象A, 即可完成getBean(A), 然后完成getBean(B), 再完成外层的getBean(A).  </span><br><span class="line">  </span><br><span class="line">TIPS:</span><br><span class="line">步骤<span class="number">4</span>中, 会先判断 earlySingletonObjects, 不存在才判断 singletonFactories, 而从 singletonFactories 中取得对象后, 则会将其从 singletonFactories 移除并加入 earlySingletonObjects</span><br><span class="line"></span><br><span class="line">这是因为 singletonFactories 缓存的 FactoryBean, 若反复调用 getObject(), 则每次获取都会调用 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#getEarlyBeanReference 方法, 而此方法会执行 SmartInstantiationAwareBeanPostProcessor 的 getEarlyBeanReference(), 这会导致 BeanPostProcessor 重复执行, 显然是不行的.</span><br></pre></td></tr></table></figure>



<h3 id="Spring可以用注解替换XML配置文件了-是如何实现的呢-常用注解的实现原理"><a href="#Spring可以用注解替换XML配置文件了-是如何实现的呢-常用注解的实现原理" class="headerlink" title="Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?"></a>Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1) 首先是指定包名或指定类名</span><br><span class="line">	如指定包名则 scan 时会执行, 如指定类名则在构造方法初始化 reader 时执行</span><br><span class="line">2) 无论哪种, 最终都会走一段代码 AnnotationConfigUtils#registerAnnotationConfigProcessors()</span><br><span class="line">3) 这段代码会添加一些 BeanFactoryPostProcessor</span><br><span class="line">	如 ConfigurationClassPostProcessor 负责解析 @Configuration&#x2F;@Import&#x2F;@Bean 等注解</span><br><span class="line">    	然后由 ConfigurationClassBeanDefinitionReader 负责将信息转换成BeanDefinition再注册到容器。</span><br><span class="line">	如 AutowiredAnnotationBeanPostProcessor 负责解析 @Autowired&#x2F;@Value 注解</span><br><span class="line">    如 CommonAnnotationBeanPostProcessor 负责解析 @Resource 注解</span><br><span class="line">    解析放在 postProcessProperties() 方法中， 先扫描bean的字段和方法， 然后一一调用方法和为字段注入值</span><br><span class="line">4) 之后, 他会将扫描的类放到 beanDefinitions 中(或指定的类注册进去)</span><br><span class="line">5) BeanFactory加载完毕后, 回到AbstractApplicationContext的refresh逻辑</span><br><span class="line">	如会执行 postProcessBeanFactory(), 调用前面加入的ConfigurationClassPostProcessor</span><br><span class="line">	然后会添加更多的类到容器中.</span><br><span class="line">    </span><br><span class="line">注意事项：</span><br><span class="line">    @Configuration 和 @Component的区别？</span><br><span class="line">    观察发现，即使使用@Component 其下带 @Bean 的方法依然可以注入到容器中。所以似乎两者没有区别？</span><br><span class="line">    仔细查看源码和资料后，发现 postProcessBeanFactory() 方法在 processConfigBeanDefinitions() 后还会调用 enhanceConfigurationClasses()</span><br><span class="line">    而在这个方法中, 对前面解析了class 是 CONFIGURATION_CLASS_FULL (即代表@Configuration)的类</span><br><span class="line">    会生成一个 cglib 的代理, 这样获取@Bean注解的方法的bean时,不会每次调用方法new 一个, 而是有缓存.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 就是利用 BeanFactoryPostProcessor 可获取 BeanDefinitionRegistry 对象, 然后扫描容器内带有注解的 bean, 解析这些注解得到一些 BeanDefinition, 再通过获得的 BeanDefinitionRegistry对象注册到 BeanFactory 中.</p>
</blockquote>
<h3 id="Spring-AOP是如何实现的-指-Aspect"><a href="#Spring-AOP是如何实现的-指-Aspect" class="headerlink" title="Spring AOP是如何实现的(指@Aspect)?"></a>Spring AOP是如何实现的(指@Aspect)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1) 使用 @EnableAspectJAutoProxy</span><br><span class="line">2) @EnableAspectJAutoProxy 中使用了 @Import(AspectJAutoProxyRegistrar.class)</span><br><span class="line">3) ConfigurationClassPostProcessor 会解析@Import, 进入 registerBeanDefinitions() 中</span><br><span class="line">4) registerBeanDefinitions() 中添加了 AnnotationAwareAspectJAutoProxyCreator 到容器中</span><br><span class="line">5) AnnotationAwareAspectJAutoProxyCreator 本质上时一个 BeanPostProcessor</span><br><span class="line">6) 因此在 createBean 时, 会被自动调用. 其中 postProcessAfterInitialization() 负责创建代理对象</span><br><span class="line">7) 而 getAdvicesAndAdvisorsForBean() 则负责查找对应的增强. 然后会调用子类的findCandidateAdvisors</span><br><span class="line">8) 如 AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors() 负责注解编写增强@Before&#x2F;@After等</span><br><span class="line">9) 简单说下逻辑, 就是查找容器所有类, 判断这个类有没有 @Aspect 注解, 然后先找出所有Pointcut</span><br><span class="line">	再遍历所有方法, 找出方法上带有@Before等注解且有关联的Pointcut的方法,</span><br><span class="line">    然后使用这个方法和关联的Pointcut 来new 一个Advisor, 加入到Advisor集合中, 遍历结束后返回即可.</span><br><span class="line">10) 查找到所有的增强后, 再比较Pointcut表达式是否匹配当前的bean, 如可以则加入.</span><br><span class="line">11) 根据找到的Advisor集合, 创建一个带配置(advisor集合等)的代理对象, 代理对象执行方法前</span><br><span class="line">12) 会先根据配置中的advisor集合生成一个执行链, 然后在拦截代理方法处调用. 执行链会负责执行通知.</span><br><span class="line">13) 不同的通知由不同的适配器执行.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结就是通过 @EnableAspectJAutoProxy 的@Import, 使得程序最终会执行 AnnotationAwareAspectJAutoProxyCreator 的 postProcessAfterInitialization(对象初始化后调用) 方法, 这个方法在 BeanFactory创建完对象后触发, 此时便可通过 CGlib 等动态代理技术为 创建的 bean 对象创建一个代理对象, 然后这个代理对象会根据 Pointcut 找到关联的 Advisor,  并在合适的时机执行对应的 Advisor, 如 @Before产生的Advisor 会在执行了 bean 对象的指定方法(看Pointcut配置)后执行.</p>
</blockquote>
<h3 id="Spring-事务是如何实现的-指-Transaction"><a href="#Spring-事务是如何实现的-指-Transaction" class="headerlink" title="Spring 事务是如何实现的(指@Transaction)?"></a>Spring 事务是如何实现的(指@Transaction)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0) 事务是由AOP实现的, 所以需要找到对应的Pointcut 和 Advisor</span><br><span class="line">1) 打开了 @EnableTransactionManagement 注解</span><br><span class="line">2) 然后@Import 了 TransactionManagementConfigurationSelector</span><br><span class="line">3) 之后导入了 ProxyTransactionManagementConfiguration 到容器中</span><br><span class="line">4) ProxyTransactionManagementConfiguration 带有 @Configuration</span><br><span class="line">5) @Bean 注入了一个通用的Advisor: BeanFactoryTransactionAttributeSourceAdvisor</span><br><span class="line">6) 这个Advisor的 Pointcut 是由 TransactionAttributeSourcePointcut 实现的</span><br><span class="line">	实现逻辑是 TransactionAttributeSourcePointcut 的 matches()</span><br><span class="line">    这个方法调用了 getTransactionAttributeSource() 获取 AnnotationTransactionAttributeSource</span><br><span class="line">    然后通过 getTransactionAttribute() 调用了 findTransactionAttribute()</span><br><span class="line">    最终使用SpringTransactionAnnotationParser 类判断方法是否有@Transactional注解</span><br><span class="line">    并解析注解信息然后返回. 另外这个方法还可以获取@Transactional注解的信息, 而这里只用于判断是否需要拦截这个方法.</span><br><span class="line">7) TransactionInterceptor 是一个Advisor</span><br><span class="line">    也可以通过AnnotationTransactionAttributeSource获取@Transactional注解上的信息</span><br><span class="line">    然后在invoke中, 拦截方法, 打开事务, 在执行完方法后, 提交事务, 报错时回滚事务</span><br><span class="line">    这个 Advisor 不同于传统的前置&#x2F;后置, 而是更具体的 MethodInterceptor(动态代理直接相关).</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 就是基于AOP实现的, 只需找到对应的 Pointcut 和 Advisor 即可. Pointcut 就是根据 @Transaction 注解判断方法是否需要代理, 这个很简单; 比较有意思的是 Advisor 不是我们写AOP那种 @Before,@Around之类的, 而是更接近动态代理原始的语法的 MethodInterceptor 即 TransactionInterceptor.</p>
</blockquote>
<h2 id="BeanFactoryPostProcessor-相关类分析"><a href="#BeanFactoryPostProcessor-相关类分析" class="headerlink" title="BeanFactoryPostProcessor 相关类分析"></a>BeanFactoryPostProcessor 相关类分析</h2><h3 id="BeanFactoryPostProcessor-生效原理"><a href="#BeanFactoryPostProcessor-生效原理" class="headerlink" title="BeanFactoryPostProcessor 生效原理"></a>BeanFactoryPostProcessor 生效原理</h3><blockquote>
<p>生效原理就是, ApplicationContext 的 refresh 方法中会扫描出容器中实现了 BeanFactoryPostProcessor 接口的 bean, 将其排序后执行相应的接口, 这样我们写的类实现的相应的接口的方法就被执行了.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常用的 BeanFactoryPostProcessor</span><br><span class="line"><span class="comment"># ConfigurationClassPostProcessor</span></span><br><span class="line">这个类作用就是解析 @Configuration/@Component/@Import/@ImportSource/@ComponentScan 等基础注解. 是注解开发的基石, 更是 Spring Boot 的基石.</span><br></pre></td></tr></table></figure>



<h2 id="BeanPostProcessor-相关类分析"><a href="#BeanPostProcessor-相关类分析" class="headerlink" title="BeanPostProcessor 相关类分析"></a>BeanPostProcessor 相关类分析</h2><h3 id="BeanPostProcessor-生效原理"><a href="#BeanPostProcessor-生效原理" class="headerlink" title="BeanPostProcessor 生效原理"></a>BeanPostProcessor 生效原理</h3><blockquote>
<p>在 refresh() 中会扫描容器中所有 实现了 BeanPostProcessor 接口的类, 添加到 BeanFactory 的 beanPostProcessors 字段中(是个List[CopyOnWriteArrayList自定义版, 自定义加入了清空缓存的逻辑]), 然后在 BeanFactory 创建对象时 createBean() 在适当的时机调用对应的方法.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">有哪几种 BeanPostProcessor (默认的+扩展)</span><br><span class="line">1.InstantiationAwareBeanPostProcessor</span><br><span class="line">	postProcessAfterInstantiation: 对象实例化后调用</span><br><span class="line">	postProcessBeforeInstantiation: 对象实例化前调用</span><br><span class="line">	postProcessProperties: 设置属性值前</span><br><span class="line">	postProcessPropertyValues: 设置属性值前, 若上个方法不处理(返回null)才会触发</span><br><span class="line"></span><br><span class="line">2.SmartInstantiationAwareBeanPostProcessor</span><br><span class="line">  predictBeanType: 获取一个 bean 的 class 类型前调用</span><br><span class="line">  getEarlyBeanReference: 获取一个二级缓存对象(singletonFactories的getObject)时调用</span><br><span class="line">  determineCandidateConstructors: 决定一个 bean 实例化的构造参数是什么时调用</span><br><span class="line">	</span><br><span class="line">3.DestructionAwareBeanPostProcessor</span><br><span class="line">	postProcessBeforeDestruction: 对象销毁前调用</span><br><span class="line">	requiresDestruction: 判断这个类针对某个 bean 是否执行 postProcessBeforeDestruction()</span><br><span class="line">	</span><br><span class="line">4.MergedBeanDefinitionPostProcessor</span><br><span class="line">  postProcessMergedBeanDefinition: 在创建对象前调用, 可对 BeanDefinition 做修改</span><br><span class="line">  resetBeanDefinition: 在重置 BeanDefinition 时调用, 用于清空 PostProcessor 对应的缓存</span><br><span class="line">	</span><br><span class="line">5.BeanPostProcessor(基础)</span><br><span class="line">  postProcessBeforeInitialization: 创建对象后(也设置好了字段), 在调用 init 之前调用</span><br><span class="line">  postProcessAfterInitialization: 在创建对象时, 调用了 init 之后调用</span><br><span class="line">  </span><br><span class="line">总结: </span><br><span class="line">0.对 BeanDefinition 做干预</span><br><span class="line">1.对象实例化过程中(对class/构造参数进行干预)</span><br><span class="line">2.对象实例化前后</span><br><span class="line">3.对象设置属性前, 对属性做干预</span><br><span class="line">4.对象初始化(init)前后</span><br><span class="line">5.对象销毁前</span><br></pre></td></tr></table></figure>

<h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 1.1: InstantiationAwareBeanPostProcessor 的 postProcessAfterInstantiation()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean 第一段</span></span><br><span class="line"><span class="comment">// 1.2: InstantiationAwareBeanPostProcessor 的 postProcessProperties()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean 第二段</span></span><br><span class="line"><span class="comment">// 1.3: InstantiationAwareBeanPostProcessor 的 postProcessPropertyValues</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean 第三段</span></span><br><span class="line"><span class="comment">// 1.4: InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1: SmartInstantiationAwareBeanPostProcessor 的 predictBeanType()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.predictBeanType 中</span></span><br><span class="line"><span class="comment">// 2.2: SmartInstantiationAwareBeanPostProcessor 的 getEarlyBeanReference()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getEarlyBeanReference 中</span></span><br><span class="line"><span class="comment">// 2.3: SmartInstantiationAwareBeanPostProcessor 的 determineCandidateConstructors()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineConstructorsFromBeanPostProcessors 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1: MergedBeanDefinitionPostProcessor 的 postProcessMergedBeanDefinition()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors 中</span></span><br><span class="line"><span class="comment">// 3.2: MergedBeanDefinitionPostProcessor 的 resetBeanDefinition()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.DefaultListableBeanFactory.resetBeanDefinition 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.1: DestructionAwareBeanPostProcessor 的 postProcessBeforeDestruction()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.DisposableBeanAdapter.destroy 中</span></span><br><span class="line"><span class="comment">// 4.2: DestructionAwareBeanPostProcessor 的 requiresDestruction()</span></span><br><span class="line"><span class="comment">//   在 org.springframework.beans.factory.support.DisposableBeanAdapter.filterPostProcessors 和 org.springframework.beans.factory.support.DisposableBeanAdapter.hasApplicableProcessors 中</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁😁</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有哪些常用的 BeanPostProcessor</span></span><br><span class="line">1.AsyncAnnotationBeanPostProcessor: 用于在将 @Async 相应的 Advisor 加入到对象的代理中</span><br><span class="line">2.ScheduledAnnotationBeanPostProcessor: 用于处理 @Scheduled 注解, 将 bean 生产代理类</span><br><span class="line">3.AnnotationAwareAspectJAutoProxyCreator: AOP 实现核心类</span><br><span class="line">4.AutowiredAnnotationBeanPostProcessor: 用于处理 @Autowired 注解</span><br><span class="line">5.ApplicationListenerDetector: 用于处理实现 ApplicationListener 接口的 bean 对象, 将其添加到事件广播器的监听者集合中.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        <div class="reward-container">
  <div>下次一定</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="gudqs7 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/bitcoin.png" alt="gudqs7 比特币">
        <p>比特币</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/source-code/" rel="tag"># source-code</a>
              <a href="/tags/spring/" rel="tag"># spring</a>
              <a href="/tags/memo/" rel="tag"># memo</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/20/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89method-%E5%92%8C-interface/" rel="prev" title="Go学习笔记 (三) : method 和 interface">
      <i class="fa fa-chevron-left"></i> Go学习笔记 (三) : method 和 interface
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring源码分析"><span class="nav-number">1.</span> <span class="nav-text">Spring源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关键类介绍"><span class="nav-number">1.1.</span> <span class="nav-text">关键类介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext"><span class="nav-number">1.1.1.</span> <span class="nav-text">ApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory"><span class="nav-number">1.1.2.</span> <span class="nav-text">BeanFactory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器初始化过程"><span class="nav-number">1.2.</span> <span class="nav-text">容器初始化过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#超长源码分析过程"><span class="nav-number">1.2.1.</span> <span class="nav-text">超长源码分析过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取容器对象过程"><span class="nav-number">1.3.</span> <span class="nav-text">获取容器对象过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#超长源码分析过程-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">超长源码分析过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各种实现的原理"><span class="nav-number">1.4.</span> <span class="nav-text">各种实现的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为何我写的-class-实现一些接口-如ApplicationContextAware-后并放入容器中-就可以获取到一些对象-如applicationContext"><span class="nav-number">1.4.1.</span> <span class="nav-text">为何我写的 class 实现一些接口(如ApplicationContextAware)后并放入容器中, 就可以获取到一些对象(如applicationContext)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为何我写的-class-实现-ApplicationListener-后并放入容器中-就能监听我想知道的事件"><span class="nav-number">1.4.2.</span> <span class="nav-text">为何我写的 class 实现 ApplicationListener 后并放入容器中, 就能监听我想知道的事件?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为何Spring中遇到各种顺序问题-只需要实现-Ordered-接口-或加上-Order注解-就能使其有序"><span class="nav-number">1.4.3.</span> <span class="nav-text">为何Spring中遇到各种顺序问题, 只需要实现 Ordered 接口(或加上@Order注解)就能使其有序?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring是如何解决循环依赖的-指用字段注入而非构造方法"><span class="nav-number">1.4.4.</span> <span class="nav-text">Spring是如何解决循环依赖的(指用字段注入而非构造方法)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring可以用注解替换XML配置文件了-是如何实现的呢-常用注解的实现原理"><span class="nav-number">1.4.5.</span> <span class="nav-text">Spring可以用注解替换XML配置文件了, 是如何实现的呢(常用注解的实现原理)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-AOP是如何实现的-指-Aspect"><span class="nav-number">1.4.6.</span> <span class="nav-text">Spring AOP是如何实现的(指@Aspect)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-事务是如何实现的-指-Transaction"><span class="nav-number">1.4.7.</span> <span class="nav-text">Spring 事务是如何实现的(指@Transaction)?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactoryPostProcessor-相关类分析"><span class="nav-number">1.5.</span> <span class="nav-text">BeanFactoryPostProcessor 相关类分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactoryPostProcessor-生效原理"><span class="nav-number">1.5.1.</span> <span class="nav-text">BeanFactoryPostProcessor 生效原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanPostProcessor-相关类分析"><span class="nav-number">1.6.</span> <span class="nav-text">BeanPostProcessor 相关类分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanPostProcessor-生效原理"><span class="nav-number">1.6.1.</span> <span class="nav-text">BeanPostProcessor 生效原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用时机"><span class="nav-number">1.6.2.</span> <span class="nav-text">调用时机</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gudqs7"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">gudqs7</p>
  <div class="site-description" itemprop="description">心累没钱躺尸中</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gudqs7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gudqs7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gudqs7@gmail.com" title="E-Mail → mailto:gudqs7@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gudqs7</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gudqs7s-note.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://gudqs7.github.io/2021/01/23/source-code-spring/";
    this.page.identifier = "2021/01/23/source-code-spring/";
    this.page.title = "Spring源码笔记";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://gudqs7s-note.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
