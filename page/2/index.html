<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gudqs7.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="心累没钱躺尸中">
<meta property="og:type" content="website">
<meta property="og:title" content="gudqs7&#39;s note">
<meta property="og:url" content="https://gudqs7.github.io/page/2/index.html">
<meta property="og:site_name" content="gudqs7&#39;s note">
<meta property="og:description" content="心累没钱躺尸中">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="gudqs7">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gudqs7.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>gudqs7's note</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gudqs7's note</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">心累没钱躺尸中</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/29/source-code-spring-cloud-server-discover-and-register/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/source-code-spring-cloud-server-discover-and-register/" class="post-title-link" itemprop="url">Spring Cloud 服务注册与发现源码笔记 (Nacos/Consul/Eureka)</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 13:21:23" itemprop="dateCreated datePublished" datetime="2021-01-29T13:21:23+08:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:49:43" itemprop="dateModified" datetime="2021-03-28T19:49:43+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud/" itemprop="url" rel="index"><span itemprop="name">spring-cloud</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/29/source-code-spring-cloud-server-discover-and-register/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/29/source-code-spring-cloud-server-discover-and-register/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Cloud-服务注册与发现源码笔记-Nacos-Consul-Eureka"><a href="#Spring-Cloud-服务注册与发现源码笔记-Nacos-Consul-Eureka" class="headerlink" title="Spring Cloud 服务注册与发现源码笔记 (Nacos/Consul/Eureka)"></a>Spring Cloud 服务注册与发现源码笔记 (Nacos/Consul/Eureka)</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">1.EurekaClientAutoConfiguration</span><br><span class="line">	注册了众多的 bean</span><br><span class="line">	一部分用于和 Eureka Server 交互</span><br><span class="line">	一部分和 Commons 项目对接</span><br><span class="line">	注册了(EurekaClient/EurekaAutoServiceRegistration/ApplicationInfoManager/EurekaRegistration)</span><br><span class="line">	   </span><br><span class="line">2.EurekaClient</span><br><span class="line">	与 Eureka Server 端交互</span><br><span class="line">	负责向 Eureka Server 端注册/注销服务实例</span><br><span class="line">	在构造方法和 shutdown 方法中根据配置处理自动注册和自动注销.</span><br><span class="line"></span><br><span class="line">3.InstanceInfoReplicator</span><br><span class="line">	负责定义一个注册或更新服务实例的任务</span><br><span class="line">	负责管理任务执行器</span><br><span class="line"></span><br><span class="line">4.RestTemplateEurekaHttpClient</span><br><span class="line">	负责根据服务实例信息构造注册/注销的 Http 请求</span><br><span class="line">	使用 RestTemplate 发送请求</span><br><span class="line">	</span><br><span class="line">5.EurekaAutoServiceRegistration</span><br><span class="line">	负责管理服务实例的自动注册/注销, 与容器生命周期挂钩</span><br><span class="line"></span><br><span class="line">6.ApplicationInfoManager</span><br><span class="line">	负责管理服务实例状态变更事件(即管理监听者并在适当时机触发他们)</span><br><span class="line"></span><br><span class="line">7.ApplicationInfoManager.StatusChangeListener</span><br><span class="line">	状态改变事件监听者类</span><br><span class="line">	</span><br><span class="line">8.EurekaHealthCheckHandler</span><br><span class="line">	服务实例状态健康检查类, 注册/注销服务实例前会调用此类进行检查其状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务发现</span></span><br><span class="line">1.BlockingLoadBalancer (Commons 项目上)</span><br><span class="line">	负责调用实际的负载均衡器去选择一个服务实例</span><br><span class="line">	负责调度负载均衡整个过程, 触发相应的生命周期.</span><br><span class="line">	</span><br><span class="line">2.RoundRobinLoadBalancer (Commons 项目上)</span><br><span class="line">	实际的负载均衡策略算法类</span><br><span class="line">	负责连接 ServiceInstanceListSupplier 从其中获取服务实例列表</span><br><span class="line"></span><br><span class="line">3.ServiceInstanceListSupplier</span><br><span class="line">	定义了获取服务实例实例列表的接口(任意方式)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClient</span><br><span class="line">	定义了从服务端获取服务实例列表的接口(更明确了)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClientServiceInstanceListSupplier</span><br><span class="line">	ServiceInstanceListSupplier 的实现类</span><br><span class="line">	连接 ReactiveDiscoveryClient 类, 将服务端获取道德服务实例列表返回出去</span><br><span class="line">	</span><br><span class="line">5.EurekaDiscoveryClient</span><br><span class="line">	实现了 DiscoveryClient 接口</span><br><span class="line">	负责调用 EurekaClient 从 Eureka Server 端获取服务实例列表.</span><br><span class="line"></span><br><span class="line">6.EurekaClient</span><br><span class="line">	与 Eureka Server 端交互</span><br><span class="line">	负责向 Eureka Server 端获取服务实例列表</span><br><span class="line">	在构造方法和 shutdown 方法中根据配置处理自动注册和自动注销.</span><br><span class="line"></span><br><span class="line">7.EurekaServiceInstance</span><br><span class="line">	服务实例信息对象</span><br><span class="line">	实现 ServiceInstance, 与 Commons 对接</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">实现了 Commons 的 DiscoveryClient 接口(即 EurekaDiscoveryClient), 于是服务发现实现了;</span><br><span class="line">实现了 Commons 的 ServiceRegisty 接口(即 EurekaServiceRegistry), 于是服务注册也实现了.</span><br><span class="line">再总结: Commons 大发好.</span><br></pre></td></tr></table></figure>





<h3 id="服务注册流程"><a href="#服务注册流程" class="headerlink" title="服务注册流程"></a>服务注册流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># EurekaClient 构造方法触发(前提 shouldRegisterWithEureka 为 true)</span></span><br><span class="line">1.EurekaClientAutoConfiguration 让容器里注册了一个 EurekaClient</span><br><span class="line">2.EurekaClient 这个类在构造方法中的 initScheduledTasks() 生成了一个 InstanceInfoReplicator 对象</span><br><span class="line">3.然后调用其 instanceInfoReplicator.start(), 逻辑是添加一个定时任务(仅执行一次), 定时任务执行 run()</span><br><span class="line">4.run() 里面会执行 discoveryClient.register() 也就是注册实例信息到 Eureka 上去.</span><br><span class="line">5.register() 里面会调用 RestTemplateEurekaHttpClient<span class="comment">#register() </span></span><br><span class="line">6.这个方法是构造一个 HTTP 请求, 地址为 serviceUrl + <span class="string">"apps/"</span> + info.getAppName(), Method 为 POST, 即 Eureka server 的ip/apps/服务实例名称(如spring.application.name), 当然请求 body 还会带上实例信息 info 对象.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据容器生命周期触发</span></span><br><span class="line">1.EurekaClientAutoConfiguration 让容器里注册了一个 EurekaAutoServiceRegistration.</span><br><span class="line">2.这个类即是 SmartLifecycle(与容器生命周期绑定), 也是 SmartApplicationListener(监听容器加载/关闭事件)</span><br><span class="line">3.因此其对应的 start()/stop() 和 onApplicationEvent() 都实现了对应的逻辑.</span><br><span class="line">4.如 start() 的逻辑为调用 EurekaServiceRegistry<span class="comment">#register()</span></span><br><span class="line">5.register() 先修改本地服务实例的装填, 再通过 com.netflix.discovery.DiscoveryClient<span class="comment">#registerHealthCheck() 来往任务管理器中提交一个任务, 后台执行, 任务 InstanceInfoReplicator#onDemandUpdate()</span></span><br><span class="line">6.此任务就是最终也会调用前面提到的 (4) 中的 run(). 然后就注册上去了.</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS</span></span><br><span class="line">(6) 中的任务, 与状态监听是一致的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 容器注册 EurekaClient, 调用构造方法完成大量初始化工作后, 另起一个线程调用 restTemplate 发送 HTTP 请求将当前服务实例信息发送给 Eureka server. 完成服务注册工作.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A(EurekaClientAutoConfiguration)</span><br><span class="line">A1(EurekaClient)</span><br><span class="line">A2(InstanceInfoReplicator)</span><br><span class="line">A3(EurekaClient#register)</span><br><span class="line">A4(RestTemplateEurekaHttpClient)</span><br><span class="line">A5(RestTemplate)</span><br><span class="line">A6(Eureka Server)</span><br><span class="line">A7(EurekaHttpResponse)</span><br><span class="line"></span><br><span class="line">A--让容器里注册一个--&gt;A1</span><br><span class="line">A1--在构造方法中生成一个--&gt;A2</span><br><span class="line">A2--在 run 方法中调用--&gt;A3</span><br><span class="line">A3--又把服务实例信息交给--&gt;A4</span><br><span class="line">A4--根据服务实例信息构造HTTP请求--&gt;A5</span><br><span class="line">A5--将服务实例信息发送给--&gt;A6</span><br><span class="line">A6--返回一个--&gt;A7</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210129172741.png" alt="image-20210129171345329"></p>
<h3 id="服务注销流程"><a href="#服务注销流程" class="headerlink" title="服务注销流程"></a>服务注销流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器关闭(配置了容器 shouldUnregisterOnShutdown=true)</span></span><br><span class="line">1.在 DiscoveryClient<span class="comment">#shutdown() 中根据 shouldUnregisterOnShutdown 判断是否需要注销</span></span><br><span class="line">2.然后在 unregister() 中调用 RestTemplateEurekaHttpClient<span class="comment">#cancel() </span></span><br><span class="line">3.cancel() 中使用 restTemplate 构造 Method 为 DELETE, URL 为 serviceUrl + <span class="string">"apps/"</span> + appName + <span class="string">'/'</span> + id 的请求并发送给 Eureka server 告知其注销 appName 下对应的服务实例(根据 id).</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收到容器关闭事件</span></span><br><span class="line">1.EurekaClientAutoConfiguration 让容器里注册了一个 EurekaAutoServiceRegistration.</span><br><span class="line">2.这个类即是 SmartLifecycle(与容器生命周期绑定), 也是 SmartApplicationListener(监听容器加载/关闭事件)</span><br><span class="line">3.因此其对应的 start()/stop() 和 onApplicationEvent() 都实现了对应的逻辑.</span><br><span class="line">4.如 stop() 的逻辑为调用 EurekaServiceRegistry<span class="comment">#deregister()</span></span><br><span class="line">5.deregister() 的作用是执行 ApplicationInfoManager<span class="comment">#setInstanceStatus() 将状态改为 DOWN</span></span><br><span class="line">6.因为 ApplicationInfoManager 这个类专门管理状态变化事件, 因此还会将事件发布出去. </span><br><span class="line">7.而在 initScheduledTasks 中就添加了这样的一个监听者, 起作用为调用 InstanceInfoReplicator<span class="comment">#onDemandUpdate()</span></span><br><span class="line">8.接着会调用 InstanceInfoReplicator<span class="comment">#run(), 第一行代码 refreshInstanceInfo() 会确保状态为最新的(那也还是 DOWN)</span></span><br><span class="line">9.但是其最终并不是调用 cancel 注销, 而 register 注册, 不过其中的状态是 DOWN, 因此会有 server 那边判断; 所以容器关闭事件并不会触发 cancel, 但效果应是一样的.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 要么是 shutdown() 中 unregister 调用了 cancel(), 发出了 Method 为 DELETE 的请求来注销; 要么就是 EurekaClientAutoConfiguration 中与容器生命周期做关联, 全程使用 register 接口来更新状态.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A(容器关闭#close)</span><br><span class="line">A1(DiscoveryClient#shutdown)</span><br><span class="line">A2(DiscoveryClient#unregister)</span><br><span class="line">A3(RestTemplateEurekaHttpClient#cancel)</span><br><span class="line">A4(RestTemplate)</span><br><span class="line">A5(Eureka Server) </span><br><span class="line"></span><br><span class="line">A--触发--&gt;A1</span><br><span class="line">A1--调用--&gt;A2</span><br><span class="line">A2--调用--&gt;A3</span><br><span class="line">A3--构造HTTP请求交给--&gt;A4</span><br><span class="line">A4--发送注销申请给--&gt;A5</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210129171241.png" alt="image-20210129171237603"></p>
<h3 id="服务发现流程"><a href="#服务发现流程" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Spring Cloud Commons 中注册了一个 ServiceInstanceListSupplier, 具体为(DiscoveryClientServiceInstanceListSupplier)</span><br><span class="line">2.这个类的作用是借助 ReactiveDiscoveryClient 的 getInstances(String serviceId) 方法向 LoadBalancer 提供从具体的 server(如Eureka) 获取服务实例对象列表, 这样只要实现 ReactiveDiscoveryClient 并放入容器就可以和 Spring cloud LoadBalancer 对接了.</span><br><span class="line">3.在 EurekaDiscoveryClientConfiguration 中让容器注册了一个 DiscoveryClient(具体为 EurekaDiscoveryClient).</span><br><span class="line">4.因为 Spring Cloud Commons 做了大量的预备对接工作, 所以对接其实就结束了.</span><br><span class="line">5.那再简单说下 EurekaDiscoveryClient 的实现, 即注入一个 EurekaClient eurekaClient, 然后调用 DiscoveryClient<span class="comment">#getInstancesByVipAddress() 就获取到了 ServiceInstance 列表.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: Commons 中准备好了对接的方式: 实现 DiscoveryClient 接口, 接着我们的确实现了 DiscoveryClient 接口, 即 EurekaDiscoveryClient, 而这这个类则会调用 EurekaClient 的 getInstancesByVipAddress 从 Eureka Server 端获取注册了的服务实例信息.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line"></span><br><span class="line">A1(BlockingLoadBalancerClient#位于Commons项目)</span><br><span class="line">A2(RoundRobinLoadBalancer#位于Commons项目)</span><br><span class="line">A4(LoadBalancerClientConfiguration#位于Commons项目)</span><br><span class="line">A5(DiscoveryClientServiceInstanceListSupplier)</span><br><span class="line">A6(EurekaDiscoveryClient#getInstances)</span><br><span class="line">A7(EurekaClient#getInstancesByVipAddress)</span><br><span class="line">A9(Eureka Server)</span><br><span class="line">A8(ServiceInstance 集合)</span><br><span class="line"></span><br><span class="line">A1--choose 方法调用--&gt;A2</span><br><span class="line">A2--choose 方法调用--&gt;A5</span><br><span class="line">A4--注入一个--&gt;A5</span><br><span class="line">A5--调用--&gt;A6</span><br><span class="line">A6--调用--&gt;A7</span><br><span class="line">A7--从--&gt;A9</span><br><span class="line">A9--获取--&gt;A8</span><br><span class="line">A10(EurekaDiscoveryClientConfiguration)--注入一个--&gt;A6</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210129233856.png" alt="image-20210129233854498"></p>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><h3 id="关键类-1"><a href="#关键类-1" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">1.ConsulAutoServiceRegistrationAutoConfiguration</span><br><span class="line">	负责添加自动注册/注销相关的 bean</span><br><span class="line">	注册了 ConsulAutoServiceRegistration/ConsulAutoServiceRegistrationListener/ConsulAutoRegistration</span><br><span class="line">	</span><br><span class="line">2.ConsulServiceRegistryAutoConfiguration</span><br><span class="line">	负责注册服务注册相关的 bean</span><br><span class="line">	注册了 ConsulServiceRegistry</span><br><span class="line">	</span><br><span class="line">3.ConsulDiscoveryClientConfiguration</span><br><span class="line">	负责注册服务发现相关的 bean</span><br><span class="line">	注册了 ConsulDiscoveryClient</span><br><span class="line">	</span><br><span class="line">4.ConsulServiceRegistry</span><br><span class="line">	负责与 ConsulClient 对接, 再提供注册/注销功能</span><br><span class="line"></span><br><span class="line">5.ConsulClient</span><br><span class="line">	与 Consul Server 端交互</span><br><span class="line">	负责向 Consul Server 端注册/注销服务实例</span><br><span class="line"></span><br><span class="line">6.AgentConsulClient</span><br><span class="line">	负责根据服务实例信息构造注册/注销的 Http 请求</span><br><span class="line">	</span><br><span class="line">7.ConsulAutoServiceRegistration/ConsulAutoServiceRegistrationListener</span><br><span class="line">	负责管理服务实例的自动注册/注销, 与容器生命周期挂钩</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务发现</span></span><br><span class="line">1.BlockingLoadBalancer (Commons 项目上)</span><br><span class="line">	负责调用实际的负载均衡器去选择一个服务实例</span><br><span class="line">	负责调度负载均衡整个过程, 触发相应的生命周期.</span><br><span class="line">	</span><br><span class="line">2.RoundRobinLoadBalancer (Commons 项目上)</span><br><span class="line">	实际的负载均衡策略算法类</span><br><span class="line">	负责连接 ServiceInstanceListSupplier 从其中获取服务实例列表</span><br><span class="line"></span><br><span class="line">3.ServiceInstanceListSupplier</span><br><span class="line">	定义了获取服务实例实例列表的接口(任意方式)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClient</span><br><span class="line">	定义了从服务端获取服务实例列表的接口(更明确了)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClientServiceInstanceListSupplier</span><br><span class="line">	ServiceInstanceListSupplier 的实现类</span><br><span class="line">	连接 ReactiveDiscoveryClient 类, 将服务端获取道德服务实例列表返回出去</span><br><span class="line">	</span><br><span class="line">5.ConsulDiscoveryClient</span><br><span class="line">	实现了 DiscoveryClient 接口</span><br><span class="line">	负责调用 ConsulClient 从 Consul Server 端获取服务实例列表.</span><br><span class="line"></span><br><span class="line">6.ConsulClient</span><br><span class="line">	与 Consul Server 端交互</span><br><span class="line">	负责向 Consul Server 端获取服务实例列表</span><br><span class="line"></span><br><span class="line">7.ConsulServiceInstance</span><br><span class="line">	服务实例信息对象</span><br><span class="line">	实现 ServiceInstance, 与 Commons 对接</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">实现了 Commons 的 DiscoveryClient 接口(即 ConsulDiscoveryClient), 于是服务发现实现了;</span><br><span class="line">实现了 Commons 的 ServiceRegisty 接口(即 ConsulServiceRegistry), 于是服务注册也实现了.</span><br><span class="line">再总结: Commons 大发好.</span><br></pre></td></tr></table></figure>

<h3 id="服务注册流程-1"><a href="#服务注册流程-1" class="headerlink" title="服务注册流程"></a>服务注册流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.ConsulAutoServiceRegistration 调用 org.springframework.cloud.consul.serviceregistry.ConsulServiceRegistry<span class="comment">#register() 完成注册</span></span><br><span class="line">2.接着 register() 调用 ConsulClient<span class="comment">#agentServiceRegister()</span></span><br><span class="line">3.然后会调用 AgentConsulClient<span class="comment">#agentServiceRegister()</span></span><br><span class="line">4.生成并发送请求, 请求地址为 /v1/agent/service/register</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 其实和 Eureka 差不多, 只是我跳过了一点点细节. 基本是就是 与 ServiceRegistry 交互了, 非常的配合 Commons 项目, 就像一个人写的一样…</p>
</blockquote>
<h3 id="服务发现流程-1"><a href="#服务发现流程-1" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先是 DiscoveryClientServiceInstanceListSupplier 会调用 ConsulDiscoveryClient<span class="comment">#getInstances()</span></span><br><span class="line">2.接着 getInstances() 会调用 ConsulClient<span class="comment">#getHealthServices()</span></span><br><span class="line">3.然后就是发送 HTTP 请求了, 请求地址为 /v1/health/service/, 返回的对象封装处理下得到 ServiceInstance 的实现类 ConsulServiceInstance.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 这次真的是和 Eureka 类似, 从 Commons 到 ConsulDiscoveryClient, 流程是一样的. 而其实 ConsulDiscoveryClient 的逻辑也和 EurekaDiscoverClient 类似… 只能说其实服务注册发现这个框架, 我们关注的功能其实并不是难点. 难点是 server 端的管理.</p>
</blockquote>
<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><h3 id="关键类-2"><a href="#关键类-2" class="headerlink" title="关键类"></a>关键类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line">1.NacosServiceRegistryAutoConfiguration</span><br><span class="line">	负责添加自动注册/注销相关的 bean</span><br><span class="line">	注册了 NacosAutoServiceRegistration/NacosServiceRegistry/NacosRegistration</span><br><span class="line">	</span><br><span class="line">2.NacosDiscoveryClientConfiguration</span><br><span class="line">	负责注册服务发现相关的 bean</span><br><span class="line">	注册了 NacosDiscoveryClient</span><br><span class="line">	</span><br><span class="line">3.NacosServiceRegistry</span><br><span class="line">	负责与 NamingService 对接, 再提供注册/注销功能</span><br><span class="line"></span><br><span class="line">4.NamingService</span><br><span class="line">	与 Nacos Server 端交互</span><br><span class="line">	负责向 Nacos Server 端注册/注销服务实例</span><br><span class="line">	调用 NamingProxy</span><br><span class="line"></span><br><span class="line">5.NamingProxy</span><br><span class="line">	负责根据服务实例信息构造注册/注销的 Http 请求</span><br><span class="line">	</span><br><span class="line">6.NacosAutoServiceRegistration</span><br><span class="line">	负责管理服务实例的自动注册/注销, 与容器生命周期挂钩</span><br><span class="line"></span><br><span class="line">7.NacosRegistration</span><br><span class="line">	本地实例对象, 相比服务实例数据更多</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务发现</span></span><br><span class="line">1.BlockingLoadBalancer (Commons 项目上)</span><br><span class="line">	负责调用实际的负载均衡器去选择一个服务实例</span><br><span class="line">	负责调度负载均衡整个过程, 触发相应的生命周期.</span><br><span class="line">	</span><br><span class="line">2.RoundRobinLoadBalancer (Commons 项目上)</span><br><span class="line">	实际的负载均衡策略算法类</span><br><span class="line">	负责连接 ServiceInstanceListSupplier 从其中获取服务实例列表</span><br><span class="line"></span><br><span class="line">3.ServiceInstanceListSupplier</span><br><span class="line">	定义了获取服务实例实例列表的接口(任意方式)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClient</span><br><span class="line">	定义了从服务端获取服务实例列表的接口(更明确了)</span><br><span class="line"></span><br><span class="line">4.DiscoveryClientServiceInstanceListSupplier</span><br><span class="line">	ServiceInstanceListSupplier 的实现类</span><br><span class="line">	连接 ReactiveDiscoveryClient 类, 将服务端获取道德服务实例列表返回出去</span><br><span class="line">	</span><br><span class="line">5.NacosDiscoveryClient</span><br><span class="line">	实现了 DiscoveryClient 接口</span><br><span class="line">	负责调用 NamingService 从 Nacos Server 端获取服务实例列表.</span><br><span class="line"></span><br><span class="line">6.NamingService</span><br><span class="line">	与 Nacos Server 端交互</span><br><span class="line">	负责向 Nacos Server 端获取服务实例列表</span><br><span class="line"></span><br><span class="line">7.NacosServiceInstance</span><br><span class="line">	服务实例信息对象</span><br><span class="line">	实现 ServiceInstance, 与 Commons 对接</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">实现了 Commons 的 DiscoveryClient 接口(即 NacosDiscoveryClient), 于是服务发现实现了;</span><br><span class="line">实现了 Commons 的 ServiceRegisty 接口(即 ConsulServiceRegistry), 于是服务注册也实现了.</span><br><span class="line">再总结: Commons 大发好.</span><br></pre></td></tr></table></figure>



<h3 id="服务注册流程-2"><a href="#服务注册流程-2" class="headerlink" title="服务注册流程"></a>服务注册流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.NacosAutoServiceRegistration 调用 NacosServiceRegistry<span class="comment">#register 完成注册</span></span><br><span class="line">2.接着 register() 调用 NacosNamingService<span class="comment">#registerInstance()</span></span><br><span class="line">3.然后会调用 NamingProxy<span class="comment">#registerService()</span></span><br><span class="line">4.生成并发送请求, 请求地址为 /nacos/v1/ns/instance</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 这和 Consul 差不多; 还是继承 AbstractAutoServiceRegistration 来与 ServiceRegistry 交互了, 也是非常的配合 Commons 项目啊!!</p>
</blockquote>
<h3 id="服务发现流程-2"><a href="#服务发现流程-2" class="headerlink" title="服务发现流程"></a>服务发现流程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先是 DiscoveryClientServiceInstanceListSupplier 会调用 NacosDiscoveryClient<span class="comment">#getInstances()</span></span><br><span class="line">2.接着 getInstances() 会调用 NacosServiceDiscovery<span class="comment">#getInstances()</span></span><br><span class="line">3.然后就是发送 HTTP 请求了, 请求地址为 /nacos/v1/ns/instance/list, 返回的对象封装处理下得到 ServiceInstance 的实现类 NacosServiceInstance.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 依然是和 Eureka/Consul 类似, 从 Commons 到 NacosDiscoveryClient, 流程是一样的. 而其实 NacosDiscoveryClient 的逻辑也和 ConsulDiscoveryClient/EurekaDiscoverClient 类似, 最终总是发起 HTTP 查询 server 端, 所以 server 端的代码才比较有趣啊.</p>
</blockquote>
<h2 id="Nacos-Config"><a href="#Nacos-Config" class="headerlink" title="Nacos Config"></a>Nacos Config</h2><h3 id="Nacos-Config-Client-加载-nacos-server-配置原理"><a href="#Nacos-Config-Client-加载-nacos-server-配置原理" class="headerlink" title="Nacos Config Client 加载 nacos server 配置原理"></a>Nacos Config Client 加载 nacos server 配置原理</h3><h4 id="关键类-3"><a href="#关键类-3" class="headerlink" title="关键类"></a>关键类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.NacosConfigBootstrapConfiguration</span><br><span class="line">	注册了一个 NacosPropertySourceLocator</span><br><span class="line"></span><br><span class="line">2.NacosPropertySourceLocator</span><br><span class="line">	用于从 nacos server 上加载 dataId 对应的配置文件到 environment 的 PropertySource 集合中.</span><br><span class="line">	</span><br><span class="line">3.ConfigService</span><br><span class="line">	用于与 nacos server 通信, 获取配置文件, 乃至订阅更新</span><br><span class="line">	</span><br><span class="line">4.NacosPropertySourceBuilder</span><br><span class="line">	借助 ConfigService 与 NacosDataParserHandler 从 nacos 获取 NacosPropertySource</span><br><span class="line">	</span><br><span class="line">5.NacosDataParserHandler</span><br><span class="line">	用于序列化(转码)服务端的配置文件数据为一个 PropertySource(即 NacosPropertySource)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动刷新</span></span><br><span class="line">1.NacosConfigAutoConfiguration</span><br><span class="line">2.NacosContextRefresher</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: ConfigService 与 NacosDataParserHandler 是两个干事的, 其他都是渣渣!!!</p>
</blockquote>
<h4 id="从-server-获取配置流程"><a href="#从-server-获取配置流程" class="headerlink" title="从 server 获取配置流程"></a>从 server 获取配置流程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.在 NacosConfigBootstrapConfiguration 中注册了一个 PropertySourceLocator(即 NacosPropertySourceLocator), 可用于为 environment 添加 PropertySource</span><br><span class="line">2.然后实现 locate 方法, 即 NacosPropertySourceLocator<span class="comment">#locate()</span></span><br><span class="line">3.在 locate() 的最后面, 调用了 loadApplicationConfiguration()</span><br><span class="line">4.这个方法通过多次调用 loadNacosDataIfPresent() 加载 dataId 和不同文件后缀以及profile 组和得到不同的 dataId.</span><br><span class="line">5.loadNacosDataIfPresent() 调用了 loadNacosPropertySource()</span><br><span class="line">6.其最终调用了 NacosPropertySourceBuilder<span class="comment">#loadNacosData()</span></span><br><span class="line">7.loadNacosData() 调用 ConfigService<span class="comment">#getConfig() </span></span><br><span class="line">8.getConfig() 会使用 ClientWorker<span class="comment">#getServerConfig() 发起 HTTP 请求从 nacos server 获取配置文件. 其请求地址是 /v1/cs/configs</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 还是挺简单的, 发个 HTTP 获取配置文件, 然后转化成一个 PropertySource, 再在 NacosPropertySourceLocator 的 locate 中扔进 environment 中去. Bingo!!!</p>
</blockquote>
<h4 id="从-server-实时更新原理"><a href="#从-server-实时更新原理" class="headerlink" title="从 server 实时更新原理"></a>从 server 实时更新原理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.在 NacosConfigAutoConfiguration 注册了一个 NacosContextRefresher</span><br><span class="line">2.其实现了 ApplicationListener&lt;ApplicationReadyEvent&gt;, 也就是会在容器准备事件触发后调用 NacosContextRefresher<span class="comment">#registerNacosListenersForApplications()</span></span><br><span class="line">3.在进行两个配置判断后(即 isRefreshEnabled() 和 PropertySource 的 isRefreshable), 调用 NacosContextRefresher<span class="comment">#registerNacosListener() </span></span><br><span class="line">4.这个方法通过 NacosConfigService<span class="comment">#addListener() 注册一个 AbstractSharedListener 监听者到 cacheData.</span></span><br><span class="line">5.而 ClientWorker<span class="comment">#checkConfigInfo() 中添加的 LongPollingRunnable 任务, 会在 run() 中执行 getServerConfig() 获取服务配置文件, 然后与当前缓存对比 md5, 若更新则通过 cacheData 取出刚刚添加的 listener, 触发事件(即 receiveConfigInfo() )</span></span><br><span class="line">6.触发后又会再发布一个 RefreshEvent 事件</span><br><span class="line">7.接着流转到 RefreshEventListener.onApplicationEvent()</span><br><span class="line">8.然后又会调用 ContextRefresher.refresh(), 这个方法中的 refreshEnvironment() 会调用 addConfigFilesToEnvironment(), 这方法先复制一个 StandardEnvironment, 将其放入到 SpringApplication 中, 再调用 SpringApplication 的 run() 走一遍, 会触发 NacosPropertySourceLocator.locate(), 于是复制的 environment 里面有新数据了, 再将其拷贝替换到当前的 environment. 完成 environment 的刷新. </span><br><span class="line">9.接着发布一个 EnvironmentChangeEvent 事件, 用来刷新 @ConfigurationProperties 注解的 Bean. (这么喜欢事件?不愧是写出 RocketMQ 的阿里啊!!!)</span><br><span class="line">10.接着在 ConfigurationPropertiesRebinder 中接收到这个事件, 触发 onApplicationEvent()</span><br><span class="line">11.然后会执行 ConfigurationPropertiesRebinder<span class="comment">#rebind()</span></span><br><span class="line">12.其逻辑是将 postProcessBeforeInitialization 中存起来的 ConfigurationPropertiesBean 类型的 map 遍历, 进行重新绑定(即 destroyBean 后再 initializeBean, 则会从新配置重新赋值).</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 有的地方(NacosContextRefresher)监听容器初始化添加配置更新的监听者, 自己不干活只发布配置刷新事件;</p>
<p>有的地方(ClientWorker)添加轮询任务获取服务端配置文件与本地 cacheData 对比 md5 来判断是否触发配置更新的监听者;</p>
<p>然后有的地方(RefreshEventListener)监听配置刷新事件然后用 SpringApplication.run() 通过触发 NacosPropertySourceLocator#locate() 为一个复制出来的 environment 对象添加从服务端获取最新配置, 再拷贝到当前的 environment 对象, 完成 environment 配置的刷新, 之后发布 environment 刷新事件;</p>
<p>有的地方(ConfigurationPropertiesRebinder)监听 environment 刷新事件, 然后为 @ConfigurationProperties 注解生成的 bean 重新绑定配置.</p>
<p>再总结: 挺好的, 奥运火炬手啊这是, 不停传递!!!!!</p>
</blockquote>
<h4 id="关键类-4"><a href="#关键类-4" class="headerlink" title="关键类"></a>关键类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.NacosConfigAutoConfiguration</span><br><span class="line">	注册一个监听容器初始化事件的 bean (NacosContextRefresher)</span><br><span class="line"></span><br><span class="line">2.NacosContextRefresher</span><br><span class="line">	再初始化事件触发后添加一个 AbstractSharedListener 监听者到 cacheData</span><br><span class="line"></span><br><span class="line">3.AbstractSharedListener</span><br><span class="line">	当服务端配置与本地不同后触发</span><br><span class="line">	触发后发布 RefreshEvent 事件</span><br><span class="line"></span><br><span class="line">4.CacheData</span><br><span class="line">	管理配置更新事件监听者</span><br><span class="line">	对比服务端配置与本地配置的 md5</span><br><span class="line">	md5 不同则触发 AbstractSharedListener</span><br><span class="line">	</span><br><span class="line">5.RefreshEvent</span><br><span class="line">	通过容器发布</span><br><span class="line">	当服务端配置发送更新触发</span><br><span class="line">	触发后调用 ContextRefresher<span class="comment">#refresh()</span></span><br><span class="line">	</span><br><span class="line">6.LongPollingRunnable</span><br><span class="line">	轮询任务, 获取服务端最新配置, 与 cacheData 对比</span><br><span class="line"></span><br><span class="line">7.ClientWorker</span><br><span class="line">	管理轮询任务(LongPollingRunnable)</span><br><span class="line">	负责与 nacos 服务端通信</span><br><span class="line">	</span><br><span class="line">8.ContextRefresher</span><br><span class="line">	监听 RefreshEvent 事件</span><br><span class="line">	负责获取服务端最新配置到 environment 对象中</span><br><span class="line">	发布 EnvironmentChangeEvent 事件</span><br><span class="line">	</span><br><span class="line">9.EnvironmentChangeEvent</span><br><span class="line">	通过容器发布</span><br><span class="line">	当 environment 对象更新后触发</span><br><span class="line">	触发后调用 ConfigurationPropertiesRebinder<span class="comment">#rebind()</span></span><br><span class="line">	</span><br><span class="line">10.ConfigurationPropertiesRebinder</span><br><span class="line">	监听 EnvironmentChangeEvent 事件</span><br><span class="line">	负责重新绑定用了 @ConfigurationProperties 注解的 Bean 的值</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A1(NacosConfigAutoConfiguration)</span><br><span class="line">A2(NacosContextRefresher)</span><br><span class="line">A3(ApplicationReadyEvent)</span><br><span class="line">A4(NacosContextRefresher#registerNacosListener)</span><br><span class="line">A5(NacosConfigService#addListener)</span><br><span class="line"> </span><br><span class="line">A7(ClientWorker)</span><br><span class="line">A8(LongPollingRunnable#轮询任务)</span><br><span class="line">A9(NacosConfigService#getServerConfig)</span><br><span class="line">B1(AbstractSharedListener#配置更新事件的监听者)</span><br><span class="line">B2(cacheData)</span><br><span class="line">B3(RefreshEvent)</span><br><span class="line">B4(RefreshEventListener)</span><br><span class="line">B5(ContextRefresher#refresh)</span><br><span class="line">B6(ContextRefresher#refreshEnvironment)</span><br><span class="line">B7(ContextRefresher#addConfigFilesToEnvironment)</span><br><span class="line">B8(SpringApplication#run)</span><br><span class="line">B9(StandardEnvironment)</span><br><span class="line">C1(NacosPropertySourceLocator#locate)</span><br><span class="line">C2(当前容器的 environment 对象)</span><br><span class="line">C3(EnvironmentChangeEvent)</span><br><span class="line">C4(ConfigurationPropertiesRebinder#onApplicationEvent)</span><br><span class="line">C5(ConfigurationPropertiesRebinder#rebind)</span><br><span class="line">C6(用了 ConfigurationProperties 注解 Bean)</span><br><span class="line"></span><br><span class="line">A1--注册了一个--&gt;A2</span><br><span class="line">A2--监听了--&gt;A3</span><br><span class="line">A3--事件触发后调用--&gt;A4</span><br><span class="line">A4--通过--&gt;A5</span><br><span class="line">A5--注册了一个--&gt;B1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">A7--构造方法中创建了一个--&gt;A8</span><br><span class="line">A8--run 方法中调用--&gt;A9</span><br><span class="line">A9--获取最新配置与--&gt;B2</span><br><span class="line"></span><br><span class="line">B2--比较 md5, 不同则触发--&gt;B1</span><br><span class="line">B1--事件触发后发布--&gt;B3</span><br><span class="line">B4--监听了--&gt;B3</span><br><span class="line">B3--事件触发后调用--&gt;B5</span><br><span class="line">B5--调用--&gt;B6</span><br><span class="line">B6--调用--&gt;B7</span><br><span class="line">B7--利用--&gt;B8</span><br><span class="line">B7--复制当前容器 environment 对象到--&gt;B9</span><br><span class="line">B8--触发--&gt;C1</span><br><span class="line">C1--获取了最新配置到--&gt;B9</span><br><span class="line">B9--复制最新配置回到--&gt;C2</span><br><span class="line"></span><br><span class="line">C2--更新完配置后发布--&gt;C3</span><br><span class="line">G1(ConfigurationPropertiesRebinder)--监听了--&gt;C3</span><br><span class="line">C3--事件触发后调用--&gt;C4</span><br><span class="line">C4--调用--&gt;C5</span><br><span class="line">C5--获取新配置绑定到--&gt;C6</span><br></pre></td></tr></table></figure>





<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210130001118.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/28/source-code-spring-cloud-openfeign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/28/source-code-spring-cloud-openfeign/" class="post-title-link" itemprop="url">Spring Cloud Openfeign 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-28 13:59:51" itemprop="dateCreated datePublished" datetime="2021-01-28T13:59:51+08:00">2021-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:51:05" itemprop="dateModified" datetime="2021-03-28T19:51:05+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud/" itemprop="url" rel="index"><span itemprop="name">spring-cloud</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/28/source-code-spring-cloud-openfeign/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/28/source-code-spring-cloud-openfeign/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Cloud-Openfeign-源码笔记"><a href="#Spring-Cloud-Openfeign-源码笔记" class="headerlink" title="Spring Cloud Openfeign 源码笔记"></a>Spring Cloud Openfeign 源码笔记</h1><h2 id="关键类分析"><a href="#关键类分析" class="headerlink" title="关键类分析"></a>关键类分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.FeignAutoConfiguration</span></span><br><span class="line">  配置了一个管理 feign 子容器的工厂(FeignContext). </span><br><span class="line">  配置一个 Targeter, 直接中专 fegin 的 target 方法(DefaultTargeter, 这里扩展可以实现降级哦)</span><br><span class="line">  配置了一个 feign client (ApacheHttpClient), 用于执行 HTTP 请求</span><br><span class="line">  还配备了 ok http client 方式的 feign client, 但默认不启用</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.FeignClientsRegistrar</span></span><br><span class="line">  被 @EnableFeignClients 引入</span><br><span class="line">  扫描带 @FeignClient 注解的接口, 生成代理对象(FeignClientFactoryBean)注册到容器中</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.FeignClientFactoryBean</span></span><br><span class="line">  继承自 FactoryBean, Spring 的东西, getBean() 时调用跳转到 getObject()</span><br><span class="line">  getObject() 会调用通过 feign 对象生成代理对象</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.FeignInvocationHandler</span></span><br><span class="line">	JDK 动态代理生成对象的的方法拦截器</span><br><span class="line">	通过调用 SynchronousMethodHandler 的 invoke() 实现发送请求的功能</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.SynchronousMethodHandler</span></span><br><span class="line">	invoke() 会调用 FeignBlockingLoadBalancerClient 的 execute() 通过负载均衡获取 url 再调用 ApacheHttpClient 的 execute() 发送带实际 url 的 HTTP 请求.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.ParseHandlersByName</span></span><br><span class="line">	具有核心方法 apply, 解析 @FeignClient 接口的所有方法的注解和参数信息, 转化为 RequestTemplate, 可用于构造 HTTP 请求对象. 转化后的信息存于 SynchronousMethodHandler 字段中.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.FeignBlockingLoadBalancerClient</span></span><br><span class="line">	execute() 会调用 LoadBalancerClient 的 choose() 根据 serviceId(即 HTTP 的 host) 获取 url.</span><br><span class="line">	还负责调用 ApacheHttpClient 的 execute() 真正的发送 HTTP 请求.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.LoadBalancerClient</span></span><br><span class="line">  commons 下 loadbalancer 项目的老伙计了... 干啥的来着? 忘了</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9.ApacheHttpClient</span></span><br><span class="line">	负责发送 HTTP 请求.</span><br></pre></td></tr></table></figure>



<h2 id="openfeign-原理-EnableFeignClients-生效步骤"><a href="#openfeign-原理-EnableFeignClients-生效步骤" class="headerlink" title="openfeign 原理(@EnableFeignClients 生效步骤)"></a>openfeign 原理(@EnableFeignClients 生效步骤)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.先解析 @EnableFeignClients 导入 FeignClientsRegistrar.class</span><br><span class="line">2.FeignClientsRegistrar 将扫描带 @FeignClient 注解的接口, 注册到容器中</span><br><span class="line">3.注册进容器的是一个 FeignClientFactoryBean</span><br><span class="line">4.FeignClientFactoryBean 其本质是一个 FactoryBean, 会在被 getBean() 时调用 getObject()</span><br><span class="line">5.getObject() 会从容器中取 Feign.Builder builder 对象再根据配置文件进行配置 </span><br><span class="line">6.接着会走 Targeter 对象(默认为 DefaultTargeter)的 target(), 其默认为 builder.target(target); 其中 builder 为 Feign.Builder 对象, target 为 <span class="built_in">type</span>(class), name(serviceId), url(http://name/path)</span><br><span class="line">7.target() 会先调用 build()生成一个 feign 对象, 再调用 feign.newInstance(target) 生成一个代理对象</span><br><span class="line">8.先看 build() 方法, 初始化了重要属性 targetToHandlersByName, 值为 new ParseHandlersByName(), 这个类的 apply() 会在过一会用到. apply() 逻辑是遍历挨个解析方法上的注解(如@RequestMapping, @RequestParam, @PathVariable等等)和参数, 转化后包装成 HTTP 请求相关的实体类, 存到 SynchronousMethodHandler 的字段中, 再返回 SynchronousMethodHandler 对象存到 map 里.</span><br><span class="line">9.再看 feign.newInstance(), 先调用刚说的重要属性 targetToHandlersByName.apply(), 获得一个 map, 里面键大致为类名+方法名+形参组成, 值是 SynchronousMethodHandler 对象(见 SynchronousMethodHandler.Factory.create()), 然后遍历代理类的所有方法, 将方法所对应的 SynchronousMethodHandler 从 map 中取出再存到另一个 map, 这个 map 的键则为 method; 接着使用 JDK 动态代理生成一个代理对象, 其用于拦截方法的类 InvocationHandler 具体为 FeignInvocationHandler, 这个类里面的 invoke 逻辑很简单, 先排除 Object 通用的方法的影响, 对于正常方法会调用 SynchronousMethodHandler 的 invoke()... 闹了半天就是个中转呗, 有类的 Handler 到了方法的 MethodHandler.</span><br><span class="line">10.SynchronousMethodHandler 的 invoke() 的核心代码是 this.client.execute(), 这里会走到 feign.Client 的具体实现类. 可能是 ApacheHttpClient(当 url 有地址时), 那就直接执行请求了, 也可能是 FeignBlockingLoadBalancerClient, 那么会调用 loadBalancerClient 的 choose 方法获取 url, 再执行 feignClient.execute(), 这次这个 feignClient 则肯定是 ApacheHttpClient 了, 于是最终就这样发送了请求.</span><br><span class="line"></span><br><span class="line"><span class="comment">#PS: </span></span><br><span class="line">有人问我(无中生友)发送的 HTTP 请求怎么构建? </span><br><span class="line">其实我上面说的很清楚了, 关键就在于 apply(), 好吧, 我说的具体一点... 关键在于 SpringMvcContract<span class="comment">#parseAndValidateMetadata()</span></span><br><span class="line">这个的入口在 apply() 的第一行, this.contract.parseAndValidateMetadata() 一直往里跳转, 就会进入 SpringMvcContract...  具体代码挺多的... 真的没必要细读... 因为其本身只相当于一个工具类, 而读源码应该放眼大局, 否则每段代码都认真读, 那太难了!!!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 扫描 @FeignClient, 生成代理对象, 扔进容器. 拦截代理对象的方法, 调用方法对应的 SynchronousMethodHandler, 此类调用之前解析好的 RequestTemplate 生成请求对象, 再通过 Client 执行请求, 若配置了负载均衡, 则会调用 LoadBalancerClient 将 serviceId 先解析成具体的地址再转交给 ApacheHttpClient 执行请求.</p>
</blockquote>
<h2 id="代理对象的生成步骤"><a href="#代理对象的生成步骤" class="headerlink" title="代理对象的生成步骤"></a>代理对象的生成步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A1(FeignClientFactoryBean)</span><br><span class="line">A2(Feign.Builder)</span><br><span class="line">A3(Feign)</span><br><span class="line">A4(FeignInvocationHandler)</span><br><span class="line">A5(SynchronousMethodHandler)</span><br><span class="line">A6(FeignBlockingLoadBalancerClient)</span><br><span class="line">A7(ApacheHttpClient)</span><br><span class="line">A8(LoadBalancerClient)</span><br><span class="line">A9(ServiceInstance)</span><br><span class="line">A10(Response)</span><br><span class="line">A11(Decoder 链)</span><br><span class="line"></span><br><span class="line">A1--getObject 触发--&gt;A2</span><br><span class="line">A2--build 得到--&gt;A3</span><br><span class="line">A3--Proxy.newProxyInstance 用到--&gt;A4</span><br><span class="line">A4--invoke 里调用--&gt;A5</span><br><span class="line">A5--invoke 里调用--&gt;A6</span><br><span class="line">A6--execute 中先调用 --&gt;A8</span><br><span class="line">A6--execute 中后调用--&gt;A7</span><br><span class="line">A8--获取--&gt;A9</span><br><span class="line">A7--得到--&gt;A10</span><br><span class="line">A10--交给--&gt;A11</span><br><span class="line">A11--编码得到--&gt;A12(json)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210128204558.png" alt="iShot2021-01-28 20.45.21"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/27/source-code-spring-cloud-ribbon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/27/source-code-spring-cloud-ribbon/" class="post-title-link" itemprop="url">Spring Cloud Commons 之 loadbalancer 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-27 13:10:01" itemprop="dateCreated datePublished" datetime="2021-01-27T13:10:01+08:00">2021-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:50:52" itemprop="dateModified" datetime="2021-03-28T19:50:52+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-cloud/" itemprop="url" rel="index"><span itemprop="name">spring-cloud</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/27/source-code-spring-cloud-ribbon/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/27/source-code-spring-cloud-ribbon/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Cloud-Commons-之-loadbalancer-源码笔记"><a href="#Spring-Cloud-Commons-之-loadbalancer-源码笔记" class="headerlink" title="Spring Cloud Commons 之 loadbalancer 源码笔记"></a>Spring Cloud Commons 之 loadbalancer 源码笔记</h1><blockquote>
<p>Spring Cloud Commons 是什么样的? 有什么作用? 如何与 Spring Cloud 和 Cloud Alibaba 整合?<br>让我们带着这些问题去研究源码吧! </p>
</blockquote>
<h2 id="loadbalancer-原理分析"><a href="#loadbalancer-原理分析" class="headerlink" title="loadbalancer 原理分析"></a>loadbalancer 原理分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先来认识一下 Spring Cloud Commons 吧</span></span><br><span class="line">是定义了诸多接口(如ServiceRegistry/DiscoveryClient/LoadBalancerClient)和注解(如!EnableDiscoveryClient/@LoadBalanced)为主, 少量代码实现(如 RandomLoadBalancer). </span><br><span class="line">以及对 Spring 容器(Context) 的扩展(如 NamedContextFactory, bootstrap 配置文件的加载, 容器重启, 容器跟随配置文件刷新等等)</span><br><span class="line">当然还有一些打包好的 starter.</span><br><span class="line">我们要研究的 loadbalancer 就是其中一个子项目.</span><br></pre></td></tr></table></figure>



<h3 id="loadbalancer-关键类解析"><a href="#loadbalancer-关键类解析" class="headerlink" title="loadbalancer 关键类解析"></a>loadbalancer 关键类解析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0.惊! 一堆类仅为添加一个拦截器</span></span><br><span class="line">LoadBalancerRequestFactory: 一个工厂, 包装一个为请求对象 HttpRequest 加料的回调 LoadBalancerRequest</span><br><span class="line"></span><br><span class="line">LoadBalancerClient: 用于根据 serviceId 选取一个 ServiceInstance, 执行从 LoadBalancerRequestFactory 获得的那个回调</span><br><span class="line"></span><br><span class="line">LoadBalancerInterceptor: restTemplate 的拦截器, 拦截后调用 LoadBalancerClient 修改 HttpRequest 对象(主要是 url), 且传入调用 LoadBalancerRequestFactory 生成的回调给 LoadBalancerClient</span><br><span class="line"></span><br><span class="line">RestTemplateCustomizer: 为 restTemplate 加上一个拦截器(也可以干点别的, 默认就这一个用处)</span><br><span class="line"></span><br><span class="line">SmartInitializingSingleton: 调用 RestTemplateCustomizer 为容器中所有加了 @LoadBalanced 的 RestTemplate 加上一个拦截器</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.获取对象的工厂, 以 Spring 容器作为载体管理对象.</span></span><br><span class="line">NamedContextFactory</span><br><span class="line">	继承 DisposableBean, 用于类销毁是执行点东西(指创建的好多个子容器)</span><br><span class="line">	继承 ApplicationContextAware, 用于将子容器和当前容器关联起来(所以 Spring 树形扩展这个设计真不错)</span><br><span class="line">	泛型 C extends NamedContextFactory.Specification, 无它, 就是个 POJO, 存个 name 和对应的配置 class, 用于初始化容器的(会被注册进去, 然后解析里面的注解啥的...)</span><br><span class="line">	此类作用就是管理一大堆(取决于你微服务拆分的程度)子容器, 获取其他代码需要的类型对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReactiveLoadBalancer.Factory</span><br><span class="line">  定义了获取 ReactiveLoadBalancer 的接口以及与其相关的扩展</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">LoadBalancerClientFactory</span><br><span class="line">  继承 NamedContextFactory, 构造参数指定了几个属性值</span><br><span class="line">  实现了 ReactiveLoadBalancer.Factory 的接口, 即提供获取 ReactiveLoadBalancer 的方法.</span><br><span class="line">  泛型具体为 LoadBalancerClientSpecification, 还是个POJO</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.包含算法逻辑的负载均衡策略的类</span></span><br><span class="line">Response</span><br><span class="line">	server 的封装类, 一般持有一个 ServiceInstance 对象, 如 DefaultResponse</span><br><span class="line">	</span><br><span class="line">Publisher</span><br><span class="line">	响应式编程的东西, 可获取 Response&lt;T&gt; 对象, 一般为 Response&lt;ServiceInstance&gt;</span><br><span class="line">	</span><br><span class="line">ReactiveLoadBalancer.Factory</span><br><span class="line">	定义了获取 ReactiveLoadBalancer 的接口以及与其相关的扩展</span><br><span class="line"></span><br><span class="line">ReactiveLoadBalancer</span><br><span class="line">	定义了 choose 方法, 即如何选取一个 ServiceInstance, 如轮播, 随机...</span><br><span class="line"></span><br><span class="line">ReactorLoadBalancer</span><br><span class="line">  定义了 choose 方法的另一形式, 仅返回值不同, 为 Mono&lt;Response&lt;T&gt;&gt; 是 Publisher&lt;Response&lt;T&gt;&gt; 的子类, 返回值为抽象类.</span><br><span class="line"></span><br><span class="line">ReactorServiceInstanceLoadBalancer</span><br><span class="line">  继承 ReactorLoadBalancer</span><br><span class="line">	仅仅作为一个标记类, 无新接口</span><br></pre></td></tr></table></figure>



<h3 id="类大致调用图"><a href="#类大致调用图" class="headerlink" title="类大致调用图"></a>类大致调用图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A(SmartInitializingSingleton)</span><br><span class="line">A1(RestTemplateCustomizer)</span><br><span class="line">A2(LoadBalancerInterceptor)</span><br><span class="line">A3(restTemplate)</span><br><span class="line">A4(LoadBalancerClient)</span><br><span class="line">A5(LoadBalancerRequestFactory)</span><br><span class="line">A6(ReactorServiceInstanceLoadBalancer)</span><br><span class="line">A8(LoadBalancerClientFactory)</span><br><span class="line"></span><br><span class="line">A--调用--&gt;A1</span><br><span class="line">A1--添加一个--&gt;A2</span><br><span class="line">A2--到--&gt;A3</span><br><span class="line">A2--调用--&gt;A4</span><br><span class="line">A2--调用--&gt;A5</span><br><span class="line">A5--生成一个回调给--&gt;A4 </span><br><span class="line">A4--调用--&gt;A8</span><br><span class="line">A8--获取--&gt;A6</span><br><span class="line">A6--获取--&gt;A7(ServiceInstance)</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/gudqs7/many-images/raw/master/Mac-PicGo/20210127212226.png" alt="a copy"></p>
<blockquote>
<p>瞅瞅有哪些负载均衡策略吧(看完发现这才是最简单的… 外面那些结构反而不容易理清)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.RandomLoadBalancer: 就是随机数呗, 0-size, 简单!!</span></span><br><span class="line"><span class="comment">// 在 RandomLoadBalancer#getInstanceResponse() 中</span></span><br><span class="line"><span class="comment">// 觉得这个方法可以做出 protected, 这样有些实现只需要重写这个方法就行了 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Response&lt;ServiceInstance&gt; <span class="title">getInstanceResponse</span><span class="params">(List&lt;ServiceInstance&gt; instances)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">      log.warn(<span class="string">"No servers available for service: "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmptyResponse();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> index = ThreadLocalRandom.current().nextInt(instances.size());</span><br><span class="line"></span><br><span class="line">  ServiceInstance instance = instances.get(index);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultResponse(instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.RoundRobinLoadBalancer</span></span><br><span class="line"><span class="comment">// 在 RoundRobinLoadBalancer#getInstanceResponse() 中</span></span><br><span class="line"><span class="comment">// 用一个 position 保存位置, 这个主意高啊, 即保证了数据的正确性, 还.... 编不下去了!!</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Response&lt;ServiceInstance&gt; <span class="title">getInstanceResponse</span><span class="params">(List&lt;ServiceInstance&gt; instances)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instances.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">      log.warn(<span class="string">"No servers available for service: "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmptyResponse();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> enforce order?</span></span><br><span class="line">  <span class="keyword">int</span> pos = Math.abs(<span class="keyword">this</span>.position.incrementAndGet());</span><br><span class="line"></span><br><span class="line">  ServiceInstance instance = instances.get(pos % instances.size());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultResponse(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这代码简单的, 特别不想分析…. 但其实最开始就是冲着这个来的… 总得看看吧, 咳咳!!</p>
</blockquote>
<h3 id="loadbalancer-原理分析-1"><a href="#loadbalancer-原理分析-1" class="headerlink" title="loadbalancer 原理分析"></a>loadbalancer 原理分析</h3><ol>
<li>先拦截 RestTemplate 对象的请求, 使其调用 LoadBalancerClient 的接口获取真实IP</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration 中</span></span><br><span class="line">1.@Bean 加入一个 LoadBalancerRequestFactory, 并且带有用户自定义的 transformers(作用: 对选取真实 url 后的请求对象进行干预)</span><br><span class="line">2.@Bean 加入一个 LoadBalancerClient, 其作用是, 根据 serviceId 获取/选取真实 url, 以及执行请求</span><br><span class="line">3.@Bean 加入一个 LoadBalancerInterceptor, 即核心拦截器. 逻辑是: 获取 host, 调用 LoadBalancerRequestFactory 生成请求, 用 LoadBalancerClient 执行.</span><br><span class="line">4.@Bean 加入一个 RestTemplateCustomizer, 其作用是: 为给定的 RestTemplate 添加一个 LoadBalancerInterceptor.</span><br><span class="line">5.@Bean 加入一个 SmartInitializingSingleton, 作用是单例都加载后触发回调, 回调代码为:</span><br><span class="line">     遍历所有的 RestTemplateCustomizer 和 restTemplates, 用 RestTemplateCustomizer 对 RestTemplate 做设置. 包括(4)刚刚加入的那个.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 为用户自定义(如配置类中写了个@Bean + return new RestTemplate() 这种形式)的 RestTemplate 添加一个拦截器, 在请求执行前进行拦截, 然后将请求数据的 host 作为 serviceId, 接着使用某个具体的 LoadBalancerClient 实现类调用其方法获取真实的 url. 若对应存在多个 url, 由其算法策略决定如何选择.</p>
</blockquote>
<ol start="2">
<li>再看 LoadBalancerClient 的默认实现类(在 BlockingLoadBalancerClientAutoConfiguration 中配置的), 其逻辑是, 通过工厂获取 ReactorServiceInstanceLoadBalancer 对象并调用其接口执行负载均衡算法.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cloud.loadbalancer.blocking.client.BlockingLoadBalancerClient</span></span><br><span class="line"><span class="comment">// 先进入这个方法, 然后会调用第二个方法.</span></span><br><span class="line"><span class="comment">// 这两个方法其实就是从工厂获取对象执行 choose 后再让其完成请求的执行, 大部分代码都是 LoadBalancerLifecycle 的触发.</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历 LoadBalancerLifecycle 触发 onStart 钩子</span></span><br><span class="line">  <span class="comment">// 调用 choose 方法选取一个 IP:PORT 得到包装类 ServiceInstance</span></span><br><span class="line">  <span class="comment">// 遍历 LoadBalancerLifecycle 触发 onComplete 钩子</span></span><br><span class="line">  <span class="comment">// 执行请求</span></span><br><span class="line">  String hint = getHint(serviceId);</span><br><span class="line">  LoadBalancerRequestAdapter&lt;T, DefaultRequestContext&gt; lbRequest = <span class="keyword">new</span> LoadBalancerRequestAdapter&lt;&gt;(request,</span><br><span class="line">                                                                                                    <span class="keyword">new</span> DefaultRequestContext(request, hint));</span><br><span class="line">  Set&lt;LoadBalancerLifecycle&gt; supportedLifecycleProcessors = LoadBalancerLifecycleValidator</span><br><span class="line">    .getSupportedLifecycleProcessors(</span><br><span class="line">    loadBalancerClientFactory.getInstances(serviceId, LoadBalancerLifecycle<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">DefaultRequestContext</span>.<span class="title">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">ServiceInstance</span>.<span class="title">class</span>)</span>;</span><br><span class="line">  supportedLifecycleProcessors.forEach(lifecycle -&gt; lifecycle.onStart(lbRequest));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 serviceId 对应的容器中获取一个负载均衡算法实现类对象, 即 ReactorServiceInstanceLoadBalancer.</span></span><br><span class="line">  <span class="comment">// 调用其 choose 方法. 从响应中获取 ServiceInstance 并返回.</span></span><br><span class="line">  ServiceInstance serviceInstance = choose(serviceId, lbRequest);</span><br><span class="line">  <span class="keyword">if</span> (serviceInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    supportedLifecycleProcessors.forEach(lifecycle -&gt; lifecycle.onComplete(</span><br><span class="line">      <span class="keyword">new</span> CompletionContext&lt;&gt;(CompletionContext.Status.DISCARD, lbRequest, <span class="keyword">new</span> EmptyResponse())));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可以执行了</span></span><br><span class="line">  <span class="keyword">return</span> execute(serviceId, serviceInstance, lbRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历 LoadBalancerLifecycle 触发 onStartRequest 钩子</span></span><br><span class="line">  <span class="comment">// 调用 request.apply 方法执行请求(即进入之前 LoadBalancerRequestFactory 中的代码)</span></span><br><span class="line">  <span class="comment">// 遍历 LoadBalancerLifecycle 触发 onComplete 钩子</span></span><br><span class="line"></span><br><span class="line">  DefaultResponse defaultResponse = <span class="keyword">new</span> DefaultResponse(serviceInstance);</span><br><span class="line">  Set&lt;LoadBalancerLifecycle&gt; supportedLifecycleProcessors = LoadBalancerLifecycleValidator</span><br><span class="line">    .getSupportedLifecycleProcessors(</span><br><span class="line">    loadBalancerClientFactory.getInstances(serviceId, LoadBalancerLifecycle<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">    <span class="title">DefaultRequestContext</span>.<span class="title">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">ServiceInstance</span>.<span class="title">class</span>)</span>;</span><br><span class="line">  Request lbRequest = request <span class="keyword">instanceof</span> Request ? (Request) request : <span class="keyword">new</span> DefaultRequest&lt;&gt;();</span><br><span class="line">  supportedLifecycleProcessors</span><br><span class="line">    .forEach(lifecycle -&gt; lifecycle.onStartRequest(lbRequest, <span class="keyword">new</span> DefaultResponse(serviceInstance)));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 请求调用前先使用 transformers 对原始请求对象进行一些改变处理后再执行请求</span></span><br><span class="line">    T response = request.apply(serviceInstance);</span><br><span class="line">    Object clientResponse = getClientResponse(response);</span><br><span class="line">    supportedLifecycleProcessors</span><br><span class="line">      .forEach(lifecycle -&gt; lifecycle.onComplete(<span class="keyword">new</span> CompletionContext&lt;&gt;(CompletionContext.Status.SUCCESS,</span><br><span class="line">                                                                         lbRequest, defaultResponse, clientResponse)));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException iOException) &#123;</span><br><span class="line">    supportedLifecycleProcessors.forEach(lifecycle -&gt; lifecycle.onComplete(</span><br><span class="line">      <span class="keyword">new</span> CompletionContext&lt;&gt;(CompletionContext.Status.FAILED, iOException, lbRequest, defaultResponse)));</span><br><span class="line">    <span class="keyword">throw</span> iOException;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">    supportedLifecycleProcessors.forEach(lifecycle -&gt; lifecycle.onComplete(</span><br><span class="line">      <span class="keyword">new</span> CompletionContext&lt;&gt;(CompletionContext.Status.FAILED, exception, lbRequest, defaultResponse)));</span><br><span class="line">    ReflectionUtils.rethrowRuntimeException(exception);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>所以再看看工厂是怎么获取和存放对象的, 关键类: LoadBalancerClientFactory, 其继承自 NamedContextFactory</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先看其如何获取对象的 LoadBalancerClientFactory#getInstance()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReactiveLoadBalancer&lt;ServiceInstance&gt; <span class="title">getInstance</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从 serviceId 对应的容器中获取一个负载均衡算法实现类对象, 即 ReactorServiceInstanceLoadBalancer.</span></span><br><span class="line">  <span class="keyword">return</span> getInstance(serviceId, ReactorServiceInstanceLoadBalancer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getInstance(serviceId, ReactorServiceInstanceLoadBalancer.class):</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(String name, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  AnnotationConfigApplicationContext context = getContext(name);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> context.getBean(type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (NoSuchBeanDefinitionException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// getContext(name):</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">getContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.contexts) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.contexts.containsKey(name)) &#123;</span><br><span class="line">        <span class="comment">// 结论: 容器里有点东西, 但不多...  主要是于父容器打通... 所以又啥都有了.</span></span><br><span class="line">        <span class="keyword">this</span>.contexts.put(name, createContext(name));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.contexts.get(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createContext(name):</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AnnotationConfigApplicationContext <span class="title">createContext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.结合实现类 LoadBalancerClientFactory 做出如下注释</span></span><br><span class="line">  <span class="comment">// 1.将 LoadBalancerAutoConfiguration 扫描到 configurations 注册到 name 对应的容器中.</span></span><br><span class="line">  <span class="comment">//     这里的 name 其实就是 serviceId, 也就是说, 若我们想给某个容器加入一些东西, 则实现 LoadBalancerClientSpecification 时, name 需要与 serviceId 对应起来(相同)</span></span><br><span class="line">  <span class="comment">// 2.当我上面那句没说啊... 原来 name 为 default. 开头是可以加入任意 serviceId 对应的容器的.........................(qiao)</span></span><br><span class="line">  <span class="comment">// 3.为容器加入一个占位符解析器, 和一个 defaultConfigType(=LoadBalancerClientConfiguration.class, 作用配置一些 bean)</span></span><br><span class="line">  <span class="comment">//     LoadBalancerClientConfiguration 会加入一个 RoundRobinLoadBalancer, 看来就是默认的负载均衡类了.</span></span><br><span class="line">  <span class="comment">// 4.默认为加了一个名为 loadbalancer 的 PropertySource, 里面有一个 loadbalancer.client.name=serviceId 的配置....</span></span><br><span class="line">  <span class="comment">// 5.设定父容器, 父容器通过 ApplicationContextAware 获得, 这样刚才那么辛苦的注册方式, 就仅适合于特性, 而非通用了.</span></span><br><span class="line">  <span class="comment">// 6.设置名称(啥意义呢?), 然后调用容器的 refresh() 完成容器加载</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.configurations.containsKey(name)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; configuration : <span class="keyword">this</span>.configurations.get(name).getConfiguration()) &#123;</span><br><span class="line">      context.register(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="keyword">this</span>.configurations.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.getKey().startsWith(<span class="string">"default."</span>)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;</span><br><span class="line">        context.register(configuration);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  context.register(PropertyPlaceholderAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>.<span class="title">defaultConfigType</span>)</span>;</span><br><span class="line">  <span class="comment">// 默认为加了一个名为 loadbalancer 的 PropertySource, 里面有一个 loadbalancer.client.name=serviceId 的配置....</span></span><br><span class="line">  context.getEnvironment().getPropertySources().addFirst(<span class="keyword">new</span> MapPropertySource(<span class="keyword">this</span>.propertySourceName,</span><br><span class="line">                                                                               Collections.&lt;String, Object&gt;singletonMap(<span class="keyword">this</span>.propertyName, name)));</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Uses Environment from parent as well as beans</span></span><br><span class="line">    context.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">    <span class="comment">// jdk11 issue</span></span><br><span class="line">    <span class="comment">// https://github.com/spring-cloud/spring-cloud-netflix/issues/3101</span></span><br><span class="line">    context.setClassLoader(<span class="keyword">this</span>.parent.getClassLoader());</span><br><span class="line">  &#125;</span><br><span class="line">  context.setDisplayName(generateDisplayName(name));</span><br><span class="line">  context.refresh();</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据这句 context.register(PropertyPlaceholderAutoConfiguration.class, this.defaultConfigType);</span></span><br><span class="line"><span class="comment">// 而 defaultConfigType 在 LoadBalancerClientFactory 定义为 LoadBalancerClientConfiguration.class, 其配置了一个 bean, 代码如下</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="title">reactorServiceInstanceLoadBalancer</span><span class="params">(Environment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                               LoadBalancerClientFactory loadBalancerClientFactory)</span> </span>&#123;</span><br><span class="line">  String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RoundRobinLoadBalancer(</span><br><span class="line">    loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier<span class="class">.<span class="keyword">class</span>), <span class="title">name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里会与服务发现结合起来, 即 loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class)</span></span><br><span class="line"><span class="comment">// 此方法从容器中获取能提供 ServiceInstanceListSupplier.class 类型的 BeanProvider, 其实就是能获取这种类型的 bean 呗, 然后用这个类来获取 url 列表...  具体实现要看 Nacos / Consul 了.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以默认获取的负载均衡策略就是它了:  RoundRobinLoadBalancer</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 用了一个 LoadBalancerAutoConfiguration, 为 RestTemplate 加一个拦截器使得执行请求前先修改一下请求对象(主要修改url呗), 修改的步骤是 LoadBalancerClient.execute(), 里面则会使用 choose 获取微服务真实url, choose 是 ReactorLoadBalancer  的接口, 代表负载均衡策略. 啊对了, 既然是负载均衡算法, 那就是负责选取, 不负责获取才对… 于是我发现 loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class) 才是得到的对象, 才是获取 url 列表的代码(肯定和consul或nacos有关了)!!</p>
<p>暗示下集出 Nacos!!</p>
</blockquote>
<h2 id="Cloud-Alibaba-和-Spring-Cloud-整合-Spring-Cloud-Commons-步骤-指服务注册与发现"><a href="#Cloud-Alibaba-和-Spring-Cloud-整合-Spring-Cloud-Commons-步骤-指服务注册与发现" class="headerlink" title="Cloud Alibaba 和 Spring Cloud 整合 Spring Cloud Commons 步骤(指服务注册与发现)"></a>Cloud Alibaba 和 Spring Cloud 整合 Spring Cloud Commons 步骤(指服务注册与发现)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.希望别太简单</span><br><span class="line">2.就不写这里了(因为还没写啊!)</span><br><span class="line">3.下集见</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Cloud-整合-spring-cloud-loadbalancer"><a href="#Spring-Cloud-整合-spring-cloud-loadbalancer" class="headerlink" title="Spring Cloud 整合 spring-cloud-loadbalancer"></a>Spring Cloud 整合 spring-cloud-loadbalancer</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.pom 添加依赖即可</span><br><span class="line">2.pom 添加依赖即可</span><br><span class="line">3.pom 添加依赖即可</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">我也没想到, 没多写一个类, 直接就能用...  原理上面分析了 😭😭😭😭😭</span><br></pre></td></tr></table></figure>



<h2 id="Cloud-Alibaba-整合-spring-cloud-loadbalancer"><a href="#Cloud-Alibaba-整合-spring-cloud-loadbalancer" class="headerlink" title="Cloud Alibaba 整合 spring-cloud-loadbalancer"></a>Cloud Alibaba 整合 spring-cloud-loadbalancer</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.pom 添加依赖即可</span><br><span class="line">2.pom 添加依赖即可</span><br><span class="line">3.pom 添加依赖即可</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">我也没想到, 没多写一个类, 直接就能用...  原理上面分析了 😭😭😭😭😭</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 你没卡, 你电脑没问题, 我就是写(zhan)了(tie)两遍!!!</p>
</blockquote>
<h2 id="Spring-Cloud-Commons-的核心类及其作用"><a href="#Spring-Cloud-Commons-的核心类及其作用" class="headerlink" title="Spring Cloud Commons 的核心类及其作用"></a>Spring Cloud Commons 的核心类及其作用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.LoadBalancerClient: 实现它就实现了负载均衡策略</span><br><span class="line">	但其实实现 ReactorServiceInstanceLoadBalancer 更简单</span><br><span class="line">2.DiscoveryClient: 实现它就实现了服务发现</span><br><span class="line">3.ServiceRegistry: 实现它就实现了服务注册</span><br><span class="line">4.ServiceInstance: 代表一个服务, 前面加个 Micro 就是微服务了 :D</span><br></pre></td></tr></table></figure>





<blockquote>
<p>PS: 就这!</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/25/source-code-jdk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/25/source-code-jdk/" class="post-title-link" itemprop="url">JDK 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-25 23:12:48" itemprop="dateCreated datePublished" datetime="2021-01-25T23:12:48+08:00">2021-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:52:49" itemprop="dateModified" datetime="2021-03-28T19:52:49+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/25/source-code-jdk/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/25/source-code-jdk/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JDK-源码笔记"><a href="#JDK-源码笔记" class="headerlink" title="JDK 源码笔记"></a>JDK 源码笔记</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><blockquote>
<p>核心就是 <code>newCapacity</code> 方法，这个方法用于确定扩容后的数组大小，正常是原来的 1.5 倍（老二进制运算了），若扩容后仍不够大，则仅保证能放下新加入的数据即可（当使用 ``addAll<code>方法时可能触发）；若扩容后溢出，则仅保证能放下新加入的数据即可；若扩容后逼近溢出，则返回</code>MAX_ARRAY_SIZE<code>或</code>Integer.MAX_VALUE<code>；另外两次扩容后过大也会检查</code>minCapacity` 是否溢出，防止数据错误。</p>
</blockquote>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote>
<p>核心是根据 hash 取数组下标 index，并且 1.8 的扩容后 rehash 利用二进制高低位优化了计算下标的效率；扩容为原来的两倍，即左移 1 位。</p>
</blockquote>
<h3 id="为什么-HashMap-的初始容量以及扩容后的容量均为-2-的指数幂"><a href="#为什么-HashMap-的初始容量以及扩容后的容量均为-2-的指数幂" class="headerlink" title="为什么 HashMap 的初始容量以及扩容后的容量均为 2 的指数幂"></a>为什么 <code>HashMap</code> 的初始容量以及扩容后的容量均为 2 的指数幂</h3><blockquote>
<p>因为计算机做运算时, 取模运算速度远远慢于位运算, 而若容量始终为 2 的指数幂, 则根据 hash 获取数组下标时只需要 使用 <code>(数组长度-1) &amp; hash 值</code> 即可确定数组下标, 与取模得到的下标一样可靠.</p>
<p>而扩容后后, 因为需要进行 rehash 运算来确定 数据的新下标, 多次进行取数组下标则更能体现位运算的优势.</p>
</blockquote>
<h3 id="为什么-HashMap-的加载因子是-0-75-3-4"><a href="#为什么-HashMap-的加载因子是-0-75-3-4" class="headerlink" title="为什么 HashMap 的加载因子是 0.75 (3/4)"></a>为什么 <code>HashMap</code> 的加载因子是 0.75 (3/4)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用排除法:</span><br><span class="line">1.若加载因子为 1. 则每次 HashMap 满了才进行扩容, 必将有更高的几率触发 hash 碰撞导致数组下标一致需要转成链表或红黑树, 导致读取和更新速度降低.</span><br><span class="line">2.若加载因子为 0.5. 则每次 HashMap 都有一半容量剩余, 空间大大浪费, 对内存开销太大. 容易引发 OOM 事故.</span><br><span class="line">3.0.5-1 之间那么多可能, 选哪个都行, 但作为 HashMap 的默认值, 选中间的 0.75, 走中庸之路, 也是解释的通的.</span><br></pre></td></tr></table></figure>



<h3 id="为什么-HashMap-1-8-扩容无需-rehash"><a href="#为什么-HashMap-1-8-扩容无需-rehash" class="headerlink" title="为什么 HashMap 1.8 扩容无需 rehash"></a>为什么 <code>HashMap</code> 1.8 扩容无需 rehash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 因为1.8的获取 hash 值的算法优化了. 无需一个 hashSeed 进行辅助运算 (主因)</span><br><span class="line">2. 由于 hash 值不变, 原链表中的所有节点只有 2 种可能:</span><br><span class="line">	一是 hash 值高于原数组长度, 则属于高位, 这些高位的节点, 新的下标一定是 (当前下标 + 旧数组长度). </span><br><span class="line">	另一种是 hash 值低于原数组长度, 属于低位, 这些节点的下标无需重新计算, 必然与当前下标一致</span><br><span class="line">	(不信自己那几个示例数据用画出完整二进制计算一下)(神奇的位运算)</span><br><span class="line">3. 重新计算下标时, 根据第 2 点可知, 其下标大小一定不高于(当前下标+旧数组长度), 即下一次循环的下标必然比上一次循环的下标要高, 所以 1.8 源码 resize 进行高低位分组然后转移数据时, 无需担心下一次循环会将刚刚放到新数组的值覆盖(下标相同则会覆盖)</span><br><span class="line">4. 1.8 的 resize 优化了算法, 保持了原有的链表顺序(不知道有啥用)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总得来说, 1.8 优化了 hash 算法, 使 <code>hashcode</code> 的高 16 位与 低 16 位进行异或运算, 降低了碰撞率</p>
<p>而 resize 算法也优化链表节点的迁移, 避免了 1.7 的链环产生</p>
<p>最大的区别就是, 1.7 没有将二进制的神奇发挥到极致, 依然像普通 java 程序一般逻辑. 而 1.8 则充分利用了二进制的优点(也充分的让人头晕), 提高了 <code>HashMap</code> 的效率.</p>
</blockquote>
<h3 id="为什么-HashMap-从链表达到-8-个时转成红黑树-达到-6-个时转回链表"><a href="#为什么-HashMap-从链表达到-8-个时转成红黑树-达到-6-个时转回链表" class="headerlink" title="为什么 HashMap 从链表达到 8 个时转成红黑树, 达到 6 个时转回链表?"></a>为什么 <code>HashMap</code> 从链表达到 8 个时转成红黑树, 达到 6 个时转回链表?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.根据 Poisson distribution 定律, 凑齐8个节点碰撞到同一个下标, 组成长度为 8 的链表概率极低, 约为 0.00000006, 而超过 8 个的几率则更低, 大约为千万分之一. 所以将阈值设置为 8, 因为这种概率极低. 因此可以减少链表转红黑树的, 提高增删改效率.</span><br><span class="line">2.若达到 7 个时转回链表, 则可能会导致HashMap 不停的在链表和红黑树之间转换, 所以阈值设置为 6, 可起到缓冲效果.</span><br></pre></td></tr></table></figure>







<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS 的 acquire： AbstractQueuedSynchronizer#acquire()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !tryAcquire(arg) </span><br><span class="line">    &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">  ) &#123;</span><br><span class="line">    selfInterrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.tryAcquire：判断 state 状态，无线程持有则 CAS 加持 state，并返回 true，加锁结束。</span></span><br><span class="line"><span class="comment">// 2.addWaiter：已被持有则先加入队列</span></span><br><span class="line"><span class="comment">// 3.acquireQueued：两件事，第一，循环尝试持有锁，失败则休眠；第二，持有成功则更新队列头为自己（队列向前移动）</span></span><br><span class="line"><span class="comment">//    加入队列后，不能立刻睡，防止没人唤醒自己（比如还没加入等待队列，上个持有锁的线程就结束了然后触发解锁代码，而解锁代码的唤醒依赖于等待队列）</span></span><br><span class="line"><span class="comment">//    确定得不到锁（需要等待）则进入睡眠，醒来后再尝试 tryAcquire 持有锁，失败则睡眠（循环尝试）</span></span><br><span class="line"><span class="comment">//    醒来尝试持有锁成功后，维护队列（即队列头部设为自己，宏观上队列往前移动了）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：先判断后更新 state  状态（即是否有线程持有此锁），被持有则加入队列并睡眠；醒来后再重复判断 state 过程，若持有成功则更新队列（主要目的是令我的下一个节点被唤醒后可以尝试持有锁，因为一醒来就是判断 node.prev==head）。</p>
</blockquote>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS 的 release：AbstractQueuedSynchronizer#release()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">      unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.tryRelease：减持 state 数量，减到 0 代表线程彻底释放了这个锁</span></span><br><span class="line"><span class="comment">// 2.unparkSuccessor：唤醒下一个节点的线程（若下一个节点为空，则从队列尾往前查找队列中状态不是 CANCELLED 的且最靠前的节点来唤醒）</span></span><br><span class="line"><span class="comment">// 3.唤醒后处于 acquireQueued 的循环中。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：先更新后判断 state 状态，若为 0，则代表可唤醒下一个节点，找到下一个节点，唤醒即可！</p>
</blockquote>
<p>从上得到可重入锁原理，同一线程第二次加锁，会令 state+1，</p>
<p>而释放锁时，会先令 state-1，若 state 减到 0，才唤醒下一个节点的线程。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AQS</span><br><span class="line">	acquire：通过 tryAcquire 判断是否需要加入队列以及休眠</span><br><span class="line">	release：通过 tryRelease 判断是否需要唤醒下一个节点的线程</span><br><span class="line">	tryAcquire：正向维护 state，有自己的逻辑决定返回值</span><br><span class="line">	tryRelease：反向维护 state，一般与 tryAcquire 互逆</span><br><span class="line">	</span><br><span class="line">	acquireShared：通过 tryAcquireShared 判断是否需要加入队列以及休眠（此时节点标记为 SHARED）</span><br><span class="line">	releaseShared：通过 tryReleaseShared 判断是否需要唤醒下一个节点，若下一个节点是 SHARED 节点，则还会继续唤醒下一个节点，若都是 SHARED 节点，则都会被唤醒。</span><br><span class="line">	tryAcquireShared：正向维护 state，返回值小于 0 代表需要进入队列</span><br><span class="line">	tryReleaseShared：反向维护 state，一般与 tryAcquireShared 互逆</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：一个具体的 AQS 维护一个队列以及 state 数据，总是通过 tryAcquire、tryRelease 维护 state，并在 acquire 中完成队列的添加与移除。</p>
<p>AQS 维护的队列总是在尾部增加节点，并且移除节点时，总是移除 head 节点。</p>
<p>通过实行具体的 tryAcquire、tryRelease 方法，可控制 线程是否等待，何时唤醒线程。</p>
<p>再总结： AQS 的主要作用就是将线程加入到队列、移除队列、控制休眠和唤醒。</p>
</blockquote>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><ul>
<li>读锁加锁：只要 state 中没有写锁，又没有超过最大数量（受 32 位二进制长度限制），则能加锁成功（非公平锁不进队列等待，公平锁只可能会排在队列中写锁节点后面）；</li>
<li>读锁解锁：先减少 state 中的读锁数量，减到 0 则可触发 releaseShared 来唤醒队列中可能存在的写锁节点；</li>
<li>写锁加锁：若没有写锁也没有读锁，令 state+1 写锁，记录重入次数；</li>
<li>写锁解锁：先减少 state （可重入锁），若写锁数量为 0，则可唤醒队列中的下一个节点，若下一个节点为读锁加入的节点，则会唤醒下下个是读锁的节点，重复，则唤醒大量读锁节点。</li>
</ul>
<blockquote>
<p>总结：重写 AQS 的核心方法，使其得以控制读锁、写锁能否加锁成功，利用 AQS 的 SHARED 节点在 releaseShared 时的传播性，使得写锁结束后，可以唤醒一连串的读锁。</p>
</blockquote>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new CountDownLatch(n)：设置 state 的初始值为 n，使得需要调用 n 次 countDown 才会唤醒调用 await 的线程</span></span><br><span class="line"><span class="comment">// countDown：state - 1，若 state 减到 0，则唤醒所有队列中的节点</span></span><br><span class="line"><span class="comment">// await：加入到 AQS 队列休眠，节点标记为 SHARED</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：利用 releaseShared 会传播唤醒队列上相连的 SHARED 节点特性和 state 的维护，使 await 的线程进入休眠队列，直到 countDown 调用次数足够多才会唤醒这些线程。</p>
</blockquote>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new Semaphore(n)：设置 state 的初始值为 n，当想唤醒调用 acquire(x) 的线程，则需要调用 release(x-n)</span></span><br><span class="line"><span class="comment">// acquire(x)：加入到 AQS 队列休眠（前提 state &lt; x) </span></span><br><span class="line"><span class="comment">// release(x)：state + x，总是尝试唤醒队列</span></span><br><span class="line"></span><br><span class="line">理解方式：acquire 多少个数，则代表需要等待多少个 release，若有初始值，则需要的 release 再减去初始值；满足则唤醒，为满足则进入队列休眠</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：利用 AQS 可控制线程休眠和唤醒的特性，重写 tryAcquireShared、tryReleaseShared 方法实现逻辑；另外，虽然 acquire、release 的语义与正常 AQS 保持一致，但其对 state 的操作（加减）却是反着来的。</p>
</blockquote>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><blockquote>
<p>含义: 凑足一定个数线程, 然后批量唤醒.<br>await(): 利用 ReenrantLock 的 lock 和 condition 的 await 进入休眠<br>当凑足后，用condition 的 singleAll 唤醒所有 await 的线程.</p>
</blockquote>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote>
<p>不同之处有二</p>
<p>一是 put 一个新的 key 时，会使用 CAS 确保这次 put 没有线程竞争；</p>
<p>二是 put 覆盖一个 key 时，直接使用 synchronized 同步块进行同步。</p>
</blockquote>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.ThreadPoolExecutor#execute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">      reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">      addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">    reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>若当前线程数少于核心线程数，则添加一个线程来执行任务，直到线程数超过核心数；</li>
<li>超过之后，会放入到 workQueue 队列中，并重新检查线程池状态及是否有线程可执行队列中的任务</li>
<li>若放入失败（即队列已满），则尝试添加一个线程来执行这个任务，此时若线程达到最大线程数，则会失败并调用 reject 方法触发用户设置的拒绝策略。</li>
</ol>
<blockquote>
<p>总结：线程池先创建满核心线程数，超出放入队列，队列也放不下则会新建线程来救急，如果救急的线程创建过多，最终总线程数超过最大线程数，则触发拒绝策略，线程池不再接收任务，除非队列空出位置或线程数量降下来。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/25/source-code-spring-mvc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/25/source-code-spring-mvc/" class="post-title-link" itemprop="url">Spring MVC 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-25 23:12:41" itemprop="dateCreated datePublished" datetime="2021-01-25T23:12:41+08:00">2021-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:49:14" itemprop="dateModified" datetime="2021-03-28T19:49:14+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/25/source-code-spring-mvc/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/25/source-code-spring-mvc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-MVC-源码笔记"><a href="#Spring-MVC-源码笔记" class="headerlink" title="Spring MVC 源码笔记"></a>Spring MVC 源码笔记</h1><h2 id="关键类分析"><a href="#关键类分析" class="headerlink" title="关键类分析"></a>关键类分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">WebMvcConfigurationSupport</span><br><span class="line">	默认注册了很多东西,如 HandlerMapping 几个实现, HandlerAdaptor 几个实现</span><br><span class="line"></span><br><span class="line">HandlerMapping</span><br><span class="line">	添加容器内所有带有 RequestMaping 的类的公开方法到 mappings 中存起来</span><br><span class="line">		(AbstractHandlerMethodMapping<span class="comment">#afterPropertiesSet中)</span></span><br><span class="line">    根据 request 的 uri 查找对应的 HandlerMethod, 步骤概述:</span><br><span class="line">    	把RequestMapping注解内的 path 作为 key 保持到一个 map1</span><br><span class="line">    	其他信息封装成 mapping 作为 key 也保持到另一个 map2</span><br><span class="line">    	根据 uri去 map1 获取 mapping, 再根据 mapping 获取 HandlerMethod</span><br><span class="line">    	封装成 Match 对象, 与其他匹配对象做比较后, 返回 HandlerMethod</span><br><span class="line"></span><br><span class="line">HandlerAdapter</span><br><span class="line">	初始化参数解析，返回值解析等</span><br><span class="line">		(RequestMappingHandlerAdapter<span class="comment">#afterPropertiesSet)</span></span><br><span class="line">	根据 handler 确定对应的 HandlerAdapter, 然后 HandlerAdapter 负责执行这个 handler</span><br><span class="line">    如 RequestMappingHandlerAdapter 则负责执行 HandlerMethod</span><br><span class="line">    	简单说就是封装 HandlerMethod, 根据参数值设置参数, 然后调用方法, 再处理返回值封装成 ModelAndView</span><br><span class="line">    另外，这里如果使用了@ResponseBody，会进入 RequestResponseBodyMethodProcessor</span><br><span class="line">    	然后使用 messageConverters（json）写入到响应流</span><br><span class="line">    	最后 mv 也直接返回null, 不需要render了.</span><br><span class="line"></span><br><span class="line">ViewResolver</span><br><span class="line">	负责将 ModelAndView 解析成HTML, 如JSP, FreeMarker</span><br><span class="line"></span><br><span class="line">HandlerExecutionChian</span><br><span class="line">	管理拦截器和封装Handler, 负责拦截器的实际调用逻辑实现</span><br><span class="line">	</span><br><span class="line">DispatcherServlet</span><br><span class="line">	调度整个HTTP请求响应流程, 调用各个子组件负责执行处理方法, 解析视图, 处理异常等.</span><br></pre></td></tr></table></figure>





<h2 id="SSM项目-Spring-容器和-Spring-MVC-容器的创建过程及关系"><a href="#SSM项目-Spring-容器和-Spring-MVC-容器的创建过程及关系" class="headerlink" title="SSM项目 Spring 容器和 Spring MVC 容器的创建过程及关系"></a>SSM项目 Spring 容器和 Spring MVC 容器的创建过程及关系</h2><h3 id="Spring-容器的创建"><a href="#Spring-容器的创建" class="headerlink" title="Spring 容器的创建"></a>Spring 容器的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.context.ContextLoader<span class="comment">#initWebApplicationContext</span></span><br><span class="line">1.先判断此方法是否重复运行, 若重复则报异常.</span><br><span class="line">2.记录日志, 记录开始时间用于计算启动消耗时间</span><br><span class="line">3.将容器对象存储在本地而非 servletContext, 防止 ServletContext 关闭后无法访问</span><br><span class="line">4.根据配置的类名, 实例化一个容器并赋值给 this.context</span><br><span class="line">5.标准代码, 但其实就是 setParent(null), 前提是不扩展子类咯. 也就是说这个就是顶级容器了</span><br><span class="line">6.根据 web.xml 的配置对容器做相应的配置, 初始化, 将 ServletContext 存入到 environment 对象中; 执行 InitializerClass, 调用容器 refresh 完成容器加载</span><br><span class="line">7.打印容器初始化完成日志和记录耗时</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 监听 ServletContext 创建完毕的事件, 然后创建一个 web 容器, 配置一些东西(id, parent, environment)并初始化(refresh)</p>
</blockquote>
<h3 id="MVC-子容器的创建"><a href="#MVC-子容器的创建" class="headerlink" title="MVC 子容器的创建"></a>MVC 子容器的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.首先是 DispatchServlet 本身是一个 Servlet, 因此他有生命周期 init(), 其父类 init() 会将 ServletConfig 的配置(web.xml 中的 initParams)与 servlet 对象绑定, 这样 DispatchServlet 对象的字段就有值了.</span><br><span class="line">2.然后在 DispatchServlet 的父类 FrameworkServlet<span class="comment">#initServletBean 中, 会创建一个容器并使其加载.(详细见 FrameworkServlet#initWebApplicationContext() )</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 就是利用 Servlet 的生命周期只会执行一次 init 的特性, 查找父容器, 创建子容器.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HttpServletBean#init</span><br><span class="line">    <span class="comment">// 1.把 servletConfig 的 initParameters 都加入 PropertySource, 根据 requiredProperties 判断所需配置项是否齐全</span></span><br><span class="line">		<span class="comment">// 2.将配置项绑定到 Servlet 对象(this) 上(子类的字段也算).</span></span><br><span class="line">		<span class="comment">// 3.调用子类初始化方法</span></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.FrameworkServlet#initServletBean</span><br><span class="line">    <span class="comment">// 0.父类的 init 执行完, 此时 contextConfigLocation 已经有值了</span></span><br><span class="line">		<span class="comment">// 1.记录日志和开始时间</span></span><br><span class="line">		<span class="comment">// 2.创建子容器, 与父容器绑定, 做一些配置, 调用 refresh() 完成加载.</span></span><br><span class="line">		<span class="comment">// 3.打印日志, 打印耗时</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</span><br><span class="line">    <span class="comment">// 1.从 ServletContext 中获取 Spring 容器.(那么谁放进去的呢? 没错, 就是 ContextLoader,监听了 ServletContext 事件)</span></span><br><span class="line">		<span class="comment">// 2.若容器在构造方法处被注入(可能是注解开发 Spring MVC 的方式会触发), 先忽视  -- 来自 web.xml 形式启动分析</span></span><br><span class="line">		<span class="comment">// 3.根据绑定得到的配置的 contextClass 创建一个子容器, 进行一些配置和初始化, 调用 refresh() 完成容器加载</span></span><br><span class="line">		<span class="comment">// 4.防止子容器不支持 refresh, 或子容器不是刚刚创建的, 因此手动触发 onRefresh(), 这个方法会加载一些默认的 bean(用处很大的那种)</span></span><br><span class="line">		<span class="comment">// 5.将容器设置到 ServletContext 中(根据配置, 默认允许)</span></span><br><span class="line">		<span class="comment">// 6.返回创建的子容器对象</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext</span><br><span class="line">    <span class="comment">// 1.根据绑定得到的配置设置容器 id, 若无则生成默认的</span></span><br><span class="line">		<span class="comment">// 2.设置 ServletContext/ServletConfig 对象</span></span><br><span class="line">		<span class="comment">// 3.为子容器添加一个监听只监听子容器刷新事件的监听器, 用于容器加载完毕后调用 FrameworkServlet.onApplicationEvent()</span></span><br><span class="line">		<span class="comment">// 4.将 ServletConfig/ServletContext 加入到 environment 中.</span></span><br><span class="line">		<span class="comment">// 5.执行 web.xml 中配置的 Initializers, 为子容器做的初始化</span></span><br><span class="line">		<span class="comment">// 6.调用子容器的 refresh(), 完成容器的加载</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#initStrategies</span><br><span class="line">    <span class="comment">// 加载文件上传处理 bean</span></span><br><span class="line">		<span class="comment">// 加载国际化处理 bean</span></span><br><span class="line">		<span class="comment">// 加载主题切换处理 bean</span></span><br><span class="line">		<span class="comment">// 加载 HandlerMapping bean</span></span><br><span class="line">		<span class="comment">// 加载 HandlerAdapter bean</span></span><br><span class="line">		<span class="comment">// 加载异常处理 bean</span></span><br><span class="line">		<span class="comment">// 加载 HttpServletRequest 转视图名称处理策略 bean</span></span><br><span class="line">		<span class="comment">// 加载视图解析器</span></span><br><span class="line">		<span class="comment">// 加载 FlashMap 管理 bean</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 每一个加载的逻辑都是类似的, 先从容器中根据 Xxx.class getBean</span></span><br><span class="line">		<span class="comment">// 若无, 则调用 getDefaultStrategy() 从 DispatcherServlet.properties 配置文件中读取</span></span><br></pre></td></tr></table></figure>



<h3 id="DispatchServlet-的创建"><a href="#DispatchServlet-的创建" class="headerlink" title="DispatchServlet 的创建"></a>DispatchServlet 的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Tomcat 会创建配置在 web.xml 的 Servlet</span><br><span class="line">2.接着会触发 init 方法, init 调用了创建子容器的方法后, 还添加了容器加载完毕事件监听来回调 DispatcherServlet<span class="comment">#onRefresh</span></span><br><span class="line">3.DispatcherServlet<span class="comment">#onRefresh 会 initStrategies() 加载很多策略接口 bean.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 和子容器的创建息息相关.</p>
</blockquote>
<h2 id="Dispatch-过程"><a href="#Dispatch-过程" class="headerlink" title="Dispatch 过程"></a>Dispatch 过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.覆盖 HttpServlet 的 service 方法, 调用 FrameworkServlet<span class="comment">#processRequest()</span></span><br><span class="line">2.此方法中进行一些上下文的准备工作, 以及处理日志, 异常(非 controller 异常), 然后调用 DispatcherServlet<span class="comment">#doService()</span></span><br><span class="line">3.doService() 中对 request 做一些准备工作, 然后调用 DispatcherServlet<span class="comment">#doDispatch()</span></span><br><span class="line">4.doDispatch() 先用 handlerMappings 查找合适的 handler(并加入拦截器链), 再通过 handlerAdapters 得到 handler 的适配器, 在合适的地方触发拦截器; 然后调用适配器的 handle() 得到 ModelAndView</span><br><span class="line">5.得到 ModelAndView 后, 先判断是否捕获到了异常, 是则调用 handlerExceptionResolvers 的 resolveException() 处理异常</span><br><span class="line">6.接着, 调用 viewResolvers 的 resolveViewName, 将 viewName 解析成一个 View 对象</span><br><span class="line">7.调用 View 对象的 render(), 将视图通过 response 响应到前端.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: handlerMappings 找 handler 并包装拦截器链, handlerAdapters 找可执行的 HandlerAdapter, viewResolvers 解析视图, 渲染视图.</p>
</blockquote>
<h3 id="超长源码注释"><a href="#超长源码注释" class="headerlink" title="超长源码注释"></a>超长源码注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口 HttpServlet.service</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">  HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">  <span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    processRequest(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.service(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入到 processRequest, 我只写注释了啊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.FrameworkServlet#processRequest</span><br><span class="line">    <span class="comment">// 1.记录启动时间</span></span><br><span class="line">		<span class="comment">// 2.准备国际化处理上下文</span></span><br><span class="line">		<span class="comment">// 3.准备属性管理上下文</span></span><br><span class="line">		<span class="comment">// 4.获取并缓存一个 asyncManager(异步)</span></span><br><span class="line">		<span class="comment">// 5.初始化两个 ContextHolder</span></span><br><span class="line">		<span class="comment">// 6.处理文件上传, 根据不同策略查找可执行的 controller 方法, 查到后加入拦截器, 再通过适配器来执行 controller 方法, 然后把得到的 ModelAndView 解析成视图对象, 并渲染到前端.</span></span><br><span class="line">		<span class="comment">// 7.重置两个 ContextHolder</span></span><br><span class="line">		<span class="comment">// 8.打印日志, 发布事件</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#doService</span><br><span class="line">    <span class="comment">// 1.打印日志, 记录请求信息</span></span><br><span class="line">		<span class="comment">// 2.保存一份请求上下文的快照, 这样嵌套的请求在回归时可以恢复数据</span></span><br><span class="line">		<span class="comment">// 3.将容器中的一些 bean 配置到请求上下文中</span></span><br><span class="line">		<span class="comment">// 4.处理文件上传, 根据不同策略查找可执行的 controller 方法, 查到后加入拦截器, 再通过适配器来执行 controller 方法, 然后把得到的 ModelAndView 解析成视图对象, 并渲染到前端.</span></span><br><span class="line">		<span class="comment">// 5.若需要, 将快照恢复到请求上下文</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#doDispatch</span><br><span class="line">    <span class="comment">// 1.准备一些变量</span></span><br><span class="line">		<span class="comment">// 2.判断并处理文件上传请求, 若是, processedRequest 则变为 MultipartHttpServletRequest 类型的对象.</span></span><br><span class="line">		<span class="comment">// 3.遍历之前加载的 handlerMappings, 调用 getHandler 接口获取执行链对象并返回. 找不到则返回 null</span></span><br><span class="line">		<span class="comment">// 4.根据 handler 获取合适的适配器</span></span><br><span class="line">		<span class="comment">// 5.遍历执行拦截器的 preHandle(), 若遇到 renturn false, 则结束 doDispatch</span></span><br><span class="line">		<span class="comment">// 6.执行实际的 controller 的方法得到 ModelAndView 对象.</span></span><br><span class="line">		<span class="comment">// 7.处理默认的 viewName</span></span><br><span class="line">		<span class="comment">// 8.遍历执行拦截器的 postHandle()</span></span><br><span class="line">		<span class="comment">// 9.若有异常则处理异常: 遍历之前加载的异常处理器策略类, 调用 resolveException()</span></span><br><span class="line">		<span class="comment">//10.若无异常则根据需要根据 ModelAndView的对象的视图名配合之前加载的视图解析器获取 View 对象, 再调用 render() 渲染视图.</span></span><br><span class="line">		<span class="comment">//11.最后执行拦截器的 triggerAfterCompletion</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#getHandler</span><br><span class="line">    <span class="comment">// 遍历之前加载的 handlerMappings, 调用其 getHandler 接口获取 handler 和拦截器封装成 chain 对象并返回. 找不到则返回 null</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter</span><br><span class="line">    <span class="comment">// 遍历之前加载的 handlerAdapters, 调用 supports 判断是否支持 handler, 支持则返回 adapter</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.HandlerExecutionChain#applyPreHandle</span><br><span class="line">    <span class="comment">// 从头到尾遍历拦截器, 执行 preHandle(), 若拦截器返回 false, 则立刻 triggerAfterCompletion, 然后 return false</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#processDispatchResult</span><br><span class="line">    <span class="comment">// 若有异常则处理异常: 遍历之前加载的异常处理器策略类, 调用 resolveException()</span></span><br><span class="line">		<span class="comment">// 若无异常则根据需要根据视图名和视图解析器渲染视图</span></span><br><span class="line">		<span class="comment">// 最后执行拦截器的 triggerAfterCompletion</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#processHandlerException</span><br><span class="line">    <span class="comment">// 遍历之前加载的异常处理器策略类, 调用 resolveException()</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#render</span><br><span class="line">    <span class="comment">// 先遍历视图解析器, 根据视图名获取实际视图对象</span></span><br><span class="line">		<span class="comment">// 最后调用实际视图对象的 render (渲染方法)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.web.servlet.DispatcherServlet#resolveViewName</span><br><span class="line">    <span class="comment">// 遍历视图解析器, 根据视图名获取实际视图对象</span></span><br></pre></td></tr></table></figure>





<h2 id="某些实现原理"><a href="#某些实现原理" class="headerlink" title="某些实现原理"></a>某些实现原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.拦截器原理</span><br><span class="line">2.默认的 HandlerMapping/HandlerAdapter 在何时加入?</span><br><span class="line">3.参数是如何与 HTTP 请求 body 绑定的(序列化, 格式化, 绑定)?</span><br><span class="line">4.参数校验是如何进行的?</span><br><span class="line">5.有关参数与返回值的一些拦截与干预(@RequestBody, @ResponseBody).</span><br></pre></td></tr></table></figure>



<h3 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">何时加入?</span><br><span class="line">	从 WebMvcConfigurationSupport 的子类中调用 addInterceptors </span><br><span class="line">	添加一些拦截器和拦截器的路径配置 InterceptorRegistry 和 MappedInterceptor</span><br><span class="line">    实现拦截器路径匹配, 在 new HandlerExecutionChian 时判断</span><br><span class="line"></span><br><span class="line">何时执行?</span><br><span class="line">	DispatcherServlet 负责在正确的时机调用 HandlerExecutionChian 来调用 preHanlde 等方法.</span><br><span class="line">	拿到 HandlerExecutionChian 后调用 preHanlde</span><br><span class="line">	HandlerAdapter 执行完 handler 后, 调用 postHandle</span><br><span class="line">	解析视图并渲染到response之后, 调用 afterCompletion</span><br><span class="line">	如果中途出现异常, 或 preHandle 提前结束, 则也调用 afterCompletion</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">	DispatcherServlet 去调用 HandlerExecutionChian 去调用 拦截器具体方法. </span><br><span class="line">	复杂点是添加一个拦截器到被加入到 HandlerExecutionChian 比较复杂一点, 以及带路径匹配的拦截器实现略复杂一些.</span><br></pre></td></tr></table></figure>



<h3 id="默认的-HandlerMapping-HandlerAdapter-在何时加入"><a href="#默认的-HandlerMapping-HandlerAdapter-在何时加入" class="headerlink" title="默认的 HandlerMapping/HandlerAdapter 在何时加入?"></a>默认的 HandlerMapping/HandlerAdapter 在何时加入?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.DispatcherServlet#initStrategies</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 加载文件上传处理 bean</span></span><br><span class="line">  <span class="comment">// 加载国际化处理 bean</span></span><br><span class="line">  <span class="comment">// 加载主题切换处理 bean</span></span><br><span class="line">  <span class="comment">// 加载 HandlerMapping bean</span></span><br><span class="line">  <span class="comment">// 加载 HandlerAdapter bean</span></span><br><span class="line">  <span class="comment">// 加载异常处理 bean</span></span><br><span class="line">  <span class="comment">// 加载 HttpServletRequest 转视图名称处理策略 bean</span></span><br><span class="line">  <span class="comment">// 加载视图解析器</span></span><br><span class="line">  <span class="comment">// 加载 FlashMap 管理 bean</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每一个 init 的逻辑都是类似的, 先从容器中根据 Xxx.class getBean</span></span><br><span class="line">  <span class="comment">// 若无, 则调用 getDefaultStrategy() 从 DispatcherServlet.properties 配置文件中读取</span></span><br><span class="line">  initMultipartResolver(context);</span><br><span class="line">  initLocaleResolver(context);</span><br><span class="line">  initThemeResolver(context);</span><br><span class="line">  initHandlerMappings(context);</span><br><span class="line">  initHandlerAdapters(context);</span><br><span class="line">  initHandlerExceptionResolvers(context);</span><br><span class="line">  initRequestToViewNameTranslator(context);</span><br><span class="line">  initViewResolvers(context);</span><br><span class="line">  initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参数是如何与-HTTP-请求-body-绑定的-序列化-格式化-绑定"><a href="#参数是如何与-HTTP-请求-body-绑定的-序列化-格式化-绑定" class="headerlink" title="参数是如何与 HTTP 请求 body 绑定的(序列化, 格式化, 绑定)?"></a>参数是如何与 HTTP 请求 body 绑定的(序列化, 格式化, 绑定)?</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.在适配器执行 handler 的时候, 即 RequestMappingHandlerAdapter#invokeHandlerMethod</span><br><span class="line">2.此方法会进行一些其他处理, 然后准备执行方法前解析参数, 即在 InvocableHandlerMethod#getMethodArgumentValues() 中</span><br><span class="line"><span class="number">3</span>.这个方法中会遍历每一个参数, 再遍历配置的所有 resolvers, 通过 supportsParameter 接口判断是否支持参数解析, 是则调用 resolveArgument 接口获得实参</span><br><span class="line">4.这其中, 最重要的是 resolvers, 其一般在 RequestMappingHandlerAdapter#getDefaultArgumentResolvers() 中添加默认和用户自定义的 resoloves.</span><br><span class="line">5.如 RequestResponseBodyMethodProcessor#resolveArgument() 用于处理带 @RequestBody 注解的参数.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结: 适配器执行具体方法前, 先用反射获取这个方法的 参数(形参)集合, 挨个遍历从 resolvers 找支持解析的类来解析, 得到的返回值作为实参先存起来, 最后调用具体方法时就可以带上实参们执行就实现了将 HTTP 的数据绑定到 controller 的方法参数上的功能.</p>
<p>参考 RequestResponseBodyMethodProcessor#resolveArgument()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">                              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 readWithMessageConverters 读取 body 的数据, 再序列化 json 成相应的 Java Bean</span></span><br><span class="line">  <span class="comment">// 使用 binder 检查 arg 的值是否与 @Valid 的那些注解相关的规则相符, 若有错误, 则抛异常.</span></span><br><span class="line"></span><br><span class="line">  parameter = parameter.nestedIfOptional();</span><br><span class="line">  Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">  String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (binderFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">    WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">    <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">      validateIfApplicable(binder, parameter);</span><br><span class="line">      <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mavContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参数校验是如何进行的"><a href="#参数校验是如何进行的" class="headerlink" title="参数校验是如何进行的?"></a>参数校验是如何进行的?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考上面的代码</span></span><br><span class="line"><span class="keyword">if</span> (binderFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">  WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">  <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">    validateIfApplicable(binder, parameter);</span><br><span class="line">    <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mavContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码 validateIfApplicable() 就进行了参数校验, 代码如下:</span></span><br><span class="line"><span class="comment">// 逻辑是: 遍历参数所有的注解, 包含 validatedAnn 或以 Valid 开头的注解都进行校验</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">validateIfApplicable</span><span class="params">(WebDataBinder binder, MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">  Annotation[] annotations = parameter.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">for</span> (Annotation ann : annotations) &#123;</span><br><span class="line">    Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (validatedAnn != <span class="keyword">null</span> || ann.annotationType().getSimpleName().startsWith(<span class="string">"Valid"</span>)) &#123;</span><br><span class="line">      Object hints = (validatedAnn != <span class="keyword">null</span> ? validatedAnn.value() : AnnotationUtils.getValue(ann));</span><br><span class="line">      Object[] validationHints = (hints <span class="keyword">instanceof</span> Object[] ? (Object[]) hints : <span class="keyword">new</span> Object[] &#123;hints&#125;);</span><br><span class="line">      binder.validate(validationHints);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后是 validate 具体的对象.</span></span><br><span class="line"><span class="comment">// 逻辑是: 遍历所有的 validators, 挨个调用 validate 校验</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object... validationHints)</span> </span>&#123;</span><br><span class="line">  Object target = getTarget();</span><br><span class="line">  Assert.state(target != <span class="keyword">null</span>, <span class="string">"No target to validate"</span>);</span><br><span class="line">  BindingResult bindingResult = getBindingResult();</span><br><span class="line">  <span class="comment">// Call each validator with the same binding result</span></span><br><span class="line">  <span class="keyword">for</span> (Validator validator : getValidators()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(validationHints) &amp;&amp; validator <span class="keyword">instanceof</span> SmartValidator) &#123;</span><br><span class="line">      ((SmartValidator) validator).validate(target, bindingResult, validationHints);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (validator != <span class="keyword">null</span>) &#123;</span><br><span class="line">      validator.validate(target, bindingResult);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再往下就没啦... Spring 没有具体的实现, 所以要导入 Hibernate 的啥啥啥包, 这是有原因的.</span></span><br></pre></td></tr></table></figure>





<h3 id="有关参数与返回值的一些拦截与干预-RequestBody-ResponseBody"><a href="#有关参数与返回值的一些拦截与干预-RequestBody-ResponseBody" class="headerlink" title="有关参数与返回值的一些拦截与干预(@RequestBody, @ResponseBody)."></a>有关参数与返回值的一些拦截与干预(@RequestBody, @ResponseBody).</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 RequestMappingHandlerAdapter#afterPropertiesSet()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">  initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line">    <span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line">    <span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line">    <span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由上可知, argumentResolvers/returnValueHandlers 都是此时初始化的, 再点进去看代码发现, 除了默认的, 还有用户自定义的 customArgumentResolvers/customReturnValueHandlers;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找字段的引用发现</span></span><br><span class="line">WebMvcConfigurationSupport#addReturnValueHandlers</span><br><span class="line">WebMvcConfigurationSupport#addArgumentResolvers</span><br><span class="line"><span class="comment">// 这两个方法可以继承后加入加入自己的 ArgumentResolvers/ReturnValueHandlers, 也就是项目里面继承 WebMvcConfiguration 的那个类, 重写这两个方法, 加入自己的类即可实现对参数/返回值的干预; 常用于统一加密/解密, 记录日志等.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除此之外, 两边的默认值都有 RequestResponseBodyMethodProcessor, 这就是用于处理@RequestBody/@ResponseBody 的了, 往里面深入的看, 能看到其使用 messageConverters 读取 body 数据, 然后也会在对应的地方触发 advice 的方法.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters</span></span><br><span class="line"><span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">  Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();</span><br><span class="line">  GenericHttpMessageConverter&lt;?&gt; genericConverter =</span><br><span class="line">    (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (genericConverter != <span class="keyword">null</span> ? genericConverter.canRead(targetType, contextClass, contentType) :</span><br><span class="line">      (targetClass != <span class="keyword">null</span> &amp;&amp; converter.canRead(targetClass, contentType))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message.hasBody()) &#123;</span><br><span class="line">      HttpInputMessage msgToUse =</span><br><span class="line">        getAdvice().beforeBodyRead(message, parameter, targetType, converterType);</span><br><span class="line">      body = (genericConverter != <span class="keyword">null</span> ? genericConverter.read(targetType, contextClass, msgToUse) :</span><br><span class="line">              ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));</span><br><span class="line">      body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, message, parameter, targetType, converterType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="参数的N种绑定方式"><a href="#参数的N种绑定方式" class="headerlink" title="参数的N种绑定方式"></a>参数的N种绑定方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 RequestMappingHandlerAdapter#getDefaultArgumentResolvers</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type-based argument resolution</span></span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Custom arguments</span></span><br><span class="line">  <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Catch-all</span></span><br><span class="line">  resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">  resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看几个常见的</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.RequestParamMethodArgumentResolver: 负责解析带 @RequestParam 注解的普通参数</span><br><span class="line">2.RequestParamMapMethodArgumentResolver: 负责解析带 @RequestParam 的 Map 参数....</span><br><span class="line">3.PathVariableMethodArgumentResolver/PathVariableMapMethodArgumentResolver: 同上解析带 @PathVariable 注解的参数</span><br><span class="line">4.RequestResponseBodyMethodProcessor: 负责解析带 @RequestBody 的参数</span><br><span class="line">5.RequestHeaderMethodArgumentResolver: 负责解析带 @RequestHeader 的参数 (表示没用过)</span><br><span class="line">6.ServletRequestMethodArgumentResolver: 负责解析 HttpServletRequest 等类型的参数(即 req, 用的贼多)</span><br><span class="line">7.ServletResponseMethodArgumentResolver: 负责解析 HttpServletResponse 等类型的参数(即 resp, 下载接口没少用)</span><br><span class="line">8.RequestParamMethodArgumentResolver: 啥都解析.... 即不带任何注解的普通类型.</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2021/01/24/source-code-spring-boot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/source-code-spring-boot/" class="post-title-link" itemprop="url">Spring Boot 源码笔记</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-24 02:04:22" itemprop="dateCreated datePublished" datetime="2021-01-24T02:04:22+08:00">2021-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 19:51:57" itemprop="dateModified" datetime="2021-03-28T19:51:57+08:00">2021-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/source-code/" itemprop="url" rel="index"><span itemprop="name">source-code</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring-boot/" itemprop="url" rel="index"><span itemprop="name">spring-boot</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/24/source-code-spring-boot/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/24/source-code-spring-boot/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Boot-源码分析"><a href="#Spring-Boot-源码分析" class="headerlink" title="Spring Boot 源码分析"></a>Spring Boot 源码分析</h1><h2 id="run-流程"><a href="#run-流程" class="headerlink" title="run 流程"></a>run 流程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.StopWatch 提供的计算耗时的功能, 创建一个后立即开始计时.</span><br><span class="line">2.创建一个引导容器, 并在此时(容器未使用前)把 spring.factories 找到 Bootstrapper 接口的类对应的方法触发, 来给引导容器里注册一些东西(如果有需要)</span><br><span class="line">3.从 spring.factories 找 SpringApplicationRunListener 的类, 实例化后存到 SpringApplicationRunListeners 中.</span><br><span class="line">4.触发所有存入的 SpringApplicationRunListener 的 starting 事件.</span><br><span class="line">5.将 args 内容中的参数们(类似 --spring.port=9999)解析成键值对存到 applicationArguments 对象中.</span><br><span class="line">6.创建了一个 environment 对象, 添加了好几个功能各异的 PropertySource, 触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件</span><br><span class="line">7.根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里, 根据 this.banner 判断打印什么样的 Banner (佛祖保佑.png)</span><br><span class="line">8.根据 web 类型创建不同的 ApplicationContext, 这里的创建, 仅实例化而已, 没有从构造方法调用 loadBeanDefinitions 和 refresh 的逻辑</span><br><span class="line">9.将 applicationStartup (步骤记录器)赋值给 context.</span><br><span class="line">10.对容器做些配置, 然后发布 contextPrepared 事件, 接着关闭引导容器; 然后使用 BeanDefinitionLoader 扫描解析 getAllSources (如Class) 并将得到的 BeanDefinition 注册到容器, 最后发布 contextLoaded 事件</span><br><span class="line">11.注册一个钩子, 当 JVM 关闭时, 相应的关闭 context, 然后调用容器的 refresh 方法(然后进入到 Spring 源码分析那段, 自行脑补)</span><br><span class="line">12.StopWatch 计时器停止计时, 接着打印计时数据</span><br><span class="line">13.发布 started 事件</span><br><span class="line">14.从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span><br><span class="line">15.catch 到异常则发布 failed 事件</span><br><span class="line">16.发布 running 事件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从整体结构下来, 我们发现, 其主要是创建了一个引导容器(似乎也就是事件监听用到了, 其他地方完全无瓜), 然后扫描得到一些 SpringApplicationRunListener 存起来, 之后在合适的地方发布事件, 然后创建以及配置 environment 对象, 创建以及配置 ApplicationContext 对象, 解析 primarySources 来加载 BeanDefinition 到容器, 然后调用容器的 refresh 方法进入 Spring 的加载流程, 最后处理事件和调用 ApplicationRunner/CommandLineRunner 的 bean. 其中 加载 BeanDefinition 和执行  refresh 方法其实就是与 Spring 一样的逻辑.</p>
</blockquote>
<h3 id="SpringApplication-与-ApplicationContext-的关系与联系"><a href="#SpringApplication-与-ApplicationContext-的关系与联系" class="headerlink" title="SpringApplication 与 ApplicationContext 的关系与联系"></a>SpringApplication 与 ApplicationContext 的关系与联系</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.SpringApplication 有独特的 environment 对象, 这是因为 application.xml 配置以及 Spring Cloud Config 这些都需要在容器创建前加载配置文件.</span><br><span class="line">2.ApplicationContext 是 new 的时候就会立刻触发 加载 BeanDefinition 和 refresh(), 而 SpringApplication 则是先 new 一个, 配置好后, 才分别调用方法去 加载 BeanDefinition 和 refresh().</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总得来讲, SpringApplication 相比 ApplicationContext 多出的就是 SpringApplicationRunListener 的事件管理, environment 对象加载与配置, 以及 run 方法的生命周期.</span><br></pre></td></tr></table></figure>



<h3 id="这些-SpringApplicationRunListener-事件都被谁监听了-有什么作用"><a href="#这些-SpringApplicationRunListener-事件都被谁监听了-有什么作用" class="headerlink" title="这些 SpringApplicationRunListener 事件都被谁监听了, 有什么作用?"></a>这些 SpringApplicationRunListener 事件都被谁监听了, 有什么作用?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 spring-boot-project/spring-boot/src/main/resources/META-INF/spring.factories</span></span><br><span class="line"><span class="comment">#   有一个 SpringApplicationRunListener, 其作用是:</span></span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br><span class="line">1.构造方法: 初始化一个事件广播器, 并将 SpringApplication 的 listeners 注册进去. (listeners 是在构造方法中从 spring.factories 加载 ApplicationListener 得到的数据)</span><br><span class="line">2.转发 starting,environmentPrepared,contextPrepared,contextLoaded 事件给 ApplicationListener</span><br><span class="line">3.在 contextLoaded 事件时, 遍历所有的 ApplicationListener 对象, 若其实现了 ApplicationContextAware 接口, 则将 context 注入.</span><br><span class="line">4.started,running,failed 事件均直接用 context.publishEvent 发布事件, 与 listeners 无关 (而且 listeners 这些东西如果仅配置在 spring.factories 而没有被扫描到容器内, 那么就是真的无关了)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结: 配置在 spring.factories 的 ApplicationListener 并不会触发所有 run 生命周期的事件. 因此有时实现 SpringApplicationRunListener 还是很有必要的) 当然, 若你写的 ApplicationListener 即配置在 spring.factories 中也会被扫描到容器内, 则无此忧虑.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着看 ApplicationListener 的作用</span></span><br><span class="line">1.ClearCachesApplicationListener: 在 ContextRefreshedEvent(容器加载完后) 清空缓存</span><br><span class="line">2.ParentContextCloserApplicationListener: 给子容器加一个监听, 使得父容器关闭后, 子容器也跟着关闭(还会递归子容器的容器吧.png)</span><br><span class="line">3.FileEncodingApplicationListener: 对比配置的编码格式, 不符合则报异常(若配置了)</span><br><span class="line">4.DelegatingApplicationListener: 新建一个事件广播器, 将配置文件中 context.listener.classes 的 class 实例化并作为监听者注册到广播器, 然后转发所有事件.</span><br><span class="line">5.EnvironmentPostProcessorApplicationListener</span><br><span class="line">    接受 ApplicationEnvironmentPreparedEvent 事件, 然后把从 spring.factories 获得的 EnvironmentPostProcessor 的 classNames 实例化, 然后遍历执行 postProcessEnvironment(), 其中 ConfigFileApplicationListener 用于加载 application.xxx(yml,xml,properties) 文件的配置到 environment 中的 PropertySource 里. (另外一提, Spring Cloud Config 应该也是这里实现的)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结: 原来配置文件是这么被加载进去的, 没有在主流程中写, 而是监听事件, 再调用 EnvironmentPostProcessor, 层层封装, 扩展性好强(读起来也好蓝).</span></span><br></pre></td></tr></table></figure>



<h3 id="超长源码注释"><a href="#超长源码注释" class="headerlink" title="超长源码注释"></a>超长源码注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们从源码的 spring-boot/spring-boot-tests/spring-boot-smoke-tests/spring-boot-smoke-test-tomcat 下, 找到 SampleTomcatApplication.java 类, 直接看它的 main 方法.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  SpringApplication.run(SampleTomcatApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着, 我们点进 run 方法, 瞧瞧里面干了啥</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看起来不多嘛......(看前如是写道, 看完已是凌晨四点)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.StopWatch 提供的计算耗时的功能, 创建一个后立即开始计时.</span></span><br><span class="line">  <span class="comment">// 2.创建一个引导容器, 并在此时(容器未使用前)把 spring.factories 找到 Bootstrapper 接口的类对应的方法触发, 来给引导容器里注册一些东西(如果有需要)</span></span><br><span class="line">  <span class="comment">// 3.从 spring.factories 找 SpringApplicationRunListener 的类, 实例化后存到 SpringApplicationRunListeners 中.</span></span><br><span class="line">  <span class="comment">// 4.触发所有存入的 SpringApplicationRunListener 的 starting 事件.</span></span><br><span class="line">  <span class="comment">// 5.将 args 内容中的参数们(类似 --spring.port=9999)解析成键值对存到 applicationArguments 对象中.</span></span><br><span class="line">  <span class="comment">// 6.创建了一个 environment 对象, 添加了好几个功能各异的 PropertySource, 触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件</span></span><br><span class="line">  <span class="comment">// 7.根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里, 根据 this.banner 判断打印什么样的 Banner (佛祖保佑.png)</span></span><br><span class="line">  <span class="comment">// 8.根据 web 类型创建不同的 ApplicationContext, 这里的创建, 仅实例化而已, 没有从构造方法调用 loadBeanDefinitions 和 refresh 的逻辑</span></span><br><span class="line">  <span class="comment">// 9.将 applicationStartup (步骤记录器)赋值给 context.</span></span><br><span class="line">  <span class="comment">//10.对容器做些配置, 然后发布 contextPrepared 事件, 接着关闭引导容器; 然后根据 primarySource 使用 BeanDefinitionLoader 加载 BeanDefinition 到容器, 最后发布 contextLoaded 事件</span></span><br><span class="line">  <span class="comment">//11.注册一个钩子, 当 JVM 关闭时, 相应的关闭 context, 然后调用容器的 refresh 方法(然后进入到 Spring 源码分析那段, 自行脑补)</span></span><br><span class="line">  <span class="comment">//12.计时器停止计时, 接着打印计时数据</span></span><br><span class="line">  <span class="comment">//13.发布 started 事件</span></span><br><span class="line">  <span class="comment">//14.从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span></span><br><span class="line">  <span class="comment">//15.catch 到异常则发布 failed 事件</span></span><br><span class="line">  <span class="comment">//16.发布 running 事件</span></span><br><span class="line"></span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  stopWatch.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个引导容器, 并在此时(容器未使用前)从 spring.factories 扫描一些实现了 Bootstrapper 接口的类, 来给引导容器里注册一些东西(如果有需要)</span></span><br><span class="line">  DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">  ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往系统变量里设置一个变量 headless, 看上去和 AWT 有关, 暂且忽略之</span></span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扫描 spring.factories 中配置的实现了 SpringApplicationRunListener 的类们</span></span><br><span class="line">  <span class="comment">//   实例化后放到 SpringApplicationRunListeners (其就是个容器管理类) 存起来.</span></span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发所有存入的 SpringApplicationRunListener 的 starting 事件.</span></span><br><span class="line">  listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将 args 内容中的参数(类似 --spring.port=9999)解析成键值对存到 applicationArguments 对象中.</span></span><br><span class="line">    ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个 environment 对象, 添加了好几个功能各异的 PropertySource,</span></span><br><span class="line">    <span class="comment">//   触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件</span></span><br><span class="line">    <span class="comment">//   将 environment 中 spring.main 开头的配置数据, 一一对应绑定到 SpringApplication(即this)的字段上去</span></span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 environment 的 spring.beaninfo.ignore 配置复制到 System.Property 去(若不存在)</span></span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里, 根据 this.banner 判断打印什么样的 Banner (佛祖保佑.png)</span></span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 web 类型创建不同的 ApplicationContext, 但其实差别不大, 就时多了 web 容器的特征(如启动 tomcat)</span></span><br><span class="line">    <span class="comment">// 另外与 Spring 源码分析时不同, 这里的创建, 仅实例化而已, 没有从构造方法调用 loadBeanDefinitions 和 refresh 的逻辑</span></span><br><span class="line">    context = createApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 applicationStartup (步骤记录器)赋值给 context.</span></span><br><span class="line">    context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 context 做一些配置, 执行 initializers 的 initialize()</span></span><br><span class="line">    <span class="comment">// 发布 contextPrepared 事件</span></span><br><span class="line">    <span class="comment">// 关闭引导容器, 即发布 BootstrapContextClosedEvent 事件给之前加的 closeListener (监听者)</span></span><br><span class="line">    <span class="comment">// 使用 BeanDefinitionLoader 根据 sources 和 run 方法参数 primarySource 加载 BeanDefinition 到容器中.</span></span><br><span class="line">    <span class="comment">// 发布 contextLoaded 事件</span></span><br><span class="line">    prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个钩子, 当 JVM 关闭时, 相应的关闭 context, 然后调用容器的 refresh 方法(然后进入到 Spring 源码分析那段, 自行脑补)</span></span><br><span class="line">    refreshContext(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类扩展吧</span></span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计时器停止计时, 接着打印计时数据</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">      <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布 started 事件</span></span><br><span class="line">    listeners.started(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span></span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 发布 failed 事件</span></span><br><span class="line">    handleRunFailure(context, ex, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 发布 running 事件</span></span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 发布 failed 事件</span></span><br><span class="line">    handleRunFailure(context, ex, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>温馨提示: 先在想看的地方打断点, 在打开调试模式, 可以清楚的看到对应的变量变化情况, 以此理解代码!</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来看看所有过程涉及方法的注释(大多数)</span></span><br><span class="line">org.springframework.boot.SpringApplication#createBootstrapContext</span><br><span class="line">    <span class="comment">// 1.创建一个引导容器(这个容器作用和 BeanFactory 类似, 但更简单得多, 仅有获取/注册 bean 对象等的功能)</span></span><br><span class="line">		<span class="comment">//   触发存于 this.bootstrappers 的对象的 intitialize 方法来对引导容器进行初始化(即可以在引导容器未使用前往里面注册 bean 对象)</span></span><br><span class="line">		<span class="comment">//   然后 this.bootstrappers 的数据有一部分是从 spring.factories 找 Bootstrapper 的类实例化后得到的, 然后也可以代码手动添加</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#getRunListeners</span><br><span class="line">    <span class="comment">// 扫描 spring.factories 中配置的实现了 SpringApplicationRunListener 的类, 并调用形如 types 的参数的构造函数来实例化得到对象集合</span></span><br><span class="line">		<span class="comment">//   再将这些对象集合放到 SpringApplicationRunListeners(其就是个容器管理类)中.</span></span><br><span class="line">		<span class="comment">// 并绑定 applicationStartup (步骤记录器)</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplicationRunListeners#doWithListeners(java.lang.String, java.util.function.Consumer&lt;org.springframework.boot.SpringApplicationRunListener&gt;, java.util.function.Consumer&lt;org.springframework.core.metrics.StartupStep&gt;)</span><br><span class="line">    <span class="comment">// 遍历持有的所有 SpringApplicationRunListener, 触发对应事件</span></span><br><span class="line">		<span class="comment">// 在触发监听事件前后加入 StartupStep 监听所耗时间</span></span><br><span class="line">		<span class="comment">// 步骤监听器的 accept 处理</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#prepareEnvironment</span><br><span class="line">    <span class="comment">// 1.根据 web 类型创建一个 environment 对象</span></span><br><span class="line">		<span class="comment">// 2.配置 environment</span></span><br><span class="line">		<span class="comment">//     通过 ConversionService 类添加一些类型转换支持(如文件大小1024k=1M等)</span></span><br><span class="line">		<span class="comment">//     将用户设置的 defaultProperties 添加到 environment 的 sources 中, 将 args 解析成一个 PropertySource 后加入到 environment 中</span></span><br><span class="line">		<span class="comment">// 3.为 environment 添加一个名为 configurationProperties 的源, 其作用是将每一个 PropertySource 适配成 ConfigurationPropertySource.</span></span><br><span class="line">		<span class="comment">// 4.触发所有存入的 SpringApplicationRunListener 的 environmentPrepared 事件.</span></span><br><span class="line">		<span class="comment">// 5.将名为 defaultProperties 的 Property 源移最后(降低优先级), 另此 defaultProperties 不是 this.defaultProperties</span></span><br><span class="line">		<span class="comment">// 6.将用户通过代码设置的要附加的 profile 设置到 activeProfiles 中去 (若存在且 environment 中不存在)</span></span><br><span class="line">		<span class="comment">// 7.将 environment 中 spring.main 开头的配置数据, 一一对应绑定到 SpringApplication(即this)的字段上去</span></span><br><span class="line">		<span class="comment">// 8.若不开启自定义 environment, 则将 environment 转换成 StandardEnvironment(默认行为)</span></span><br><span class="line">		<span class="comment">// 9.由于上一步可能做了转换, 所以需要重新 attach 一次.</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#getOrCreateEnvironment</span><br><span class="line">    <span class="comment">// 1.若存在一个 environment, 则直接返回</span></span><br><span class="line">		<span class="comment">// 2.若不存在, 则根据之前推断得出的 webApplicationType 来创建对应的 Environment 对象.</span></span><br><span class="line">		<span class="comment">// 3.这几个不同的类型区别也不大, 就 StandardServletEnvironment 多了3个 propertySources(其中一个是 JDNI, 比较重要)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#configureEnvironment</span><br><span class="line">    <span class="comment">// 1.通过 ConversionService 类添加一些类型转换支持(如文件大小1024k=1M等)</span></span><br><span class="line">		<span class="comment">// 2.将用户设置的 defaultProperties 添加到 environment 的 sources 中, 将 args 解析成一个 PropertySource 后加入到 environment 中.</span></span><br><span class="line">		<span class="comment">// 3. configureProfiles 是一个空方法, 看来是留给我们实现子类时扩展的.</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.context.properties.source.ConfigurationPropertySources#attach</span><br><span class="line">    <span class="comment">// 为 environment 添加一个名为 configurationProperties 的源, 其作用是将每一个 PropertySource 适配成 ConfigurationPropertySource.</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#configureAdditionalProfiles</span><br><span class="line">    <span class="comment">// 将用户通过代码设置的要附加的 profile 设置到 activeProfiles 中去 (若存在且 environment 中不存在)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#bindToSpringApplication</span><br><span class="line">    <span class="comment">// 将 environment 中的配置数据, 绑定到 SpringApplication(即this)的一些字段上去</span></span><br><span class="line">		<span class="comment">// 绑定规则是 spring.main 开头的配置数据与 SpringApplication 一一对应, 如若存在 spring.main.banner-mode=OFF, 则 this.bannerMode=OFF</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#printBanner</span><br><span class="line">    <span class="comment">// 根据 this.bannerMode 判断是否打印 Banner, 以及打印在哪里</span></span><br><span class="line">		<span class="comment">//   this.banner 为文件路径, 若为空, 则打印 Spring Boot 默认准备的文本(这不换个佛祖保佑?)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#createApplicationContext</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 根据 web 类型创建不同的 ApplicationContext, 但其实差别不大, 就几个细节不同罢了</span></span><br><span class="line">		<span class="comment">// 以 AnnotationConfigServletWebServerApplicationContext 为例, 与 AnnotationConfigApplicationContext 的区别大致为</span></span><br><span class="line">		<span class="comment">//   多加了一个 BeanPostProcessor 用于给 ServletContextAware/ServletConfigAware 接口注入 servletContext/servletConfig 对象</span></span><br><span class="line">		<span class="comment">//   onRefresh() 时, 调用 createWebServer() 启动 tomcat/jetty/undertow</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#prepareContext</span><br><span class="line">    <span class="comment">// 1.设置 environment 对象</span></span><br><span class="line">		<span class="comment">// 2.将 beanNameGenerator 注册到容器中 (若存在), 配置容器的 resourceLoader 和 conversionService (从 SpringApplication 获取)</span></span><br><span class="line">		<span class="comment">// 3.将 initializers 根据 @Order 配置排序后, 遍历执行其 initialize 方法.</span></span><br><span class="line">		<span class="comment">// 4.发布 contextPrepared 事件</span></span><br><span class="line">		<span class="comment">// 5.关闭销毁引导容器(毕竟真正的容器已经准备好了, 这玩意就没用了)</span></span><br><span class="line">		<span class="comment">// 6.为容器添加一些特殊的 bean, 对 beanFactory 做点小设置; 然后添加一个懒加载功能的 BeanFactoryPostProcessor, 作用是将所有的 BeanDefinition 的 lazyInit 设置为 true</span></span><br><span class="line">		<span class="comment">// 7.创建一个 BeanDefinitionLoader, 解析 sources 得到 BeanDefinition 再注册到容器中. 和 Spring 的 new 容器时的 load 过程类似.</span></span><br><span class="line">		<span class="comment">// 8.发布 contextLoaded 事件</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#postProcessApplicationContext</span><br><span class="line">    <span class="comment">// 1.将 beanNameGenerator 注册到容器中 (若存在)</span></span><br><span class="line">		<span class="comment">// 2.将 SpringApplication 的 resourceLoader 赋值给容器 (若存在)</span></span><br><span class="line">		<span class="comment">// 3.为容器设置 ConversionService(类型转换工具)对象 (若配置了允许)</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#load</span><br><span class="line">    <span class="comment">// 创建一个 BeanDefinitionLoader, 解析 sources 得到 BeanDefinition 再注册到容器中. 和 Spring 的 new 容器时的 load 过程类似.</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplication#refreshContext</span><br><span class="line">    <span class="comment">// 1.注册一个钩子, 当 JVM 关闭时, 相应的关闭 context</span></span><br><span class="line">		<span class="comment">// 2.调用容器的 refresh 方法</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">org.springframework.boot.SpringApplication#callRunners</span><br><span class="line">    <span class="comment">// 从容器中取出 ApplicationRunner/CommandLineRunner 两类 bean, 并调用它们的 run 方法.</span></span><br><span class="line">		<span class="comment">// 这里有两个不同点</span></span><br><span class="line">		<span class="comment">//    1. XxxRunner 和 ApplicationListener 有何不同?</span></span><br><span class="line">		<span class="comment">//       答案是 XxxRunner 的 run 方法可以直接取到程序启动的 args 参数, 而监听器要取则还需借助 environment</span></span><br><span class="line">		<span class="comment">//    2.ApplicationRunner 和 CommandLineRunner 有何不同?</span></span><br><span class="line">		<span class="comment">//       答案是 run 方法接受的参数形式不同, 一个是 字符串数组(原始的), 一个是解析好的 key:value 方便直接取用.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>规矩我懂得, GitHub在这 <a href="https://github.com/gudqs7/spring-boot/tree/wq-comment" target="_blank" rel="noopener">注意分支哦</a> </p>
</blockquote>
<h2 id="各种实现的原理"><a href="#各种实现的原理" class="headerlink" title="各种实现的原理"></a>各种实现的原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.application.properties 是如何被加载到 Environment 中的?</span><br><span class="line">2.@ConfigurationProperties 如何实现自动注入`application.properties/application.yml`中配置的值?</span><br><span class="line">3.一些只需要改改依赖jar就可以切换(如tomcat-&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)</span><br><span class="line">4.JdbcTemplateAutoConfiguration如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)</span><br><span class="line">5.为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)</span><br></pre></td></tr></table></figure>



<h3 id="application-properties-是如何被加载到-Environment-中的"><a href="#application-properties-是如何被加载到-Environment-中的" class="headerlink" title="application.properties 是如何被加载到 Environment 中的?"></a>application.properties 是如何被加载到 Environment 中的?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1) run方法中创建了 Environment 对象, 当初始化好一些东西后会触发 environmentPrepared 事件</span><br><span class="line">2) 通过 SpringApplicationRunListener 的 EventPublishingRunListener 转发事件给 ApplicationListener 这类监听者, 即 EnvironmentPostProcessorApplicationListener.</span><br><span class="line">3) 这个类接收事件后, 遍历从 spring.factories 获得的 EnvironmentPostProcessor 对象, 执行其 postProcessEnvironment()</span><br><span class="line">4) 其中 ConfigFileApplicationListener<span class="comment">#postProcessEnvironment() 实现了配置文件的加载</span></span><br><span class="line">5) 具体为 postProcessEnvironment 下的 addPropertySources()</span><br><span class="line">6) 此方法将会扫描指定的路径下指定的某些文件</span><br><span class="line">7) 然后使用 spring.factories 下的 PropertySourceLoader 一一尝试解析</span><br><span class="line">8) 文件存在且解析正确则加入到 environment 的 sources 集合中.</span><br><span class="line">	某些路径: getSearchLocations() ,默认: classpath:/,classpath:/config/ ...</span><br><span class="line">	某些文件: getSearchNames() ,默认: application</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS: </span></span><br><span class="line">PropertySourceLoader 有 PropertiesPropertySourceLoader/YamlPropertySourceLoader</span><br><span class="line">一个尝试后缀有 xml/properties, 另一个是 yml/yaml, 因为是遍历后 load, 所以所有可能性有:</span><br><span class="line">    classpath:/application.xml; classpath:/application.properties</span><br><span class="line">	classpath:/application.yml; classpath:/application.yaml</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>



<h3 id="ConfigurationProperties-如何实现自动注入application-properties-application-yml中配置的值"><a href="#ConfigurationProperties-如何实现自动注入application-properties-application-yml中配置的值" class="headerlink" title="@ConfigurationProperties 如何实现自动注入application.properties/application.yml中配置的值?"></a>@ConfigurationProperties 如何实现自动注入<code>application.properties/application.yml</code>中配置的值?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) 首先加了 @EnableConfigurationProperties 也会解析里面的 @Import </span><br><span class="line">2) @Import 则引入了 EnableConfigurationPropertiesRegistrar.class</span><br><span class="line">3) 这是一个 ImportBeanDefinitionRegistrar 的实现类, 因此调用指定方法 registerBeanDefinitions</span><br><span class="line">4) 指定方法 registerBeanDefinitions() 会将 @EnableConfigurationProperties 注解的值对应的类注册到容器中, 如 @EnableConfigurationProperties(RabbitProperties.class) 则会加载 RabbitProperties.class</span><br><span class="line">5) 指定方法还注册了一些工具 bean 和一个重要的 BeanPostProcessor 在 registerInfrastructureBeans()中</span><br><span class="line">6) 即 ConfigurationPropertiesBindingPostProcessor, 当我们要使用配置文件 bean(如 RabbitProperties)时,会实例化 bean 并触发 postProcessorBeforeInitialization()</span><br><span class="line">7) 在 postProcessorBeforeInitialization() 中, 通过 org.springframework.boot.context.properties.ConfigurationPropertiesBinder<span class="comment">#bind() 来完成实际的绑定</span></span><br><span class="line">8) 其本质就是 Binder 的 <span class="built_in">bind</span> 方法, 设定配置文件前缀即可将配置文件中的配置对应的绑定到 bean(如 rabbitProperties 对象) 中.</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS</span></span><br><span class="line">这里的 Binder 和 SpringApplication 里绑定 spring.main 开头配置文件那个类是同一个.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">就是先将 XxxProperties 类注册到容器中, 这样就可以通过 BeanPostProcessor 再实例化后将配置文件与属性绑定.</span><br></pre></td></tr></table></figure>



<h3 id="一些只需要改改依赖jar就可以切换-如tomcat–-gt-undertow-是怎么做到的-ConditionalXxx-的实现原理"><a href="#一些只需要改改依赖jar就可以切换-如tomcat–-gt-undertow-是怎么做到的-ConditionalXxx-的实现原理" class="headerlink" title="一些只需要改改依赖jar就可以切换(如tomcat–&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)"></a>一些只需要改改依赖jar就可以切换(如tomcat–&gt;undertow)是怎么做到的? (@ConditionalXxx 的实现原理)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1) 在类上加上注解 @Conditional 或带有 @Conditional 的其他注解(即注解的子类亦会扫描)</span><br><span class="line">2) 在所有的扫描类和注解的地方,如解析@Configuration, AnotatedBeanDefinitionReader 等 reader</span><br><span class="line">    会使用 ConditionEvaluator 的 shouldSkip() 判断是否可以加载, 时机点如下</span><br><span class="line">    AnnotatedBeanDefinitionReader<span class="comment">#doRegisterBean() 的第二行代码</span></span><br><span class="line">    ConfigurationClassBeanDefinitionReader<span class="comment">#loadBeanDefinitionsForBeanMethod() 第四行</span></span><br><span class="line">    ConfigurationClassBeanDefinitionReader<span class="comment">#loadBeanDefinitionsForConfigurationClass()</span></span><br><span class="line">    ConfigurationClassParser<span class="comment">#doProcessConfigurationClass() 处理 ComponentScan 那段</span></span><br><span class="line">3) 然后再 shouldSkip 中判断， 判断逻辑大致如下：</span><br><span class="line">    先遍历所有注解取得所有的 @Conditional 的 value, 这个 value 是具体的 Condition 实现, 如 OnClassCondition(实现了 Condition 的 matches 接口, 很多抽象类用以增强代码扩展性), 然后其加入到 conditions 中, 排序后遍历调用 matches(), 一个不匹配则返回 <span class="literal">true</span>, 代表应该跳过.</span><br><span class="line"></span><br><span class="line"><span class="comment"># TIPS:</span></span><br><span class="line">ConditionOutcome 封装了是否匹配和匹配日志信息[为啥成功/为啥失败]</span><br><span class="line">SpringBootCondition 提供了通用的根据 ConditionOutcome 判断是否匹配并记录日志信息的抽象类.</span><br><span class="line">    子类只需实现 getMatchOutcome(): 根据 metadata[注解信息] 返回 ConditionOutcome 对象.</span><br><span class="line">    因此, 如果我们要实现自己的 Condition, 可以继承它.</span><br></pre></td></tr></table></figure>



<h3 id="JdbcTemplateAutoConfiguration-如何确保能够获取到-DataSource-AutoConfigureAfter-的实现原理"><a href="#JdbcTemplateAutoConfiguration-如何确保能够获取到-DataSource-AutoConfigureAfter-的实现原理" class="headerlink" title="JdbcTemplateAutoConfiguration 如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)"></a>JdbcTemplateAutoConfiguration 如何确保能够获取到 DataSource? (@AutoConfigureAfter 的实现原理)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1) 首先所有的 XxxAutoConfiguration 都是借助 AutoConfigurationImportSelector 加载的, 其继承了 DeferredImportSelector.  </span><br><span class="line">2) 这种 DeferredImportSelector 会延迟加载, 原理是 parse 后再加载, 而非 parse 执行过程中就加载.</span><br><span class="line">3) 延迟加载机制 会先调用 process 方法, 将要加载的 class 保存起来, 然后再调用 selectImports 返回.</span><br><span class="line">4) 此时 AutoConfigurationImportSelector.AutoConfigurationGroup 的 selectImports() 会调用 sortAutoConfigurations(), 也就是调用了 AutoConfigurationSorter.getInPriorityOrder()</span><br><span class="line">5) getInPriorityOrder() 调用了 sortByAnnotation() 这个方法根据2个注解 @AutoConfigureBefore/@AutoConfigureAfter 排序.</span><br><span class="line">6) 最后返回的就是有序的了. 另外, 这两个注解只能作用在 spring.factories 中 EnableAutoConfiguration 的类上才有效.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结:</span></span><br><span class="line">利用 DeferredImportSelector 的延迟加载, 将所有的 AutoConfiguration 所引入的 class 先存起来不加载, 然后又加入排序的逻辑, 使得真正加载时会根据排序结果依次加载.</span><br></pre></td></tr></table></figure>



<h3 id="为什么-Spring-Boot-启动-main-方法就能访问-Tomcat-SpringApplication-run-启动-tomcat-实现原理"><a href="#为什么-Spring-Boot-启动-main-方法就能访问-Tomcat-SpringApplication-run-启动-tomcat-实现原理" class="headerlink" title="为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)"></a>为什么 Spring Boot 启动 main 方法就能访问 Tomcat? (SpringApplication.run() 启动 tomcat 实现原理)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1) main 方法会调用 SpringApplication 的 run 方法, 里面会创建 applicationContext, 如是 webApplicationType = SERVLET, 则实现类为 AnnotationConfigServletWebServerApplicationContext</span><br><span class="line">    另外一提, webApplicationType 是根据 classpath 下是否有哪些类来推断的.</span><br><span class="line">2) 这个类继承了 ServletWebServerApplicationContext</span><br><span class="line">3) ServletWebServerApplicationContext 实现了 onRefresh()</span><br><span class="line">4) onRefresh() 调用了 createWebServer()</span><br><span class="line">5) createWebServer() 使用 ServletWebServerFactory.getWebServer() 获取 webServer 对象</span><br><span class="line">6) ServletWebServerFactory 的具体实现类由 ServletWebServerFactoryAutoConfiguration 引入</span><br><span class="line">    详细见 ServletWebServerFactoryConfiguration.EmbeddedTomcat.class</span><br><span class="line">7) 引入后调用 getWebServer(), 大概为 new Tomcat(), 绑定配置文件到 Tomcat 的一些属性上, 然后启动它.</span><br><span class="line">8) 至此, run() 启动了 tomcat/jetty/undertow.</span><br><span class="line"> </span><br><span class="line"><span class="comment"># TIPS:</span></span><br><span class="line">Spring 使用工厂模式获取不同的 webServer, 而不同的 webServer 实现类其实是用 XxxAutoConfiguration 来自动注入的(还可以配合 @Conditional 决定何时加载).</span><br><span class="line">这样如果新增一种 webServer, 只需要在写一个 XxxAutoConfiguration 注册一个 webServer 实现类的 bean 即可, 非常灵活(非常 nice).</span><br></pre></td></tr></table></figure>





<h2 id="常见的-XxxAutoConfiguration"><a href="#常见的-XxxAutoConfiguration" class="headerlink" title="常见的 XxxAutoConfiguration"></a>常见的 XxxAutoConfiguration</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.连接池</span><br><span class="line">   DataSourceAutoConfiguration 会 Import DataSourceConfiguration.Hikari.class</span><br><span class="line">2.Mybatis</span><br><span class="line">   MybatisAutoConfiguration: 注册并配置了 SqlSessionFactory/SqlSessionTemplate</span><br><span class="line">3.Spring MVC</span><br><span class="line">   DispatcherServletAutoConfiguration: 配置前端控制器和文件上传处理器</span><br><span class="line">   ServletWebServerFactoryAutoConfiguration: 注册 WebServerFactory 的实现类 bean</span><br><span class="line">4.RocketMQ</span><br><span class="line">   RabbitAutoConfiguration: 注册并配置 RabbitTemplate</span><br><span class="line">5.Redis</span><br><span class="line">   RedisAutoConfiguration: 注册并配置 RedisTemplate/StringRedisTemplate</span><br><span class="line">6.邮件发送</span><br><span class="line">   MailSenderAutoConfiguration: 注册并配置 JavaMailSenderImpl</span><br><span class="line">7.MyBatis-Plus</span><br><span class="line">   MybatisPlusAutoConfiguration: 注册 SqlSessionFactory, 并配置了其 plugins, 使 Mybatis-Plus 生效</span><br><span class="line">8.定时任务</span><br><span class="line">   TaskSchedulingAutoConfiguration: 注册 ThreadPoolTaskScheduler</span><br><span class="line">9.AOP</span><br><span class="line">   AopAutoConfiguration: 通过静态内部类加载了 @EnableAspectJAutoProxy</span><br></pre></td></tr></table></figure>



<h2 id="我所见到的设计模式"><a href="#我所见到的设计模式" class="headerlink" title="我所见到的设计模式"></a>我所见到的设计模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.适配器模式: SpringConfigurationPropertySources</span><br><span class="line">    要将 Iterable&lt;PropertySource&lt;?&gt;&gt;</span><br><span class="line">    适配成 Iterable&lt;ConfigurationPropertySource&gt;</span><br><span class="line">    也即是 PropertySource --&gt; ConfigurationPropertySource</span><br><span class="line">  <span class="comment">#其实主要工作是: ConfigurationPropertySource#getConfigurationProperty() 里面调用了 PropertySource#getProperty(), 以此完成适配... 很适配器模式, 存一个未适配的对象, 在适配的方法中调用存储的对象的要适配的方法. </span></span><br><span class="line">  </span><br><span class="line">2.简单工厂模式: org.springframework.boot.ApplicationContextFactory<span class="comment">#create</span></span><br><span class="line">    根据 webApplicationType 创建不同的 ConfigurableApplicationContext</span><br><span class="line">  </span><br><span class="line">3.观察者模式: </span><br><span class="line">	监听者: SpringApplicationRunListener</span><br><span class="line">  观察对象: SpringApplication 的生命周期(starting/environmentPrepared/contextPrepared/contextLoaded/started/running/failed)</span><br><span class="line">  管理者: SpringApplicationRunListeners, 负责遍历监听者广播对应事件</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2020/05/20/Go-study-memo-3-method-and-interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/Go-study-memo-3-method-and-interface/" class="post-title-link" itemprop="url">Go学习笔记 (三) : method 和 interface</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 09:24:19" itemprop="dateCreated datePublished" datetime="2020-05-20T09:24:19+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-22 13:39:17" itemprop="dateModified" datetime="2021-01-22T13:39:17+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/20/Go-study-memo-3-method-and-interface/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/20/Go-study-memo-3-method-and-interface/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为了面向对象-首先你得有个对象"><a href="#为了面向对象-首先你得有个对象" class="headerlink" title="为了面向对象(首先你得有个对象)"></a>为了面向对象(首先你得有个对象)</h1><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><h3 id="定义一个method"><a href="#定义一个method" class="headerlink" title="定义一个method"></a>定义一个method</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">growup</span><span class="params">()</span></span> &#123;  <span class="comment">//想想去掉 * 会怎样?</span></span><br><span class="line">	p.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	p := Person&#123;<span class="string">"wq"</span>,<span class="number">10</span>&#125;</span><br><span class="line">	<span class="built_in">println</span>(p, p.name, p.age)</span><br><span class="line">	p.growup()</span><br><span class="line">	<span class="built_in">println</span>(p.age)</span><br><span class="line">	p.setName(<span class="string">"gudqs"</span>)</span><br><span class="line">	<span class="built_in">println</span>(p.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 func ( 方法属于者 方法属于者类型) 方法名 (方法参数列表) (返回参数列表) {..}定义一个方法<br>传递 指针类型 使结构体值改变<br>所有自定义类型, 和一些内置类型均可作为方法属于者,即可拥有方法</p>
</blockquote>
<h3 id="方法继承"><a href="#方法继承" class="headerlink" title="方法继承"></a>方法继承</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Person</span><br><span class="line">	no <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">sayhi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(p.name,p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	s := Student&#123;Person&#123;<span class="string">"wq"</span>,<span class="number">20</span>&#125;,<span class="number">1</span>,<span class="string">"110"</span>&#125;</span><br><span class="line">	s.sayhi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用匿名字段可继承改字段类型的方法 同样的可以直接调用</p>
</blockquote>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><blockquote>
<p>在之前代码 后添加一个 Student 的sayhi方法 , 实现重写</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">sayhi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(s.name,s.no,s.phone,s.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看执行结果, 如果学过java ,你一定已经露出了纯洁的笑容       : ) </p>
</blockquote>
<h3 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h3><blockquote>
<p>在方法定义时 , 方法属于者类型 为一个指针时, 方法种操作 指针不需要 加 *也可, go会自动加<br>不能为 int , []int 等类型 添加方法, 但通过自定义类型 ,如 type Int int , 则又可以添加方法 ,因此自定义类型具有高扩展性啊</p>
</blockquote>
<h2 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface (接口)"></a>interface (接口)</h2><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserDao <span class="keyword">interface</span> &#123;</span><br><span class="line">	add()</span><br><span class="line">	update()</span><br><span class="line">	remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> f <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserDao <span class="keyword">interface</span> &#123;</span><br><span class="line">	add(u User)</span><br><span class="line">	update(u User)</span><br><span class="line">	remove(u User)</span><br><span class="line">	findAll() []User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserDaoMysqlImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserDaoOracleImpl <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao UserDaoMysqlImpl)</span> <span class="title">add</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">	f.Println(<span class="string">"add user[mysql] :"</span>,u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao UserDaoMysqlImpl)</span> <span class="title">update</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">	f.Println(<span class="string">"update user[mysql] :"</span>,u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao UserDaoMysqlImpl)</span> <span class="title">remove</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">	f.Println(<span class="string">"remove user[mysql] :"</span>,u.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao UserDaoOracleImpl)</span> <span class="title">add</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">	f.Println(<span class="string">"add user[oralce] :"</span>,u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao UserDaoOracleImpl)</span> <span class="title">update</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">	f.Println(<span class="string">"update user[oracle] :"</span>,u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao UserDaoOracleImpl)</span> <span class="title">remove</span><span class="params">(u User)</span></span> &#123;</span><br><span class="line">	f.Println(<span class="string">"remove user[oracle] :"</span>,u.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao UserDaoMysqlImpl)</span> <span class="title">findAll</span><span class="params">()</span> []<span class="title">User</span></span> &#123;</span><br><span class="line">	users := <span class="built_in">make</span>([]User,<span class="number">3</span>)</span><br><span class="line">	users[<span class="number">0</span>], users[<span class="number">1</span>], users[<span class="number">2</span>] = User&#123;<span class="string">"wq"</span>,<span class="number">1</span>&#125;, User&#123;<span class="string">"aa"</span>,<span class="number">2</span>&#125;, User&#123;<span class="string">"gudqs"</span>,<span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao UserDaoOracleImpl)</span> <span class="title">findAll</span><span class="params">()</span> []<span class="title">User</span></span> &#123;</span><br><span class="line">	users := <span class="built_in">make</span>([]User,<span class="number">3</span>)</span><br><span class="line">	users[<span class="number">0</span>] = User&#123;<span class="string">"gg"</span>,<span class="number">007</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> users</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> dao UserDao</span><br><span class="line">	u := User&#123;<span class="string">"qq"</span>,<span class="number">88</span>&#125;</span><br><span class="line">	dao =UserDaoOracleImpl&#123;&#125;</span><br><span class="line">	dao.add(u)</span><br><span class="line">	dao.update(u)</span><br><span class="line">	dao.remove(u)</span><br><span class="line">	<span class="keyword">for</span> i,u := <span class="keyword">range</span> dao.findAll() &#123;</span><br><span class="line">		f.Println(i,u)</span><br><span class="line">	&#125;</span><br><span class="line">	dao =UserDaoMysqlImpl&#123;&#125;</span><br><span class="line">	dao.add(u)</span><br><span class="line">	dao.update(u)</span><br><span class="line">	dao.remove(u)</span><br><span class="line">	<span class="keyword">for</span> j,u2 := <span class="keyword">range</span> dao.findAll() &#123;</span><br><span class="line">		f.Println(<span class="string">"mysql:"</span>,j,u2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个东东 具有 某个接口的所有方法, 那么这个东东 可以赋值给这个接口类型的变量<br>这个特性说白了就是类似多态</p>
</blockquote>
<h3 id="接口类型-作为函数-方法-参数"><a href="#接口类型-作为函数-方法-参数" class="headerlink" title="接口类型 作为函数(方法) 参数"></a>接口类型 作为函数(方法) 参数</h3><p>在上面代码基础上添加 如下代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserServiceImpl <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(service UserServiceImpl)</span> <span class="title">add</span><span class="params">(u User, dao UserDao)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"service do :"</span>)</span><br><span class="line">	dao.add(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	service := UserServiceImpl&#123;&#125;</span><br><span class="line">	u := User&#123;<span class="string">"wq"</span>,<span class="number">20</span>&#125;</span><br><span class="line">	dao := UserDaoMysqlImpl&#123;&#125;</span><br><span class="line">	service.add(u,dao)</span><br><span class="line">	dao =UserDaoOracleImpl&#123;&#125;</span><br><span class="line">	service.add(u,dao)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加类型UserServiceImpl和对应的add方法, 使用UserDao作为参数, 然后修改main()</p>
<blockquote>
<p> 方法参数为接口类型, 好处是 可以接受更多的类型 , 只要那种类型有 这个接口的所有方法</p>
</blockquote>
<h3 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> a <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">99</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"wq"</span></span><br><span class="line">	a = i</span><br><span class="line">	<span class="built_in">println</span>(a)</span><br><span class="line">	a = str</span><br><span class="line">	<span class="built_in">println</span>(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样 a类型 就可以接受任何类型了, 就像 java 的Object类型一样 !</p>
</blockquote>
<h3 id="嵌套-interface"><a href="#嵌套-interface" class="headerlink" title="嵌套 interface"></a>嵌套 interface</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> a <span class="keyword">interface</span> &#123;</span><br><span class="line">	swap()</span><br><span class="line">	<span class="built_in">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> b <span class="keyword">interface</span> &#123;</span><br><span class="line">	a</span><br><span class="line">	value()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后b就有了 3个方法 , 对的, 想匿名字段继承一样</p>
</blockquote>
<h3 id="Comma-ok断言"><a href="#Comma-ok断言" class="headerlink" title="Comma-ok断言"></a>Comma-ok断言</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> a <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> b <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	list := <span class="built_in">make</span>([]a,<span class="number">3</span>)</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="string">"wq"</span></span><br><span class="line">	a[<span class="number">2</span>] = b&#123;<span class="string">"wq"</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _,element := <span class="keyword">range</span> list &#123;</span><br><span class="line">		ok,val := element.(b)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">" b is a a"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		ok,val = element.(<span class="keyword">int</span>)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"int is a a"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//solution 2</span></span><br><span class="line">	<span class="keyword">for</span> _,ele := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">switch</span> value :=ele.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="keyword">int</span> :</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">"ele is an int"</span>,)</span><br><span class="line">			<span class="keyword">case</span> b :</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">"ele is a b"</span>)</span><br><span class="line">			<span class="keyword">default</span> :</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">"ele is default type"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过 变量.(类型) 获得返回值 ok 判断 该变量存的是否是 该类型<br>变量.(type) 仅在switch中 可以使用</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2020/05/20/Go-study-memo-2-if-for-switch-and-func-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/Go-study-memo-2-if-for-switch-and-func-struct/" class="post-title-link" itemprop="url">Go学习笔记 (二) : 流程控制(if,for,switch) 与 函数 与 struct (匿名字段)</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 09:21:55" itemprop="dateCreated datePublished" datetime="2020-05-20T09:21:55+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-22 13:39:17" itemprop="dateModified" datetime="2021-01-22T13:39:17+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/20/Go-study-memo-2-if-for-switch-and-func-struct/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/20/Go-study-memo-2-if-for-switch-and-func-struct/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为了扩展的扩展"><a href="#为了扩展的扩展" class="headerlink" title="为了扩展的扩展"></a>为了扩展的扩展</h1><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 后接条件语句(表达式) , 无括号 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">9</span>&gt;<span class="number">8</span> &#123;</span><br><span class="line">	<span class="comment">//do some...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">8</span>&gt;<span class="number">8</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> expr1; expr2 ;expr3 &#123;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>expr1 为初试化变量语句, 仅执行一次<br>expr2 为循环条件语句, 每次循环前都会判断其值<br>expr3 是改变循环变量的地方, 每次循环后执行<br>其中expr1,expr2,expr3均可省略</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; ; &#123;</span><br><span class="line">	<span class="comment">// some code </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一种是仅留下 循环条件语句 如:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; <span class="number">9</span>&gt;<span class="number">8</span> ; &#123;</span><br><span class="line">	<span class="comment">// some code </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 2个分号 也可省略, 即:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">9</span>&gt;<span class="number">8</span> &#123;</span><br><span class="line">	<span class="comment">//some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>啊, 和java的while 多像</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">me := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"name"</span>:<span class="string">"wq"</span>,<span class="string">"age"</span>:<span class="string">"19"</span>,<span class="string">"long"</span>:<span class="string">"200"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> me &#123;</span><br><span class="line">	fmt.Println(k,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>嗯, 是的foreach(for in) 就是这个feel<br>尤其提示, 如果不使用 k , 请用_ 替代, 避免编译错误</p>
</blockquote>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> exp &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="comment">//do some ...</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>:</span><br><span class="line">		<span class="comment">//do some..</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">//do some..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于exp不需要括号<br>每个case后, 都默认带有break, 不会往下执行<br>如需执行后面的case,可使用fallthrough 关键字<br>可以用 , 号分隔代表多个case<br>default就不说了, 类似与if的else</p>
</blockquote>
<h3 id="最后写个冒泡排序法复习巩固下"><a href="#最后写个冒泡排序法复习巩固下" class="headerlink" title="最后写个冒泡排序法复习巩固下"></a>最后写个冒泡排序法复习巩固下</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    slice := []<span class="keyword">int</span>&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">88</span>,<span class="number">44</span>,<span class="number">20</span>&#125;</span><br><span class="line">    maopao(slice)</span><br><span class="line">    fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(slice []<span class="keyword">int</span>, index1 <span class="keyword">int</span>,index2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    temp := slice[index1]</span><br><span class="line">    slice[index1]=slice[index2]</span><br><span class="line">    slice[index2]=temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maopao</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt; <span class="built_in">len</span>(slice)<span class="number">-1</span>;i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt; <span class="built_in">len</span>(slice)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> slice[j]&gt;slice[j+<span class="number">1</span>] &#123;</span><br><span class="line">                swap(slice,j,j+<span class="number">1</span>)</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>99 乘法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    num, num2 := <span class="number">1</span>, <span class="number">1</span> </span><br><span class="line">    <span class="keyword">for</span> num&lt;=<span class="number">9</span> &#123;</span><br><span class="line">        num2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num2&lt;=num &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d * %d = %d\t"</span>,num2,num,num*num2)</span><br><span class="line">            num2++  </span><br><span class="line">        &#125;       </span><br><span class="line">        fmt.Println()</span><br><span class="line">        num++   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用了for的完整版 , if 判断<br>slice指针传递 可变性</p>
</blockquote>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="func语法"><a href="#func语法" class="headerlink" title="func语法"></a>func语法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span> <span class="params">(params...)</span> <span class="params">(returns...)</span></span> &#123;</span><br><span class="line">	<span class="comment">//some code</span></span><br><span class="line">	<span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如,无参无返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单参数,单返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">//some code</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多参数, 多返回值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span> <span class="params">(id <span class="keyword">int</span>, skills []<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span> , <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//some code</span></span><br><span class="line">	numbers := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>:<span class="number">1</span>,<span class="string">"two"</span>:<span class="number">2</span>,<span class="string">"three"</span>:<span class="number">3</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> , numbers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大概就是这些, 写个阶乘玩玩</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jiechen</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n==<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n * jiechen(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sum := jiechen(<span class="number">4</span>) <span class="comment">//24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="defer延迟"><a href="#defer延迟" class="headerlink" title="defer延迟"></a>defer延迟</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"func code run"</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"defer"</span>,i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"func code last"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>后进先出的队列机制, 逆序输出了 i<br>延迟执行, 在return之前</p>
</blockquote>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	. <span class="string">"fmt"</span></span><br><span class="line">	_ <span class="string">"fmt"</span></span><br><span class="line">	f <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用 . 代表无需前缀, 直接调用fmt的方法<br>用_ 代表不使用fmt的函数, 仅加载<br>其他名称则为别名 , 如 f.Println()</p>
</blockquote>
<h3 id="a-func-is-a-type-or-a-value"><a href="#a-func-is-a-type-or-a-value" class="headerlink" title="a func is a type or a value ??"></a>a func is a type or a value ??</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"slice:"</span>,slice)</span><br><span class="line">    odd := filter(slice,isOdd)</span><br><span class="line">    even:= filter(slice,isEven)</span><br><span class="line">    fmt.Println(odd,even)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> funcType <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOdd</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> ==<span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> ==<span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(slice []<span class="keyword">int</span>,f funcType)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> f(value)&#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将func作为一个类型, 置于参数中, 由于go也是强类型, 所以需要添加自定义类型<br>将func作为实参(值)传递给另一个函数, 然后被调用</p>
</blockquote>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><h3 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p person</span><br><span class="line">p.name=<span class="string">"wq"</span></span><br><span class="line">p.age = <span class="number">79</span></span><br><span class="line"></span><br><span class="line">p1 := person&#123;<span class="string">"wq"</span>,<span class="number">89</span>&#125;</span><br><span class="line">p2 := person&#123;name:<span class="string">"wq"</span>,age:<span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> humen <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	long <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Skills []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	humen</span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">	Skills</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	p := person&#123;humen&#123;<span class="string">"wq"</span>,<span class="number">39</span>,<span class="number">99</span>&#125;,<span class="number">666</span>,[]<span class="keyword">int</span>&#123;<span class="string">"c"</span>,<span class="string">"java"</span>,<span class="string">"c#"</span>&#125;,<span class="string">"pwq"</span>,<span class="string">"110"</span>&#125;</span><br><span class="line">	fmt.Println(p,p.name,p.age,p.long,p.phone,p.Skills,p.<span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">//可直接访问匿名字段的 字段, 但可能会覆盖匿名字段的 字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过2个struct 实现了类似 继承<br>通过不给字段名,仅给字段类型定义一个匿名字段<br>可直接访问匿名字段, 但可能覆盖匿名字段中的字段<br>匿名字段 还可以为 自定义类型, 基础类型 , slice, map, array等</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2020/05/20/Go-study-memo-1-int-bool-string-error-array-slice-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/Go-study-memo-1-int-bool-string-error-array-slice-map/" class="post-title-link" itemprop="url">Go 学习笔记(一) : 3种方式得变量 / 常量与iota / 数据类型(int,bool,string,error,array,slice,map)</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 09:20:11" itemprop="dateCreated datePublished" datetime="2020-05-20T09:20:11+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-22 13:39:17" itemprop="dateModified" datetime="2021-01-22T13:39:17+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/20/Go-study-memo-1-int-bool-string-error-array-slice-map/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/20/Go-study-memo-1-int-bool-string-error-array-slice-map/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为了基础的基础"><a href="#为了基础的基础" class="headerlink" title="为了基础的基础"></a>为了基础的基础</h1><h2 id="package-import"><a href="#package-import" class="headerlink" title="package , import"></a>package , import</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello World !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>包 , 与python类似, 与java不同. 用于模块化. 通过声明包, 和导入包可以实现程序的相互调用. 如 导入 fmt , 使用fmt的函数Println()<br>main.main()是 程序的运行入口, 无参数, 无返回值</p>
</blockquote>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> complete <span class="keyword">string</span> = <span class="string">"I 'm complete !"</span></span><br><span class="line">	<span class="keyword">var</span> autoType = <span class="string">"I'm auto "</span></span><br><span class="line">	<span class="keyword">var</span> simple := <span class="string">"I'm simple "</span></span><br><span class="line">	complete, autoType, simple = <span class="string">"complete again"</span>, <span class="string">"auto again"</span>, <span class="string">"simple again"</span></span><br><span class="line">	fmt.Println(complete,autoType,simple)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示, 获得一个变量有3种方式</p>
<blockquote>
<p>完整的声明和赋值 (也可只声明, 后赋值)<br>声明时不写类型 , 必须同时赋值自动推导类型<br>省略var , 使用 := 声明+赋值, 仅用于声明<br>###常量</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SEX_MALE <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> SEX_FEMALE = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	MALE = <span class="literal">iota</span>  <span class="comment">//0</span></span><br><span class="line">	FEMAILE  <span class="comment">//1</span></span><br><span class="line">	WHAT <span class="comment">//2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用const关键字可声明常量, 使用()可一次声明多个 使用iota可便捷声, 规则为:<br>遇到const重置为0<br>同一行值相同<br>上一行为iota, 则本行不赋值时为 上一行iota值 + 1, 以此类推</p>
</blockquote>
<h2 id="数据类型小计"><a href="#数据类型小计" class="headerlink" title="数据类型小计"></a>数据类型小计</h2><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><blockquote>
<p>int : int8 , int16, int32, int 64<br>uint : uint8, uint16, uint32, uint64<br>rune, int, byte</p>
</blockquote>
<p>其中 int 与 uint 的区别是 有无符号 , rune 是 int32的别称, byte是uint8的别称, int虽然是32位但与int32不可互用</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>默认为false, 与java类似, 数0,空等不代表 false</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span> </span><br><span class="line">fmt.Println(ok) <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> gameover = <span class="literal">true</span></span><br><span class="line">isover := <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>与java类似, 双引号包围</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"I'm a string!"</span></span><br></pre></td></tr></table></figure>
<p>当多行时 使用 反引号 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multistr = <span class="string">`This is </span></span><br><span class="line"><span class="string">a </span></span><br><span class="line"><span class="string">multiline</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>使用 ` 时, 不转义\n,\t等</p>
<blockquote>
<p>使用string类型时, 注意string不可变, 类似java . 但可强转为byte[] 类型后操作</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hello"</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'c'</span> <span class="comment">//wrong!!!</span></span><br><span class="line"><span class="keyword">var</span> c = (<span class="keyword">byte</span>[])str</span><br><span class="line">c[<span class="number">0</span>]=<span class="string">'c'</span></span><br></pre></td></tr></table></figure>

<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>Go内置有一个error类型，专门用来处理错误信息，Go的package里面还专门有一个包errors来处理错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">"I am error message!"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>在go中, array是值类型, 而slice(切片),map 才是引用类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">array:=[...]<span class="keyword">int</span>&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;</span><br><span class="line">arr2 := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">//后7个元素则为零值 </span></span><br><span class="line"><span class="keyword">var</span> arr3 [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">arr3[<span class="number">0</span>]=<span class="number">9</span></span><br><span class="line">arr3[<span class="number">1</span>]=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于数组的赋值,取值与c和java类似<br>对于数组的初始化,分完整,部分(不写长度, 不写所有元素)<br>注意array是值类型, 互相传递赋值时, 不会相互影响</p>
</blockquote>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">aslice := array[:]</span><br><span class="line">bslice := aslice[<span class="number">2</span>:]</span><br><span class="line">bslice[<span class="number">3</span>] = <span class="number">99</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">-99</span></span><br><span class="line">fmt.Println(aslice,bslice)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>切片 , 可通过数组[n:m] 获取<br>切片是引用类型, 改变bslice , 同时aslice也会改变<br>改变arr不会改变aslice , 因为array是值类型</p>
</blockquote>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> =<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"all"</span>:<span class="number">9999</span>&#125;</span><br><span class="line">    others := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    others[<span class="string">"name"</span>]=<span class="number">007</span></span><br><span class="line">    numbers[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">    numbers[<span class="string">"ten"</span>] = <span class="number">10</span></span><br><span class="line">    numbers[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line">    <span class="built_in">delete</span>(numbers,<span class="string">"one"</span>)</span><br><span class="line">    val , ok := numbers[<span class="string">"not ex"</span>]</span><br><span class="line">    fmt.Println(numbers,numbers[<span class="string">"one"</span>],others,<span class="built_in">len</span>(numbers),val,ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>map类似与python种的字典, 操作与slice类似<br>元素赋值, 取值使用[]<br>map初始化使用 make 或者 map[string]int{}<br>使用delete删除key<br>使用多返回值检测是否存在key<br>使用len查看元素个数</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gudqs7.github.io/2020/05/20/soldity-source-code-memo-Fomo3D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gudqs7">
      <meta itemprop="description" content="心累没钱躺尸中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gudqs7's note">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/20/soldity-source-code-memo-Fomo3D/" class="post-title-link" itemprop="url">远古Fomo3D智能合约源码分析(附送单机部署指南)</a>
        </h2>

        <div class="post-meta">
			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-20 09:05:21" itemprop="dateCreated datePublished" datetime="2020-05-20T09:05:21+08:00">2020-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-22 13:39:17" itemprop="dateModified" datetime="2021-01-22T13:39:17+08:00">2021-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blockchain/" itemprop="url" rel="index"><span itemprop="name">blockchain</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/blockchain/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/20/soldity-source-code-memo-Fomo3D/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/20/soldity-source-code-memo-Fomo3D/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Fomo3D"><a href="#Fomo3D" class="headerlink" title="Fomo3D"></a>Fomo3D</h1><h2 id="Fomo3D-合约源码分析"><a href="#Fomo3D-合约源码分析" class="headerlink" title="Fomo3D 合约源码分析"></a>Fomo3D 合约源码分析</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="环境准备-用于调试合约"><a href="#环境准备-用于调试合约" class="headerlink" title="环境准备 (用于调试合约)"></a>环境准备 (用于调试合约)</h4><ul>
<li>git, nodejs, Chrome</li>
<li>ganache-cli, remix-ide</li>
</ul>
<h4 id="代码-及-IDE"><a href="#代码-及-IDE" class="headerlink" title="代码 及 IDE"></a>代码 及 IDE</h4><blockquote>
<p>安装好 Git 后, 下载源码 <code>git clone https://github.com/reedhong/fomo3d_clone.git</code><br>安装好 nodejs 后, 使用 npm 安装2个东西(建议使用国内镜像源:cnpm)<br><code>npm install ganache-cli -g &amp; npm install remix-ide -g</code>  </p>
</blockquote>
<blockquote>
<p>至于IDE 上的选择, 只要 IDE 支持 sol 语法, 如 idea 就有 solidity 插件, 亦或者 vscode 也很棒, 而且中文支持比较好, 还对于大文件 js 及 json 打开速度比较快, 编辑也比较流畅( idea 可能是插件太多, 各种语法解析比较卡)</p>
</blockquote>
<h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+-- interface	 </span><br><span class="line">|	 +-- DiviesInterface.sol</span><br><span class="line">|	 +-- F3DexternalSettingsInterface.sol</span><br><span class="line">|	 +-- HourglassInterface.sol</span><br><span class="line">|	 +-- JIincForwarderInterface.sol</span><br><span class="line">|	 +-- JIincInterfaceForForwarder.sol</span><br><span class="line">|	 +-- PlayerBookInterface.sol</span><br><span class="line">|	 +-- PlayerBookReceiverInterface.sol</span><br><span class="line">|	 +-- TeamJustInterface.sol</span><br><span class="line">|	 +-- otherFoMo3D.sol</span><br><span class="line">+-- library	</span><br><span class="line">|	 +-- F3DKeysCalcLong.sol</span><br><span class="line">|	 +-- F3Ddatasets.sol</span><br><span class="line">|	 +-- MSFun.sol	</span><br><span class="line">|	 +-- NameFilter.sol</span><br><span class="line">|	 +-- SafeMath.sol	</span><br><span class="line">|	 +-- UintCompressor.sol</span><br><span class="line">+-- Divies.sol</span><br><span class="line">+-- F3Devents.sol	</span><br><span class="line">+-- F3DexternalSettings.sol	</span><br><span class="line">+-- FoMo3Dlong.sol	</span><br><span class="line">+-- Hourglass.sol	</span><br><span class="line">+-- JIincForwarder.sol</span><br><span class="line">+-- PlayerBook.sol	</span><br><span class="line">+-- TeamJust.sol	</span><br><span class="line">+-- modularLong.sol</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上就是 reed 大佬整理的源码结构, 看到这么多文件, 心里感觉好慌, 别怕, 其实大多数文件都是摆设, 没有太多逻辑代码, 我们主要需要看的, 也就是那么几个合约, 既然如此, 我们先排除一些用处不大, 非游戏关键核心的合约</p>
</blockquote>
<h3 id="各大收款合约"><a href="#各大收款合约" class="headerlink" title="各大收款合约"></a>各大收款合约</h3><ul>
<li>JIincForwarder.sol (JIincForwarderInterface 类型变量的实际引用), 用于向项目基金会转账</li>
<li>otherFoMo3D.sol (游戏 activate 前必须设置的 otherFomo 变量的实际引用), 向不知道哪个地址转账</li>
<li>Divies.sol (DeviesInterface 类型变量的实际引用), 用于 p3d 分红</li>
</ul>
<h4 id="JIincForwarder-sol"><a href="#JIincForwarder-sol" class="headerlink" title="JIincForwarder.sol"></a>JIincForwarder.sol</h4><blockquote>
<p>这个合约就是向 基金会地址 转发 ether, 单独写一个中转的好处就是灵活, 这个合约可以做到基金会地址安全转移, 也就是说中途可以改变基金会的转账地址, 而这个过程需要新旧2个合约共同完成(旧.startMigration(新地址)–&gt; 新.finishMigration(), 中途 旧方可以 旧.cancelMigration(), 而完成地址转移后, 新地址完全替代旧地址 )<br>其中比较转账逻辑就是调用下面的这个接口对应的实际合约 的 deposit 方法 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface JIincInterfaceForForwarder &#123;</span><br><span class="line">    function deposit(address _addr) external payable returns (bool);</span><br><span class="line">    function migrationReceiver_setup() external returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>至于现在这个基金会的地址到底是啥, 可以通过 status() 方法查看哦</p>
</blockquote>
<h4 id="otherFoMo3D-sol"><a href="#otherFoMo3D-sol" class="headerlink" title="otherFoMo3D.sol"></a>otherFoMo3D.sol</h4><blockquote>
<p>这个合约很有意思, 或者说它的背后很有意思, 大家都想知道 其他的 fomo 到底是啥, 据说不是 soon 版<br>至于逻辑上, 这个 potSwap 的调用时机是在玩家买 key 的时候, 而它的作用, 我认为是游戏间的奖池交换<br>比如说, fomolong 共有100个 ether 买入, 那么就会有1%流向 otherFomo 的奖池, 同理, otherFomo 里应该也会有这个逻辑的存在, 这么做有啥用就交给大家自己思考了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">interface otherFoMo3D &#123;</span><br><span class="line">    function potSwap() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fomo3Dlong 代码: (fomo3Dlong本身也可以是一个 otherFomo, 甚至在 真正的otherFomo 里它的那个 otherFomo 就是 fomo3Dlong 也不一定)</span><br><span class="line"></span><br><span class="line">function potSwap()</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; setup local rID</span><br><span class="line">    uint256 _rID &#x3D; rID_ + 1;</span><br><span class="line">    </span><br><span class="line">    round_[_rID].pot &#x3D; round_[_rID].pot.add(msg.value); &#x2F;&#x2F; 奖池金额增加</span><br><span class="line">    emit F3Devents.onPotSwapDeposit(_rID, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Divies-sol"><a href="#Divies-sol" class="headerlink" title="Divies.sol"></a>Divies.sol</h4><blockquote>
<p>这部分是给 P3D 分红的, 代码很简单, 就一个转账的调用, 调用时机上, 首先是买 key 的钱被瓜分时, 有它的一份, 其次当一轮 (Round) 结束后, 又会根据赢的队伍来分配奖池, 抽出一部分给到 P3D</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface DiviesInterface &#123;</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然这其中如何给 P3D 分红我还没搞太懂, 大致流程貌似是: 买 key分红 –&gt; 调用 Divies 的 deposit 方法, Divies 合约中此方法无具体实现(空方法, 啥也不干, 就收钱) –&gt; 预计什么时候会有 P3D 的玩家来调用这个合约的 distribute 方法, 而 这个方法的作用似乎是将 分红转来的钱拿去投入 P3D, 然后卖出, 根据传入的百分比决定是否继续投入或重复投入和售出多少次, 最后把钱提现回来(可能就没多少了), 而钱通过10% 的分红机制全给了 P3D 的用户??? 这一块一直不太懂, 而且这个方法的 调用时机不明, 调用时还增加了 时间限制和拥挤队列的限制. 总的将这里面就是存在给 P3D 分红的钱, 但这钱啥时候 给 P3D, 我还是没猜出来.</p>
</blockquote>
<h3 id="3大合约"><a href="#3大合约" class="headerlink" title="3大合约"></a>3大合约</h3><blockquote>
<p>光是转账合约就感觉有些看不懂了, 真是头疼啊, 只好把不懂的放下, 留待日后琢磨. 还是先分析游戏核心代码吧</p>
</blockquote>
<ul>
<li>TeamJust.sol</li>
<li>PlayerBook.sol</li>
<li>FoMo3Dlong.sol</li>
</ul>
<h4 id="TeamJust-sol"><a href="#TeamJust-sol" class="headerlink" title="TeamJust.sol"></a>TeamJust.sol</h4><blockquote>
<p>首先看 TeamJust.sol , 这个是用来做权限控制的, 里面 除了与 muitiSig( 这个以后说 )相关的几个方法, 也就是管理 admin 和 dev 了, 如 <code>addAdmin</code> <code>removeAdmin</code>, 而 <code>isDev</code> <code>isAdmin</code> 则是拿来给其他合约调用(比如 playerBook 的 onlyDevs) </p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function setup(address _addr)</span><br><span class="line">    onlyDevs()</span><br><span class="line">    public</span><br><span class="line">&#123;</span><br><span class="line">    require( address(Jekyll_Island_Inc) &#x3D;&#x3D; address(0) );</span><br><span class="line">    Jekyll_Island_Inc &#x3D; JIincForwarderInterface(_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>经过我的观察发现, 这个 teamJust 合约应该是比较后加的, 比如 fomo3Dlong 合约的激活就没有使用, 而2个合约不同的对于 <code>Jekyll_Island_Inc</code> 的赋值也让我推测这可能是较新的写法. 我也觉得这种通过调用合约赋值的方式比较好, 所以在我整的 项目 <a href="https://github.com/gudqs7/fomo3d_truffle" target="_blank" rel="noopener">fomo3d_truffle</a> 中, 我把 activate 函数的用户限制 也改成了 用 teamJust 来做, 而 其中的 playerBook 和 teamJust 实际合约地址也是通过 类似上面 setup 的方式 赋值, 这么做还有个好处就是可以通过 truffle 一键把这些合约部署且赋值, 而不是弄一个改源码重新编译这种测试起来比较麻烦的方式</p>
</blockquote>
<h4 id="PlayerBook-sol"><a href="#PlayerBook-sol" class="headerlink" title="PlayerBook.sol"></a>PlayerBook.sol</h4><blockquote>
<p>这个合约主要是管理 玩家信息, 而玩家信息则分为 name, id, addr, id 是根据地址是否存在自增生成的, 而 name 则是通过 花钱注册可用于推广获取提成的! 合约内大多方法都像个数据库一样均为 crud 操作, 夹带的逻辑无非就是一些验证, 其他的都比较少, 里面比较有意思的点就是 addGame </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function addGame(address _gameAddress, string _gameNameStr)</span><br><span class="line">    onlyDevs()</span><br><span class="line">    public</span><br><span class="line">&#123;</span><br><span class="line">    require(gameIDs_[_gameAddress] &#x3D;&#x3D; 0, &quot;derp, that games already been registered&quot;);</span><br><span class="line">    </span><br><span class="line">    if (multiSigDev(&quot;addGame&quot;) &#x3D;&#x3D; true)</span><br><span class="line">    &#123;deleteProposal(&quot;addGame&quot;);</span><br><span class="line">        gID_++;</span><br><span class="line">        bytes32 _name &#x3D; _gameNameStr.nameFilter();</span><br><span class="line">        gameIDs_[_gameAddress] &#x3D; gID_;</span><br><span class="line">        gameNames_[_gameAddress] &#x3D; _name;</span><br><span class="line">        games_[gID_] &#x3D; PlayerBookReceiverInterface(_gameAddress);</span><br><span class="line">    </span><br><span class="line">        games_[gID_].receivePlayerInfo(1, plyr_[1].addr, plyr_[1].name, 0);</span><br><span class="line">        games_[gID_].receivePlayerInfo(2, plyr_[2].addr, plyr_[2].name, 0);</span><br><span class="line">        games_[gID_].receivePlayerInfo(3, plyr_[3].addr, plyr_[3].name, 0);</span><br><span class="line">        games_[gID_].receivePlayerInfo(4, plyr_[4].addr, plyr_[4].name, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里是把 fomo3Dlong 的地址和名称传入, 然后就会通过接口向 fomo3Dlong 传入几个预设的玩家信息(来自 playerbook的构造方法), 而调用过这个方法后, <code>registerNameXxxxFromDapp</code> 这样的方法才能不被 <code>isRegisteredGame</code> 拦截. 所以部署时, 这一步是必做的.   </p>
</blockquote>
<blockquote>
<p>其他的几个点: 可设置的注册费用, 且费用被转到基金会;  购买 key 邀请分红总是和访问的链接的推广码有关, 只有在无推广码时, 才从历史中获取 laff, 而 laff 每访问一个推广码(并买了 key)都在改变</p>
</blockquote>
<h4 id="FoMo3Dlong-sol"><a href="#FoMo3Dlong-sol" class="headerlink" title="FoMo3Dlong.sol"></a>FoMo3Dlong.sol</h4><blockquote>
<p>主要合约啊, 先看下 所有的 state 变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">string constant public name &#x3D; &quot;FoMo3D Long Official&quot;;</span><br><span class="line">string constant public symbol &#x3D; &quot;F3D&quot;;</span><br><span class="line">uint256 private rndExtra_ &#x3D; extSettings.getLongExtra();     &#x2F;&#x2F; length of the very first ICO </span><br><span class="line">uint256 private rndGap_ &#x3D; extSettings.getLongGap();         &#x2F;&#x2F; length of ICO phase, set to 1 year for EOS.</span><br><span class="line">uint256 constant private rndInit_ &#x3D; 1 hours;                &#x2F;&#x2F; round timer starts at this</span><br><span class="line">uint256 constant private rndInc_ &#x3D; 30 seconds;              &#x2F;&#x2F; every full key purchased adds this much to the timer</span><br><span class="line">uint256 constant private rndMax_ &#x3D; 24 hours;                &#x2F;&#x2F; max length a round timer can be  </span><br><span class="line">uint256 public airDropPot_;             &#x2F;&#x2F; person who gets the airdrop wins part of this pot</span><br><span class="line">uint256 public airDropTracker_ &#x3D; 0;     &#x2F;&#x2F; incremented each time a &quot;qualified&quot; tx occurs.  used to determine winning air drop</span><br><span class="line">uint256 public rID_;  </span><br><span class="line"></span><br><span class="line">mapping (address &#x3D;&gt; uint256) public pIDxAddr_;          &#x2F;&#x2F; (addr &#x3D;&gt; pID) returns player id by address</span><br><span class="line">mapping (bytes32 &#x3D;&gt; uint256) public pIDxName_;          &#x2F;&#x2F; (name &#x3D;&gt; pID) returns player id by name</span><br><span class="line">mapping (uint256 &#x3D;&gt; F3Ddatasets.Player) public plyr_;   &#x2F;&#x2F; (pID &#x3D;&gt; data) player data</span><br><span class="line">mapping (uint256 &#x3D;&gt; mapping (uint256 &#x3D;&gt; F3Ddatasets.PlayerRounds)) public plyrRnds_;    &#x2F;&#x2F; (pID &#x3D;&gt; rID &#x3D;&gt; data) player round data by player id &amp; round id</span><br><span class="line">mapping (uint256 &#x3D;&gt; mapping (bytes32 &#x3D;&gt; bool)) public plyrNames_; &#x2F;&#x2F; (pID &#x3D;&gt; name &#x3D;&gt; bool) list of names a player owns.  (used so you can change your display name amongst any name you own)</span><br><span class="line"></span><br><span class="line">mapping (uint256 &#x3D;&gt; F3Ddatasets.Round) public round_;   &#x2F;&#x2F; (rID &#x3D;&gt; data) round data</span><br><span class="line">mapping (uint256 &#x3D;&gt; mapping(uint256 &#x3D;&gt; uint256)) public rndTmEth_;      &#x2F;&#x2F; (rID &#x3D;&gt; tID &#x3D;&gt; data) eth in per team, by round id and team id</span><br><span class="line"></span><br><span class="line">mapping (uint256 &#x3D;&gt; F3Ddatasets.TeamFee) public fees_;          &#x2F;&#x2F; (team &#x3D;&gt; fees) fee distribution by team</span><br><span class="line">mapping (uint256 &#x3D;&gt; F3Ddatasets.PotSplit) public potSplit_;     &#x2F;&#x2F; (team &#x3D;&gt; fees) pot split distribution by team</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大部分都可以通过 变量名 猜出个大概, 实在不行可以搜索大致看一下哪里用了, 结合的先看一下, 其他都是各种数据, 没啥复杂的, 这里就主要看下 fees_ 和 potSplit_</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Team allocation percentages</span><br><span class="line">&#x2F;&#x2F; (F3D, P3D) + (Pot , Referrals, Community)</span><br><span class="line">    &#x2F;&#x2F; Referrals &#x2F; Community rewards are mathematically designed to come from the winner&#39;s share of the pot.</span><br><span class="line">fees_[0] &#x3D; F3Ddatasets.TeamFee(30,6);   &#x2F;&#x2F;50% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot</span><br><span class="line">fees_[1] &#x3D; F3Ddatasets.TeamFee(43,0);   &#x2F;&#x2F;43% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot</span><br><span class="line">fees_[2] &#x3D; F3Ddatasets.TeamFee(56,10);  &#x2F;&#x2F;20% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot</span><br><span class="line">fees_[3] &#x3D; F3Ddatasets.TeamFee(43,8);   &#x2F;&#x2F;35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; how to split up the final pot based on which team was picked</span><br><span class="line">&#x2F;&#x2F; (F3D, P3D)</span><br><span class="line">potSplit_[0] &#x3D; F3Ddatasets.PotSplit(15,10);  &#x2F;&#x2F;48% to winner, 25% to next round, 2% to com</span><br><span class="line">potSplit_[1] &#x3D; F3Ddatasets.PotSplit(25,0);   &#x2F;&#x2F;48% to winner, 25% to next round, 2% to com</span><br><span class="line">potSplit_[2] &#x3D; F3Ddatasets.PotSplit(20,20);  &#x2F;&#x2F;48% to winner, 10% to next round, 2% to com</span><br><span class="line">potSplit_[3] &#x3D; F3Ddatasets.PotSplit(30,10);  &#x2F;&#x2F;48% to winner, 10% to next round, 2% to com</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fees_ 就是用来决定 玩家 买 key 后, 买 key 的 ether 怎么分配, 其中 2% 基金会(com) + 1% (otherFomo) + 1% 空投池 + fees_[].p3d % P3D + fees_[].gen % 收益, 10% 给 推荐人(无则给P3D)<br>总结就是 14% 固定 + 86% 可设定, 86% 分3块( gen+p3d+pot ),所以2队是56% gen + 10% p3d + 20% pot, 其他队伍类似<br>potSplit_ 类似, 固定的 48%(win)+2%(com) + 50% 可设定, 分3块(gen+p3d+nextround), 如2队的 20 gen + 20 p3d + 10 next</p>
</blockquote>
<p>然后讲讲所有的方法, 简单的归类下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">修饰器</span><br><span class="line">isActivated() 			&#x2F;&#x2F;拦截游戏未激活</span><br><span class="line">isHuman()					&#x2F;&#x2F;听说拦截非人类?</span><br><span class="line">isWithinLimits(eth)		&#x2F;&#x2F;拦截太穷的人和 v 神 ???</span><br><span class="line"></span><br><span class="line">ether 买		&#x2F;&#x2F;从不同地址进的, 第一个参数是推荐人标识, 第二个是选的 team</span><br><span class="line">buyXid(id, team)  	</span><br><span class="line">buyXaddr(addr, team)</span><br><span class="line">buyXname(name, team)</span><br><span class="line"></span><br><span class="line">valuts 买		&#x2F;&#x2F;从不同地址进的, 第一个参数是推荐人标识, 第二个是选的 team, 第三个是根据 key 数量计算出来的 eth</span><br><span class="line">reLoadXid(id, team, eth)	</span><br><span class="line">reLoadXaddr(addr, team, eth)</span><br><span class="line">reLoadXname(name, team, eth)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buyCore  			&#x2F;&#x2F; 这里就是判断了一下本轮是否结束了, 然后直接调用的 core,当然结束会走 endRound</span><br><span class="line">reLoadCore		&#x2F;&#x2F; 同上, 结束的判断, 还有就是减去 gen 的金额, 再调用 core</span><br><span class="line">core				&#x2F;&#x2F; 限制前100eth, 更新 end 时间, 超过0.1eth 判断空投, 更新玩家及轮次等数据, 调用2个分红方法</span><br><span class="line">distributeExternal 	&#x2F;&#x2F; 给固定的13% (10% aff,2% com,1% otherFomo) 及 P3D 打钱</span><br><span class="line">distributeInternal	&#x2F;&#x2F; 给空投1% 和 gen 和 pot 打钱</span><br><span class="line"></span><br><span class="line">提现跑路</span><br><span class="line">withdraw() 	</span><br><span class="line"></span><br><span class="line">结束一轮</span><br><span class="line">endRound()	&#x2F;&#x2F; pot 分成5分, win 拿48%, 2%给 com, 还有 gen, p3d, nextRound 则根据配置来分配, 其中 p3d 和下一轮逻辑比较简单, 而 gen 我还没太懂, 因为涉及到 mask 的我都没看明白( 没时间细看, 全是数学, 要慢慢推理分析 )		</span><br><span class="line"></span><br><span class="line">注册 name		&#x2F;&#x2F;注册一个 name 用于推广获取提成, 第一个参数是 name 标识, 第二个是推荐人的标识, 第三个是是否同步到其他游戏</span><br><span class="line">registerNameXID(name, id, all) </span><br><span class="line">registerNameXaddr(name, addr, all)</span><br><span class="line">registerNameXname(name, name, all)</span><br><span class="line"></span><br><span class="line">玩家信息相关 , 前2个一般是给外部调用的</span><br><span class="line">receivePlayerInfo			&#x2F;&#x2F;将传入玩家信息储存</span><br><span class="line">receivePlayerNameList		&#x2F;&#x2F;储存玩家的所有name</span><br><span class="line">determinePID				&#x2F;&#x2F;确定玩家信息, 若无则生成一个 pid</span><br><span class="line"></span><br><span class="line">玩家分红, keys相关</span><br><span class="line">calcUnMaskedEarnings  		&#x2F;&#x2F; 实现看不懂, 不过方法作用是用来计算能提现的收益</span><br><span class="line">calcKeysReceived(rid, eth)	&#x2F;&#x2F; 根据轮次返回 用eth能买多少 keys</span><br><span class="line">iWantXKeys					&#x2F;&#x2F; 根据 key 数量返回需要多少 eth</span><br><span class="line">managePlayer					&#x2F;&#x2F; 第 x 轮时将上一轮的收益移至此轮, 仅轮次开始后第一次购买执行</span><br><span class="line">updateGenVault				&#x2F;&#x2F; 计算及更新收益</span><br><span class="line">updateMasks					&#x2F;&#x2F; 更新被锁定的收益</span><br><span class="line">withdrawEarnings				&#x2F;&#x2F; 计算可提现的收益</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这么多方法, 我也只能列个大致作用和我看的懂的逻辑, 具体的细节等我参透再出文章  </p>
</blockquote>
<blockquote>
<p>最后总结游戏大致逻辑 :  玩家买 key–&gt; buyXxx(relaodXxx) 方法–&gt; xxxCore –&gt; core –&gt; distributeExternal &amp; distributeInternal –&gt; 游戏结束 –&gt; 玩家 buy 触发 endRound –&gt; 分了钱 pot 的钱, 部分转入下一轮 –&gt; 激活新一轮 –&gt; 接上最开始 进入循环 !!! 当然中途可以提现自己没锁住的收益, 以及注册 name 拉人啥的. </p>
</blockquote>
<h3 id="几个有意思的类库"><a href="#几个有意思的类库" class="headerlink" title="几个有意思的类库"></a>几个有意思的类库</h3><h4 id="MSFun-sol"><a href="#MSFun-sol" class="headerlink" title="MSFun.sol"></a>MSFun.sol</h4><blockquote>
<p>首先说下, 这个库是用来做多重签名的, 啥意思呢? 就是一个方法, 必须好几个(多)人同意执行, 最后才会执行. 用法如下: </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*                                ┌────────────────────┐</span><br><span class="line">*                                │ Setup Instructions │</span><br><span class="line">*                                └────────────────────┘</span><br><span class="line">* (Step 1) import the library into your contract</span><br><span class="line">* </span><br><span class="line">*    import &quot;.&#x2F;MSFun.sol&quot;;</span><br><span class="line">*</span><br><span class="line">* (Step 2) set up the signature data for msFun</span><br><span class="line">* </span><br><span class="line">*     MSFun.Data private msData;</span><br><span class="line">*                                ┌────────────────────┐</span><br><span class="line">*                                │ Usage Instructions │</span><br><span class="line">*                                └────────────────────┘</span><br><span class="line">* at the beginning of a function</span><br><span class="line">* </span><br><span class="line">*     function functionName() </span><br><span class="line">*     &#123;</span><br><span class="line">*         if (MSFun.multiSig(msData, required signatures, &quot;functionName&quot;) &#x3D;&#x3D; true)</span><br><span class="line">*         &#123;</span><br><span class="line">*             MSFun.deleteProposal(msData, &quot;functionName&quot;);</span><br><span class="line">* </span><br><span class="line">*             &#x2F;&#x2F; put function body here </span><br><span class="line">*         &#125;</span><br><span class="line">*     &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大致就是先导包, 然后定义一个 MSFun.data 作为区分合约的标识, 然后再方法中使用 if 包围, if 第一句就是将之前的签名清空</p>
</blockquote>
<blockquote>
<p>MSFun.multiSig( data标识, 需要签名的数量, 方法名称 )</p>
</blockquote>
<blockquote>
<p>最后说下此类库在 fomo 中的样子: 首先 data 照旧, 而需要签名的数量来自 teamJust.sol, 它的定义是构造是初始为1, 以后每 add 一个 admin 或 dev 就把对应的 requiredSignatures 加一, remove 同理, 减一. 所以在部署时不改代码的话, 只要满足对应的身份限制, 加了这个MSFun.muitiSig 的方法默认是一个人调用就能执行</p>
</blockquote>
<h4 id="SafeMath-sol"><a href="#SafeMath-sol" class="headerlink" title="SafeMath.sol"></a>SafeMath.sol</h4><blockquote>
<p>这个没啥好说的, 操作金额必备, 听说狼人杀就是少了这个被攻击的(整形溢出), 也许可以不懂怎么攻击, 但一定要懂怎么防范, so </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @dev Multiplies two numbers, throws on overflow.</span><br><span class="line">*&#x2F;</span><br><span class="line">function mul(uint256 a, uint256 b) </span><br><span class="line">    internal </span><br><span class="line">    pure </span><br><span class="line">    returns (uint256 c) </span><br><span class="line">&#123;</span><br><span class="line">    if (a &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    c &#x3D; a * b;</span><br><span class="line">    require(c &#x2F; a &#x3D;&#x3D; b, &quot;SafeMath mul failed&quot;);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如你所见, 简单的判断即可确保不会由于溢出导致数据错乱</p>
</blockquote>
<h4 id="F3DKeysCalcLong-sol"><a href="#F3DKeysCalcLong-sol" class="headerlink" title="F3DKeysCalcLong.sol"></a>F3DKeysCalcLong.sol</h4><blockquote>
<p>我只能猜到作用, 至于完全理解… 没上过大学的我瑟瑟发抖</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keysRec(curEth, newEth)			&#x2F;&#x2F; 第一个参数就是using 后的调用方, 第二个参数是 准备花的 eth, 如我花0.01 eth , 用 round_[rId].eth.keysRec(0.01 eth); 得出的就是当前轮次时0.01eth 能买多少个 key, 注意返回的 keys 很大, 1个 实际上是 1e18 吧, </span><br><span class="line">ethRec(curKeys, sellKeys)		&#x2F;&#x2F; 同上, 输入想买的 keys 数量, 返回当前轮次 keys 基数下购买 keys 需要花的 eth</span><br><span class="line">keys(eth)						&#x2F;&#x2F; 根据 eth 计算可得多少 keys</span><br><span class="line">eth(keys)						&#x2F;&#x2F; 根据 keys 计算需要多少 eth</span><br></pre></td></tr></table></figure>

<p>bundle.js 中, iWantKeys 逻辑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = BN(<span class="built_in">parseInt</span>(count) * <span class="number">1e18</span>)</span><br><span class="line"><span class="keyword">let</span> priceQuotation = <span class="keyword">await</span> JUST.Bridges.Browser.contracts.Quick.read(<span class="string">'iWantXKeys'</span>, count)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>keys 和 eth 应该是对应的, 而 eth 的变化规律如果画图的话应该是 指数级上升? 可以画成函数看看</p>
</blockquote>
<h2 id="Fomo3D-源码部署指南"><a href="#Fomo3D-源码部署指南" class="headerlink" title="Fomo3D 源码部署指南"></a>Fomo3D 源码部署指南</h2><blockquote>
<p>代码在我的 gayhub 上 : <a href="https://github.com/gudqs7/fomo3d_truffle" target="_blank" rel="noopener">fomo3d_truffle</a> , 以下是 README</p>
</blockquote>
<h3 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约:"></a>部署合约:</h3><blockquote>
<p>一共部署了3个合约, 其中3个收款地址被砍掉(改成了部署者的地址), p3d 也砍掉了<br>3个合约 我偷懒没有把合约地址写死, 用的是后续的 set 方法, 所以如果 truffle migrate 最后那段报错了, 可能没有 set 成功, 需要用其他方式调用( truffle console, 或者 remix 等)<br>合约部署完, 如无报错, 直接复制走 FoMo3Dlong 的地址就行了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install ganache-cli -g</span><br><span class="line">ganache-cli -l 471238800 -g 1 # 开启 testrpc 同时设定 gasLimit 和 gasPrice</span><br><span class="line">truffle compile</span><br><span class="line">truffle migrate --reset # 执行后, 复制 FoMo3Dlong: 后跟的地址</span><br><span class="line">#直接输出最终合约地址, 将不会打印编译过程</span><br><span class="line">truffle migrate --reset | grep &#39;FoMo3Dlong: 0x&#39; | awk  &#39;&#123; print $2 &#125;&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>推荐做法<br>truffle migrate –reset &gt; migrate.log<br>cat migrate.log  # 查看有无错误, 如合约均部署成功,但最后报错, 可能有几个赋值方法没有执行(我部署到 kovan 时就发生了这事,可以参考 migrations/2_deploy_fomo3d.js逻辑手动执行)<br>cat migrate.log | grep ‘FoMo3Dlong: 0x’ | awk  ‘{ print $2 }’</p>
</blockquote>
<h3 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端:"></a>部署前端:</h3><blockquote>
<p>前端没有太多需要改的地方, 若使用英文版, 可参考下面命令行修改地址方式<br>若选择 bundle-cn.js 这个中文版, 则自己找到要修改的地方, 手动修改也行的<br>顺便说下 cn 里面还是 kovan测试网络的配置, 如需使用可把 bundle.js 里面的本地配置拷贝下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd src&#x2F;js</span><br><span class="line">sed -i &quot;&quot; &#39;s&#x2F;&#123;&#123;address&#125;&#125;&#x2F;0x00&#x2F;g&#39; bundle.js # 非 mac 去除 -i 后的 &quot;&quot;</span><br><span class="line">cd ..&#x2F;..&#x2F;</span><br><span class="line">npm install &amp; npm run start</span><br></pre></td></tr></table></figure>

<h3 id="游戏激活"><a href="#游戏激活" class="headerlink" title="游戏激活"></a>游戏激活</h3><blockquote>
<p>刚想到一个不一定靠谱的简单方式, 把 migrations 下那个 js 里面加一个 activate 的方法调用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install remix-ide -g  # 安装个本地的 remix-ide</span><br><span class="line">remix-ide  #注意此时处于项目根目录</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OK, 浏览器访问 <a href="localhost:8080">remix-ide</a>, 点击左上角第6个图标( Connect to localhost ), 弹框继续 connect</p>
<p>左边多出 localhost, 点击 contracts 下的 FoMo3Dlong.sol 文件, ctrl + s , 触发编译 , 下一步</p>
<p>点击右边的上边的 Run, 选择 web3 provider, 如端口不变, 一路 next, ok, 往下看, 有个选择 合约的 select, 选中 FoMo3Dlong, 然后在 输入框中输入 migrate 得到的合约地址, 然后点击 At Address</p>
<p>最后点下 合约的 activate 方法</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gudqs7"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">gudqs7</p>
  <div class="site-description" itemprop="description">心累没钱躺尸中</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gudqs7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gudqs7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gudqs7@gmail.com" title="E-Mail → mailto:gudqs7@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gudqs7</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://gudqs7s-note.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
